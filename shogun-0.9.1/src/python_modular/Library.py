# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.
# This file is compatible with both classic and new-style classes.

"""
The `Library` module gathers all miscellaneous Objects in the SHOGUN toolkit.
"""

import _Library
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types


class ShogunException(_object):
    """
    Class ShogunException defines an exception which is thrown whenever an
    error inside of shogun occurs.

    C++ includes: ShogunException.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShogunException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ShogunException, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, str) -> ShogunException

        constructor

        Parameters:
        -----------

        str:  exception string 
        """
        this = _Library.new_ShogunException(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_ShogunException
    __del__ = lambda self : None;
    def get_exception_string(*args):
        """
        get_exception_string(self) -> str

        get exception string

        the exception string 
        """
        return _Library.ShogunException_get_exception_string(*args)

ShogunException_swigregister = _Library.ShogunException_swigregister
ShogunException_swigregister(ShogunException)

MSG_GCDEBUG = _Library.MSG_GCDEBUG
MSG_DEBUG = _Library.MSG_DEBUG
MSG_INFO = _Library.MSG_INFO
MSG_NOTICE = _Library.MSG_NOTICE
MSG_WARN = _Library.MSG_WARN
MSG_ERROR = _Library.MSG_ERROR
MSG_CRITICAL = _Library.MSG_CRITICAL
MSG_ALERT = _Library.MSG_ALERT
MSG_EMERGENCY = _Library.MSG_EMERGENCY
MSG_MESSAGEONLY = _Library.MSG_MESSAGEONLY
class IO(_object):
    """
    Class IO, used to do input output operations throughout shogun.

    Any debug or error or progress message is passed through the functions
    of this class to be in the end written to the screen. Note that
    messages don't have to be written to stdout or stderr, but can be
    redirected to a file.

    C++ includes: io.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IO, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IO, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IO
        __init__(self, orig) -> IO

        copy constructor 
        """
        this = _Library.new_IO(*args)
        try: self.this.append(this)
        except: self.this = this
    def set_loglevel(*args):
        """
        set_loglevel(self, level)

        set loglevel

        Parameters:
        -----------

        level:  level of log messages 
        """
        return _Library.IO_set_loglevel(*args)

    def get_loglevel(*args):
        """
        get_loglevel(self) -> EMessageType

        get loglevel

        level of log messages 
        """
        return _Library.IO_get_loglevel(*args)

    def get_show_progress(*args):
        """
        get_show_progress(self) -> bool

        get show_progress

        if progress bar is shown 
        """
        return _Library.IO_get_show_progress(*args)

    def get_show_file_and_line(*args):
        """
        get_show_file_and_line(self) -> bool

        get show file and line

        if file and line should prefix messages 
        """
        return _Library.IO_get_show_file_and_line(*args)

    def message(*args):
        """
        message(self, prio, file, line, fmt, ?)

        print a message

        optionally prefixed with file name and line number from (use -1 in
        line to disable this)

        Parameters:
        -----------

        prio:  message priority

        file:  file name from where the message is called

        line:  line number from where the message is called

        fmt:  format string 
        """
        return _Library.IO_message(*args)

    def progress(*args):
        """
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1)
        progress(self, current_val, min_val=0.0, max_val=1.0)
        progress(self, current_val, min_val=0.0)
        progress(self, current_val)

        print progress bar

        Parameters:
        -----------

        current_val:  current value

        min_val:  minimum value

        max_val:  maximum value

        decimals:  decimals

        prefix:  message prefix 
        """
        return _Library.IO_progress(*args)

    def absolute_progress(*args):
        """
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1)
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0)
        absolute_progress(self, current_val, val, min_val=0.0)
        absolute_progress(self, current_val, val)

        print absolute progress bar

        Parameters:
        -----------

        current_val:  current value

        val:  value

        min_val:  minimum value

        max_val:  maximum value

        decimals:  decimals

        prefix:  message prefix 
        """
        return _Library.IO_absolute_progress(*args)

    def done(*args):
        """
        done(self)

        print 'done' with priority INFO, but only if progress bar is enabled

        """
        return _Library.IO_done(*args)

    def not_implemented(*args):
        """
        not_implemented(self, file, line)

        print error message 'not implemented' 
        """
        return _Library.IO_not_implemented(*args)

    def deprecated(*args):
        """
        deprecated(self, file, line)

        print warning message 'function deprecated' 
        """
        return _Library.IO_deprecated(*args)

    def buffered_message(*args):
        """
        buffered_message(self, prio, fmt, ?)

        print a buffered message

        Parameters:
        -----------

        prio:  message priority

        fmt:  format string 
        """
        return _Library.IO_buffered_message(*args)

    def skip_spaces(*args):
        """skip_spaces(str) -> str"""
        return _Library.IO_skip_spaces(*args)

    if _newclass:skip_spaces = staticmethod(skip_spaces)
    __swig_getmethods__["skip_spaces"] = lambda x: skip_spaces
    def skip_blanks(*args):
        """skip_blanks(str) -> str"""
        return _Library.IO_skip_blanks(*args)

    if _newclass:skip_blanks = staticmethod(skip_blanks)
    __swig_getmethods__["skip_blanks"] = lambda x: skip_blanks
    def get_target(*args):
        """
        get_target(self) -> FILE

        get target

        file descriptor for target 
        """
        return _Library.IO_get_target(*args)

    def set_target(*args):
        """
        set_target(self, target)

        set target

        Parameters:
        -----------

        target:  file descriptor for target 
        """
        return _Library.IO_set_target(*args)

    def set_target_to_stderr(*args):
        """
        set_target_to_stderr(self)

        set target to stderr 
        """
        return _Library.IO_set_target_to_stderr(*args)

    def set_target_to_stdout(*args):
        """
        set_target_to_stdout(self)

        set target to stdout 
        """
        return _Library.IO_set_target_to_stdout(*args)

    def enable_progress(*args):
        """
        enable_progress(self)

        enable progress bar 
        """
        return _Library.IO_enable_progress(*args)

    def disable_progress(*args):
        """
        disable_progress(self)

        disable progress bar 
        """
        return _Library.IO_disable_progress(*args)

    def enable_file_and_line(*args):
        """
        enable_file_and_line(self)

        enable displaying of file and line when printing messages 
        """
        return _Library.IO_enable_file_and_line(*args)

    def disable_file_and_line(*args):
        """
        disable_file_and_line(self)

        disable displaying of file and line when printing messages 
        """
        return _Library.IO_disable_file_and_line(*args)

    def set_dirname(*args):
        """set_dirname(dirname)"""
        return _Library.IO_set_dirname(*args)

    if _newclass:set_dirname = staticmethod(set_dirname)
    __swig_getmethods__["set_dirname"] = lambda x: set_dirname
    def concat_filename(*args):
        """concat_filename(filename) -> str"""
        return _Library.IO_concat_filename(*args)

    if _newclass:concat_filename = staticmethod(concat_filename)
    __swig_getmethods__["concat_filename"] = lambda x: concat_filename
    def filter(*args):
        """filter(d) -> int"""
        return _Library.IO_filter(*args)

    if _newclass:filter = staticmethod(filter)
    __swig_getmethods__["filter"] = lambda x: filter
    def ref(*args):
        """
        ref(self) ->  int

        increase reference counter

        reference count 
        """
        return _Library.IO_ref(*args)

    def ref_count(*args):
        """
        ref_count(self) ->  int

        display reference counter

        reference count 
        """
        return _Library.IO_ref_count(*args)

    def unref(*args):
        """
        unref(self) ->  int

        decrement reference counter and deallocate object if refcount is zero
        before or after decrementing it

        reference count 
        """
        return _Library.IO_unref(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.IO_get_name(*args)

    __swig_destroy__ = _Library.delete_IO
    __del__ = lambda self : None;
IO_swigregister = _Library.IO_swigregister
IO_swigregister(IO)
cvar = _Library.cvar

def IO_skip_spaces(*args):
  """IO_skip_spaces(str) -> str"""
  return _Library.IO_skip_spaces(*args)

def IO_skip_blanks(*args):
  """IO_skip_blanks(str) -> str"""
  return _Library.IO_skip_blanks(*args)

def IO_set_dirname(*args):
  """IO_set_dirname(dirname)"""
  return _Library.IO_set_dirname(*args)

def IO_concat_filename(*args):
  """IO_concat_filename(filename) -> str"""
  return _Library.IO_concat_filename(*args)

def IO_filter(*args):
  """IO_filter(d) -> int"""
  return _Library.IO_filter(*args)

class SGObject(_object):
    """Proxy of C++ SGObject class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SGObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SGObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Library.delete_SGObject
    __del__ = lambda self : None;
    def ref(*args):
        """ref(self) ->  int"""
        return _Library.SGObject_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Library.SGObject_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Library.SGObject_unref(*args)

    def get_name(*args):
        """get_name(self) -> str"""
        return _Library.SGObject_get_name(*args)

    __swig_setmethods__["io"] = _Library.SGObject_io_set
    __swig_getmethods__["io"] = _Library.SGObject_io_get
    if _newclass:io = _swig_property(_Library.SGObject_io_get, _Library.SGObject_io_set)
    __swig_setmethods__["parallel"] = _Library.SGObject_parallel_set
    __swig_getmethods__["parallel"] = _Library.SGObject_parallel_get
    if _newclass:parallel = _swig_property(_Library.SGObject_parallel_get, _Library.SGObject_parallel_set)
    __swig_setmethods__["version"] = _Library.SGObject_version_set
    __swig_getmethods__["version"] = _Library.SGObject_version_get
    if _newclass:version = _swig_property(_Library.SGObject_version_get, _Library.SGObject_version_set)
SGObject_swigregister = _Library.SGObject_swigregister
SGObject_swigregister(SGObject)

class Version(_object):
    """Proxy of C++ Version class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Version, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Version, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self) -> Version"""
        this = _Library.new_Version(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_Version
    __del__ = lambda self : None;
    def print_version(*args):
        """print_version()"""
        return _Library.Version_print_version(*args)

    if _newclass:print_version = staticmethod(print_version)
    __swig_getmethods__["print_version"] = lambda x: print_version
    def get_version_extra(*args):
        """get_version_extra() -> str"""
        return _Library.Version_get_version_extra(*args)

    if _newclass:get_version_extra = staticmethod(get_version_extra)
    __swig_getmethods__["get_version_extra"] = lambda x: get_version_extra
    def get_version_release(*args):
        """get_version_release() -> str"""
        return _Library.Version_get_version_release(*args)

    if _newclass:get_version_release = staticmethod(get_version_release)
    __swig_getmethods__["get_version_release"] = lambda x: get_version_release
    def get_version_revision(*args):
        """get_version_revision() ->  int"""
        return _Library.Version_get_version_revision(*args)

    if _newclass:get_version_revision = staticmethod(get_version_revision)
    __swig_getmethods__["get_version_revision"] = lambda x: get_version_revision
    def get_version_year(*args):
        """get_version_year() ->  int"""
        return _Library.Version_get_version_year(*args)

    if _newclass:get_version_year = staticmethod(get_version_year)
    __swig_getmethods__["get_version_year"] = lambda x: get_version_year
    def get_version_month(*args):
        """get_version_month() ->  int"""
        return _Library.Version_get_version_month(*args)

    if _newclass:get_version_month = staticmethod(get_version_month)
    __swig_getmethods__["get_version_month"] = lambda x: get_version_month
    def get_version_day(*args):
        """get_version_day() ->  int"""
        return _Library.Version_get_version_day(*args)

    if _newclass:get_version_day = staticmethod(get_version_day)
    __swig_getmethods__["get_version_day"] = lambda x: get_version_day
    def get_version_hour(*args):
        """get_version_hour() ->  int"""
        return _Library.Version_get_version_hour(*args)

    if _newclass:get_version_hour = staticmethod(get_version_hour)
    __swig_getmethods__["get_version_hour"] = lambda x: get_version_hour
    def get_version_minute(*args):
        """get_version_minute() ->  int"""
        return _Library.Version_get_version_minute(*args)

    if _newclass:get_version_minute = staticmethod(get_version_minute)
    __swig_getmethods__["get_version_minute"] = lambda x: get_version_minute
    def get_version_in_minutes(*args):
        """get_version_in_minutes() -> int"""
        return _Library.Version_get_version_in_minutes(*args)

    if _newclass:get_version_in_minutes = staticmethod(get_version_in_minutes)
    __swig_getmethods__["get_version_in_minutes"] = lambda x: get_version_in_minutes
    def ref(*args):
        """ref(self) ->  int"""
        return _Library.Version_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Library.Version_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Library.Version_unref(*args)

Version_swigregister = _Library.Version_swigregister
Version_swigregister(Version)

def Version_print_version(*args):
  """Version_print_version()"""
  return _Library.Version_print_version(*args)

def Version_get_version_extra(*args):
  """Version_get_version_extra() -> str"""
  return _Library.Version_get_version_extra(*args)

def Version_get_version_release(*args):
  """Version_get_version_release() -> str"""
  return _Library.Version_get_version_release(*args)

def Version_get_version_revision(*args):
  """Version_get_version_revision() ->  int"""
  return _Library.Version_get_version_revision(*args)

def Version_get_version_year(*args):
  """Version_get_version_year() ->  int"""
  return _Library.Version_get_version_year(*args)

def Version_get_version_month(*args):
  """Version_get_version_month() ->  int"""
  return _Library.Version_get_version_month(*args)

def Version_get_version_day(*args):
  """Version_get_version_day() ->  int"""
  return _Library.Version_get_version_day(*args)

def Version_get_version_hour(*args):
  """Version_get_version_hour() ->  int"""
  return _Library.Version_get_version_hour(*args)

def Version_get_version_minute(*args):
  """Version_get_version_minute() ->  int"""
  return _Library.Version_get_version_minute(*args)

def Version_get_version_in_minutes(*args):
  """Version_get_version_in_minutes() -> int"""
  return _Library.Version_get_version_in_minutes(*args)

class Parallel(_object):
    """Proxy of C++ Parallel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parallel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Parallel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Parallel
        __init__(self, orig) -> Parallel
        """
        this = _Library.new_Parallel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_Parallel
    __del__ = lambda self : None;
    def get_num_cpus(*args):
        """get_num_cpus(self) ->  int"""
        return _Library.Parallel_get_num_cpus(*args)

    def set_num_threads(*args):
        """set_num_threads(self, n)"""
        return _Library.Parallel_set_num_threads(*args)

    def get_num_threads(*args):
        """get_num_threads(self) ->  int"""
        return _Library.Parallel_get_num_threads(*args)

    def ref(*args):
        """ref(self) ->  int"""
        return _Library.Parallel_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Library.Parallel_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Library.Parallel_unref(*args)

Parallel_swigregister = _Library.Parallel_swigregister
Parallel_swigregister(Parallel)

class PySwigIterator(_object):
    """Proxy of C++ PySwigIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Library.delete_PySwigIterator
    __del__ = lambda self : None;
    def value(*args):
        """value(self) -> PyObject"""
        return _Library.PySwigIterator_value(*args)

    def incr(*args):
        """
        incr(self, n=1) -> PySwigIterator
        incr(self) -> PySwigIterator
        """
        return _Library.PySwigIterator_incr(*args)

    def decr(*args):
        """
        decr(self, n=1) -> PySwigIterator
        decr(self) -> PySwigIterator
        """
        return _Library.PySwigIterator_decr(*args)

    def distance(*args):
        """distance(self, x) -> ptrdiff_t"""
        return _Library.PySwigIterator_distance(*args)

    def equal(*args):
        """equal(self, x) -> bool"""
        return _Library.PySwigIterator_equal(*args)

    def copy(*args):
        """copy(self) -> PySwigIterator"""
        return _Library.PySwigIterator_copy(*args)

    def next(*args):
        """next(self) -> PyObject"""
        return _Library.PySwigIterator_next(*args)

    def previous(*args):
        """previous(self) -> PyObject"""
        return _Library.PySwigIterator_previous(*args)

    def advance(*args):
        """advance(self, n) -> PySwigIterator"""
        return _Library.PySwigIterator_advance(*args)

    def __eq__(*args):
        """__eq__(self, x) -> bool"""
        return _Library.PySwigIterator___eq__(*args)

    def __ne__(*args):
        """__ne__(self, x) -> bool"""
        return _Library.PySwigIterator___ne__(*args)

    def __iadd__(*args):
        """__iadd__(self, n) -> PySwigIterator"""
        return _Library.PySwigIterator___iadd__(*args)

    def __isub__(*args):
        """__isub__(self, n) -> PySwigIterator"""
        return _Library.PySwigIterator___isub__(*args)

    def __add__(*args):
        """__add__(self, n) -> PySwigIterator"""
        return _Library.PySwigIterator___add__(*args)

    def __sub__(*args):
        """
        __sub__(self, n) -> PySwigIterator
        __sub__(self, x) -> ptrdiff_t
        """
        return _Library.PySwigIterator___sub__(*args)

    def __iter__(self): return self
PySwigIterator_swigregister = _Library.PySwigIterator_swigregister
PySwigIterator_swigregister(PySwigIterator)

class IntVector(_object):
    """Proxy of C++ IntVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _Library.IntVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _Library.IntVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(int)>::size_type"""
        return _Library.IntVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(int)>::value_type"""
        return _Library.IntVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> IntVector"""
        return _Library.IntVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _Library.IntVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _Library.IntVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _Library.IntVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(int)>::value_type"""
        return _Library.IntVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _Library.IntVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _Library.IntVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _Library.IntVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(int)>::size_type"""
        return _Library.IntVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _Library.IntVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _Library.IntVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(int)>::allocator_type"""
        return _Library.IntVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(int)>::const_iterator"""
        return _Library.IntVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(int)>::const_iterator"""
        return _Library.IntVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _Library.IntVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _Library.IntVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _Library.IntVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(int)>::iterator
        erase(self, first, last) -> std::vector<(int)>::iterator
        """
        return _Library.IntVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> IntVector
        __init__(self, ?) -> IntVector
        __init__(self, size) -> IntVector
        __init__(self, size, value) -> IntVector
        """
        this = _Library.new_IntVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _Library.IntVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(int)>::value_type"""
        return _Library.IntVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(int)>::value_type"""
        return _Library.IntVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _Library.IntVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _Library.IntVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(int)>::iterator
        insert(self, pos, n, x)
        """
        return _Library.IntVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _Library.IntVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(int)>::size_type"""
        return _Library.IntVector_capacity(*args)

    __swig_destroy__ = _Library.delete_IntVector
    __del__ = lambda self : None;
IntVector_swigregister = _Library.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(_object):
    """Proxy of C++ DoubleVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _Library.DoubleVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _Library.DoubleVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(double)>::size_type"""
        return _Library.DoubleVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(double)>::value_type"""
        return _Library.DoubleVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> DoubleVector"""
        return _Library.DoubleVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _Library.DoubleVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _Library.DoubleVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _Library.DoubleVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(double)>::value_type"""
        return _Library.DoubleVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _Library.DoubleVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _Library.DoubleVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _Library.DoubleVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(double)>::size_type"""
        return _Library.DoubleVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _Library.DoubleVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _Library.DoubleVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(double)>::allocator_type"""
        return _Library.DoubleVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(double)>::const_iterator"""
        return _Library.DoubleVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(double)>::const_iterator"""
        return _Library.DoubleVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _Library.DoubleVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _Library.DoubleVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _Library.DoubleVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(double)>::iterator
        erase(self, first, last) -> std::vector<(double)>::iterator
        """
        return _Library.DoubleVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> DoubleVector
        __init__(self, ?) -> DoubleVector
        __init__(self, size) -> DoubleVector
        __init__(self, size, value) -> DoubleVector
        """
        this = _Library.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _Library.DoubleVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(double)>::value_type"""
        return _Library.DoubleVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(double)>::value_type"""
        return _Library.DoubleVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _Library.DoubleVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _Library.DoubleVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(double)>::iterator
        insert(self, pos, n, x)
        """
        return _Library.DoubleVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _Library.DoubleVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(double)>::size_type"""
        return _Library.DoubleVector_capacity(*args)

    __swig_destroy__ = _Library.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _Library.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class DynamicCharArray(SGObject):
    """
    Template Dynamic array class that creates an array that can be used
    like a list or an array.

    It grows and shrinks dynamically, while elements can be accessed via
    index. It is performance tuned for simple types like float etc. and
    for hi-level objects only stores pointers, which are not automagically
    SG_REF'd/deleted.

    C++ includes: DynamicArray.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicCharArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicCharArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, p_resize_granularity=128) -> DynamicCharArray
        __init__(self) -> DynamicCharArray

        constructor

        Parameters:
        -----------

        p_resize_granularity:  resize granularity 
        """
        this = _Library.new_DynamicCharArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_DynamicCharArray
    __del__ = lambda self : None;
    def set_granularity(*args):
        """
        set_granularity(self, g) ->  int

        set the resize granularity

        Parameters:
        -----------

        g:  new granularity

        what has been set (minimum is 128) 
        """
        return _Library.DynamicCharArray_set_granularity(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size (including granularity buffer) 
        """
        return _Library.DynamicCharArray_get_array_size(*args)

    def get_num_elements(*args):
        """
        get_num_elements(self) ->  int

        get number of elements

        number of elements 
        """
        return _Library.DynamicCharArray_get_num_elements(*args)

    def get_element(*args):
        """
        get_element(self, index) -> str

        get array element at index

        (does NOT do bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicCharArray_get_element(*args)

    def get_element_safe(*args):
        """
        get_element_safe(self, index) -> str

        get array element at index

        (does bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicCharArray_get_element_safe(*args)

    def set_element(*args):
        """
        set_element(self, element, index) -> bool

        set array element at index

        Parameters:
        -----------

        element:  element to set

        index:  index

        if setting was successful 
        """
        return _Library.DynamicCharArray_set_element(*args)

    def insert_element(*args):
        """
        insert_element(self, element, index) -> bool

        insert array element at index

        Parameters:
        -----------

        element:  element to insert

        index:  index

        if setting was successful 
        """
        return _Library.DynamicCharArray_insert_element(*args)

    def append_element(*args):
        """
        append_element(self, element) -> bool

        append array element to the end of array

        Parameters:
        -----------

        element:  element to append

        if setting was successful 
        """
        return _Library.DynamicCharArray_append_element(*args)

    def find_element(*args):
        """
        find_element(self, element) ->  int

        find first occurence of array element and return its index or -1 if
        not available

        Parameters:
        -----------

        element:  element to search for

        index of element or -1 
        """
        return _Library.DynamicCharArray_find_element(*args)

    def delete_element(*args):
        """
        delete_element(self, idx) -> bool

        delete array element at idx (does not call delete[] or the like)

        Parameters:
        -----------

        idx:  index

        if deleting was successful 
        """
        return _Library.DynamicCharArray_delete_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize the array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.DynamicCharArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> str

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.DynamicCharArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_num_elements, array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  new array

        p_num_elements:  last element index + 1

        array_size:  number of elements in array 
        """
        return _Library.DynamicCharArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.DynamicCharArray_clear_array(*args)

DynamicCharArray_swigregister = _Library.DynamicCharArray_swigregister
DynamicCharArray_swigregister(DynamicCharArray)

class DynamicByteArray(SGObject):
    """
    Template Dynamic array class that creates an array that can be used
    like a list or an array.

    It grows and shrinks dynamically, while elements can be accessed via
    index. It is performance tuned for simple types like float etc. and
    for hi-level objects only stores pointers, which are not automagically
    SG_REF'd/deleted.

    C++ includes: DynamicArray.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicByteArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicByteArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, p_resize_granularity=128) -> DynamicByteArray
        __init__(self) -> DynamicByteArray

        constructor

        Parameters:
        -----------

        p_resize_granularity:  resize granularity 
        """
        this = _Library.new_DynamicByteArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_DynamicByteArray
    __del__ = lambda self : None;
    def set_granularity(*args):
        """
        set_granularity(self, g) ->  int

        set the resize granularity

        Parameters:
        -----------

        g:  new granularity

        what has been set (minimum is 128) 
        """
        return _Library.DynamicByteArray_set_granularity(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size (including granularity buffer) 
        """
        return _Library.DynamicByteArray_get_array_size(*args)

    def get_num_elements(*args):
        """
        get_num_elements(self) ->  int

        get number of elements

        number of elements 
        """
        return _Library.DynamicByteArray_get_num_elements(*args)

    def get_element(*args):
        """
        get_element(self, index) -> unsigned str

        get array element at index

        (does NOT do bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicByteArray_get_element(*args)

    def get_element_safe(*args):
        """
        get_element_safe(self, index) -> unsigned str

        get array element at index

        (does bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicByteArray_get_element_safe(*args)

    def set_element(*args):
        """
        set_element(self, element, index) -> bool

        set array element at index

        Parameters:
        -----------

        element:  element to set

        index:  index

        if setting was successful 
        """
        return _Library.DynamicByteArray_set_element(*args)

    def insert_element(*args):
        """
        insert_element(self, element, index) -> bool

        insert array element at index

        Parameters:
        -----------

        element:  element to insert

        index:  index

        if setting was successful 
        """
        return _Library.DynamicByteArray_insert_element(*args)

    def append_element(*args):
        """
        append_element(self, element) -> bool

        append array element to the end of array

        Parameters:
        -----------

        element:  element to append

        if setting was successful 
        """
        return _Library.DynamicByteArray_append_element(*args)

    def find_element(*args):
        """
        find_element(self, element) ->  int

        find first occurence of array element and return its index or -1 if
        not available

        Parameters:
        -----------

        element:  element to search for

        index of element or -1 
        """
        return _Library.DynamicByteArray_find_element(*args)

    def delete_element(*args):
        """
        delete_element(self, idx) -> bool

        delete array element at idx (does not call delete[] or the like)

        Parameters:
        -----------

        idx:  index

        if deleting was successful 
        """
        return _Library.DynamicByteArray_delete_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize the array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.DynamicByteArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned str

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.DynamicByteArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_num_elements, array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  new array

        p_num_elements:  last element index + 1

        array_size:  number of elements in array 
        """
        return _Library.DynamicByteArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.DynamicByteArray_clear_array(*args)

DynamicByteArray_swigregister = _Library.DynamicByteArray_swigregister
DynamicByteArray_swigregister(DynamicByteArray)

class DynamicShortArray(SGObject):
    """
    Template Dynamic array class that creates an array that can be used
    like a list or an array.

    It grows and shrinks dynamically, while elements can be accessed via
    index. It is performance tuned for simple types like float etc. and
    for hi-level objects only stores pointers, which are not automagically
    SG_REF'd/deleted.

    C++ includes: DynamicArray.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicShortArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicShortArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, p_resize_granularity=128) -> DynamicShortArray
        __init__(self) -> DynamicShortArray

        constructor

        Parameters:
        -----------

        p_resize_granularity:  resize granularity 
        """
        this = _Library.new_DynamicShortArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_DynamicShortArray
    __del__ = lambda self : None;
    def set_granularity(*args):
        """
        set_granularity(self, g) ->  int

        set the resize granularity

        Parameters:
        -----------

        g:  new granularity

        what has been set (minimum is 128) 
        """
        return _Library.DynamicShortArray_set_granularity(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size (including granularity buffer) 
        """
        return _Library.DynamicShortArray_get_array_size(*args)

    def get_num_elements(*args):
        """
        get_num_elements(self) ->  int

        get number of elements

        number of elements 
        """
        return _Library.DynamicShortArray_get_num_elements(*args)

    def get_element(*args):
        """
        get_element(self, index) -> short

        get array element at index

        (does NOT do bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicShortArray_get_element(*args)

    def get_element_safe(*args):
        """
        get_element_safe(self, index) -> short

        get array element at index

        (does bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicShortArray_get_element_safe(*args)

    def set_element(*args):
        """
        set_element(self, element, index) -> bool

        set array element at index

        Parameters:
        -----------

        element:  element to set

        index:  index

        if setting was successful 
        """
        return _Library.DynamicShortArray_set_element(*args)

    def insert_element(*args):
        """
        insert_element(self, element, index) -> bool

        insert array element at index

        Parameters:
        -----------

        element:  element to insert

        index:  index

        if setting was successful 
        """
        return _Library.DynamicShortArray_insert_element(*args)

    def append_element(*args):
        """
        append_element(self, element) -> bool

        append array element to the end of array

        Parameters:
        -----------

        element:  element to append

        if setting was successful 
        """
        return _Library.DynamicShortArray_append_element(*args)

    def find_element(*args):
        """
        find_element(self, element) ->  int

        find first occurence of array element and return its index or -1 if
        not available

        Parameters:
        -----------

        element:  element to search for

        index of element or -1 
        """
        return _Library.DynamicShortArray_find_element(*args)

    def delete_element(*args):
        """
        delete_element(self, idx) -> bool

        delete array element at idx (does not call delete[] or the like)

        Parameters:
        -----------

        idx:  index

        if deleting was successful 
        """
        return _Library.DynamicShortArray_delete_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize the array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.DynamicShortArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> short

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.DynamicShortArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_num_elements, array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  new array

        p_num_elements:  last element index + 1

        array_size:  number of elements in array 
        """
        return _Library.DynamicShortArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.DynamicShortArray_clear_array(*args)

DynamicShortArray_swigregister = _Library.DynamicShortArray_swigregister
DynamicShortArray_swigregister(DynamicShortArray)

class DynamicWordArray(SGObject):
    """
    Template Dynamic array class that creates an array that can be used
    like a list or an array.

    It grows and shrinks dynamically, while elements can be accessed via
    index. It is performance tuned for simple types like float etc. and
    for hi-level objects only stores pointers, which are not automagically
    SG_REF'd/deleted.

    C++ includes: DynamicArray.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicWordArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicWordArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, p_resize_granularity=128) -> DynamicWordArray
        __init__(self) -> DynamicWordArray

        constructor

        Parameters:
        -----------

        p_resize_granularity:  resize granularity 
        """
        this = _Library.new_DynamicWordArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_DynamicWordArray
    __del__ = lambda self : None;
    def set_granularity(*args):
        """
        set_granularity(self, g) ->  int

        set the resize granularity

        Parameters:
        -----------

        g:  new granularity

        what has been set (minimum is 128) 
        """
        return _Library.DynamicWordArray_set_granularity(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size (including granularity buffer) 
        """
        return _Library.DynamicWordArray_get_array_size(*args)

    def get_num_elements(*args):
        """
        get_num_elements(self) ->  int

        get number of elements

        number of elements 
        """
        return _Library.DynamicWordArray_get_num_elements(*args)

    def get_element(*args):
        """
        get_element(self, index) -> unsigned short

        get array element at index

        (does NOT do bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicWordArray_get_element(*args)

    def get_element_safe(*args):
        """
        get_element_safe(self, index) -> unsigned short

        get array element at index

        (does bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicWordArray_get_element_safe(*args)

    def set_element(*args):
        """
        set_element(self, element, index) -> bool

        set array element at index

        Parameters:
        -----------

        element:  element to set

        index:  index

        if setting was successful 
        """
        return _Library.DynamicWordArray_set_element(*args)

    def insert_element(*args):
        """
        insert_element(self, element, index) -> bool

        insert array element at index

        Parameters:
        -----------

        element:  element to insert

        index:  index

        if setting was successful 
        """
        return _Library.DynamicWordArray_insert_element(*args)

    def append_element(*args):
        """
        append_element(self, element) -> bool

        append array element to the end of array

        Parameters:
        -----------

        element:  element to append

        if setting was successful 
        """
        return _Library.DynamicWordArray_append_element(*args)

    def find_element(*args):
        """
        find_element(self, element) ->  int

        find first occurence of array element and return its index or -1 if
        not available

        Parameters:
        -----------

        element:  element to search for

        index of element or -1 
        """
        return _Library.DynamicWordArray_find_element(*args)

    def delete_element(*args):
        """
        delete_element(self, idx) -> bool

        delete array element at idx (does not call delete[] or the like)

        Parameters:
        -----------

        idx:  index

        if deleting was successful 
        """
        return _Library.DynamicWordArray_delete_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize the array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.DynamicWordArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned short

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.DynamicWordArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_num_elements, array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  new array

        p_num_elements:  last element index + 1

        array_size:  number of elements in array 
        """
        return _Library.DynamicWordArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.DynamicWordArray_clear_array(*args)

DynamicWordArray_swigregister = _Library.DynamicWordArray_swigregister
DynamicWordArray_swigregister(DynamicWordArray)

class DynamicIntArray(SGObject):
    """
    Template Dynamic array class that creates an array that can be used
    like a list or an array.

    It grows and shrinks dynamically, while elements can be accessed via
    index. It is performance tuned for simple types like float etc. and
    for hi-level objects only stores pointers, which are not automagically
    SG_REF'd/deleted.

    C++ includes: DynamicArray.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicIntArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicIntArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, p_resize_granularity=128) -> DynamicIntArray
        __init__(self) -> DynamicIntArray

        constructor

        Parameters:
        -----------

        p_resize_granularity:  resize granularity 
        """
        this = _Library.new_DynamicIntArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_DynamicIntArray
    __del__ = lambda self : None;
    def set_granularity(*args):
        """
        set_granularity(self, g) ->  int

        set the resize granularity

        Parameters:
        -----------

        g:  new granularity

        what has been set (minimum is 128) 
        """
        return _Library.DynamicIntArray_set_granularity(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size (including granularity buffer) 
        """
        return _Library.DynamicIntArray_get_array_size(*args)

    def get_num_elements(*args):
        """
        get_num_elements(self) ->  int

        get number of elements

        number of elements 
        """
        return _Library.DynamicIntArray_get_num_elements(*args)

    def get_element(*args):
        """
        get_element(self, index) -> int

        get array element at index

        (does NOT do bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicIntArray_get_element(*args)

    def get_element_safe(*args):
        """
        get_element_safe(self, index) -> int

        get array element at index

        (does bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicIntArray_get_element_safe(*args)

    def set_element(*args):
        """
        set_element(self, element, index) -> bool

        set array element at index

        Parameters:
        -----------

        element:  element to set

        index:  index

        if setting was successful 
        """
        return _Library.DynamicIntArray_set_element(*args)

    def insert_element(*args):
        """
        insert_element(self, element, index) -> bool

        insert array element at index

        Parameters:
        -----------

        element:  element to insert

        index:  index

        if setting was successful 
        """
        return _Library.DynamicIntArray_insert_element(*args)

    def append_element(*args):
        """
        append_element(self, element) -> bool

        append array element to the end of array

        Parameters:
        -----------

        element:  element to append

        if setting was successful 
        """
        return _Library.DynamicIntArray_append_element(*args)

    def find_element(*args):
        """
        find_element(self, element) ->  int

        find first occurence of array element and return its index or -1 if
        not available

        Parameters:
        -----------

        element:  element to search for

        index of element or -1 
        """
        return _Library.DynamicIntArray_find_element(*args)

    def delete_element(*args):
        """
        delete_element(self, idx) -> bool

        delete array element at idx (does not call delete[] or the like)

        Parameters:
        -----------

        idx:  index

        if deleting was successful 
        """
        return _Library.DynamicIntArray_delete_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize the array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.DynamicIntArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> int

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.DynamicIntArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_num_elements, array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  new array

        p_num_elements:  last element index + 1

        array_size:  number of elements in array 
        """
        return _Library.DynamicIntArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.DynamicIntArray_clear_array(*args)

DynamicIntArray_swigregister = _Library.DynamicIntArray_swigregister
DynamicIntArray_swigregister(DynamicIntArray)

class DynamicUIntArray(SGObject):
    """
    Template Dynamic array class that creates an array that can be used
    like a list or an array.

    It grows and shrinks dynamically, while elements can be accessed via
    index. It is performance tuned for simple types like float etc. and
    for hi-level objects only stores pointers, which are not automagically
    SG_REF'd/deleted.

    C++ includes: DynamicArray.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicUIntArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicUIntArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, p_resize_granularity=128) -> DynamicUIntArray
        __init__(self) -> DynamicUIntArray

        constructor

        Parameters:
        -----------

        p_resize_granularity:  resize granularity 
        """
        this = _Library.new_DynamicUIntArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_DynamicUIntArray
    __del__ = lambda self : None;
    def set_granularity(*args):
        """
        set_granularity(self, g) ->  int

        set the resize granularity

        Parameters:
        -----------

        g:  new granularity

        what has been set (minimum is 128) 
        """
        return _Library.DynamicUIntArray_set_granularity(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size (including granularity buffer) 
        """
        return _Library.DynamicUIntArray_get_array_size(*args)

    def get_num_elements(*args):
        """
        get_num_elements(self) ->  int

        get number of elements

        number of elements 
        """
        return _Library.DynamicUIntArray_get_num_elements(*args)

    def get_element(*args):
        """
        get_element(self, index) -> unsigned int

        get array element at index

        (does NOT do bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicUIntArray_get_element(*args)

    def get_element_safe(*args):
        """
        get_element_safe(self, index) -> unsigned int

        get array element at index

        (does bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicUIntArray_get_element_safe(*args)

    def set_element(*args):
        """
        set_element(self, element, index) -> bool

        set array element at index

        Parameters:
        -----------

        element:  element to set

        index:  index

        if setting was successful 
        """
        return _Library.DynamicUIntArray_set_element(*args)

    def insert_element(*args):
        """
        insert_element(self, element, index) -> bool

        insert array element at index

        Parameters:
        -----------

        element:  element to insert

        index:  index

        if setting was successful 
        """
        return _Library.DynamicUIntArray_insert_element(*args)

    def append_element(*args):
        """
        append_element(self, element) -> bool

        append array element to the end of array

        Parameters:
        -----------

        element:  element to append

        if setting was successful 
        """
        return _Library.DynamicUIntArray_append_element(*args)

    def find_element(*args):
        """
        find_element(self, element) ->  int

        find first occurence of array element and return its index or -1 if
        not available

        Parameters:
        -----------

        element:  element to search for

        index of element or -1 
        """
        return _Library.DynamicUIntArray_find_element(*args)

    def delete_element(*args):
        """
        delete_element(self, idx) -> bool

        delete array element at idx (does not call delete[] or the like)

        Parameters:
        -----------

        idx:  index

        if deleting was successful 
        """
        return _Library.DynamicUIntArray_delete_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize the array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.DynamicUIntArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned int

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.DynamicUIntArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_num_elements, array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  new array

        p_num_elements:  last element index + 1

        array_size:  number of elements in array 
        """
        return _Library.DynamicUIntArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.DynamicUIntArray_clear_array(*args)

DynamicUIntArray_swigregister = _Library.DynamicUIntArray_swigregister
DynamicUIntArray_swigregister(DynamicUIntArray)

class DynamicLongArray(SGObject):
    """
    Template Dynamic array class that creates an array that can be used
    like a list or an array.

    It grows and shrinks dynamically, while elements can be accessed via
    index. It is performance tuned for simple types like float etc. and
    for hi-level objects only stores pointers, which are not automagically
    SG_REF'd/deleted.

    C++ includes: DynamicArray.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicLongArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicLongArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, p_resize_granularity=128) -> DynamicLongArray
        __init__(self) -> DynamicLongArray

        constructor

        Parameters:
        -----------

        p_resize_granularity:  resize granularity 
        """
        this = _Library.new_DynamicLongArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_DynamicLongArray
    __del__ = lambda self : None;
    def set_granularity(*args):
        """
        set_granularity(self, g) ->  int

        set the resize granularity

        Parameters:
        -----------

        g:  new granularity

        what has been set (minimum is 128) 
        """
        return _Library.DynamicLongArray_set_granularity(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size (including granularity buffer) 
        """
        return _Library.DynamicLongArray_get_array_size(*args)

    def get_num_elements(*args):
        """
        get_num_elements(self) ->  int

        get number of elements

        number of elements 
        """
        return _Library.DynamicLongArray_get_num_elements(*args)

    def get_element(*args):
        """
        get_element(self, index) -> long long

        get array element at index

        (does NOT do bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicLongArray_get_element(*args)

    def get_element_safe(*args):
        """
        get_element_safe(self, index) -> long long

        get array element at index

        (does bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicLongArray_get_element_safe(*args)

    def set_element(*args):
        """
        set_element(self, element, index) -> bool

        set array element at index

        Parameters:
        -----------

        element:  element to set

        index:  index

        if setting was successful 
        """
        return _Library.DynamicLongArray_set_element(*args)

    def insert_element(*args):
        """
        insert_element(self, element, index) -> bool

        insert array element at index

        Parameters:
        -----------

        element:  element to insert

        index:  index

        if setting was successful 
        """
        return _Library.DynamicLongArray_insert_element(*args)

    def append_element(*args):
        """
        append_element(self, element) -> bool

        append array element to the end of array

        Parameters:
        -----------

        element:  element to append

        if setting was successful 
        """
        return _Library.DynamicLongArray_append_element(*args)

    def find_element(*args):
        """
        find_element(self, element) ->  int

        find first occurence of array element and return its index or -1 if
        not available

        Parameters:
        -----------

        element:  element to search for

        index of element or -1 
        """
        return _Library.DynamicLongArray_find_element(*args)

    def delete_element(*args):
        """
        delete_element(self, idx) -> bool

        delete array element at idx (does not call delete[] or the like)

        Parameters:
        -----------

        idx:  index

        if deleting was successful 
        """
        return _Library.DynamicLongArray_delete_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize the array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.DynamicLongArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> long long

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.DynamicLongArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_num_elements, array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  new array

        p_num_elements:  last element index + 1

        array_size:  number of elements in array 
        """
        return _Library.DynamicLongArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.DynamicLongArray_clear_array(*args)

DynamicLongArray_swigregister = _Library.DynamicLongArray_swigregister
DynamicLongArray_swigregister(DynamicLongArray)

class DynamicULongArray(SGObject):
    """
    Template Dynamic array class that creates an array that can be used
    like a list or an array.

    It grows and shrinks dynamically, while elements can be accessed via
    index. It is performance tuned for simple types like float etc. and
    for hi-level objects only stores pointers, which are not automagically
    SG_REF'd/deleted.

    C++ includes: DynamicArray.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicULongArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicULongArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, p_resize_granularity=128) -> DynamicULongArray
        __init__(self) -> DynamicULongArray

        constructor

        Parameters:
        -----------

        p_resize_granularity:  resize granularity 
        """
        this = _Library.new_DynamicULongArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_DynamicULongArray
    __del__ = lambda self : None;
    def set_granularity(*args):
        """
        set_granularity(self, g) ->  int

        set the resize granularity

        Parameters:
        -----------

        g:  new granularity

        what has been set (minimum is 128) 
        """
        return _Library.DynamicULongArray_set_granularity(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size (including granularity buffer) 
        """
        return _Library.DynamicULongArray_get_array_size(*args)

    def get_num_elements(*args):
        """
        get_num_elements(self) ->  int

        get number of elements

        number of elements 
        """
        return _Library.DynamicULongArray_get_num_elements(*args)

    def get_element(*args):
        """
        get_element(self, index) -> unsigned long long

        get array element at index

        (does NOT do bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicULongArray_get_element(*args)

    def get_element_safe(*args):
        """
        get_element_safe(self, index) -> unsigned long long

        get array element at index

        (does bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicULongArray_get_element_safe(*args)

    def set_element(*args):
        """
        set_element(self, element, index) -> bool

        set array element at index

        Parameters:
        -----------

        element:  element to set

        index:  index

        if setting was successful 
        """
        return _Library.DynamicULongArray_set_element(*args)

    def insert_element(*args):
        """
        insert_element(self, element, index) -> bool

        insert array element at index

        Parameters:
        -----------

        element:  element to insert

        index:  index

        if setting was successful 
        """
        return _Library.DynamicULongArray_insert_element(*args)

    def append_element(*args):
        """
        append_element(self, element) -> bool

        append array element to the end of array

        Parameters:
        -----------

        element:  element to append

        if setting was successful 
        """
        return _Library.DynamicULongArray_append_element(*args)

    def find_element(*args):
        """
        find_element(self, element) ->  int

        find first occurence of array element and return its index or -1 if
        not available

        Parameters:
        -----------

        element:  element to search for

        index of element or -1 
        """
        return _Library.DynamicULongArray_find_element(*args)

    def delete_element(*args):
        """
        delete_element(self, idx) -> bool

        delete array element at idx (does not call delete[] or the like)

        Parameters:
        -----------

        idx:  index

        if deleting was successful 
        """
        return _Library.DynamicULongArray_delete_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize the array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.DynamicULongArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned long long

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.DynamicULongArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_num_elements, array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  new array

        p_num_elements:  last element index + 1

        array_size:  number of elements in array 
        """
        return _Library.DynamicULongArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.DynamicULongArray_clear_array(*args)

DynamicULongArray_swigregister = _Library.DynamicULongArray_swigregister
DynamicULongArray_swigregister(DynamicULongArray)

class DynamicShortRealArray(SGObject):
    """
    Template Dynamic array class that creates an array that can be used
    like a list or an array.

    It grows and shrinks dynamically, while elements can be accessed via
    index. It is performance tuned for simple types like float etc. and
    for hi-level objects only stores pointers, which are not automagically
    SG_REF'd/deleted.

    C++ includes: DynamicArray.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicShortRealArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicShortRealArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, p_resize_granularity=128) -> DynamicShortRealArray
        __init__(self) -> DynamicShortRealArray

        constructor

        Parameters:
        -----------

        p_resize_granularity:  resize granularity 
        """
        this = _Library.new_DynamicShortRealArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_DynamicShortRealArray
    __del__ = lambda self : None;
    def set_granularity(*args):
        """
        set_granularity(self, g) ->  int

        set the resize granularity

        Parameters:
        -----------

        g:  new granularity

        what has been set (minimum is 128) 
        """
        return _Library.DynamicShortRealArray_set_granularity(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size (including granularity buffer) 
        """
        return _Library.DynamicShortRealArray_get_array_size(*args)

    def get_num_elements(*args):
        """
        get_num_elements(self) ->  int

        get number of elements

        number of elements 
        """
        return _Library.DynamicShortRealArray_get_num_elements(*args)

    def get_element(*args):
        """
        get_element(self, index) -> float

        get array element at index

        (does NOT do bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicShortRealArray_get_element(*args)

    def get_element_safe(*args):
        """
        get_element_safe(self, index) -> float

        get array element at index

        (does bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicShortRealArray_get_element_safe(*args)

    def set_element(*args):
        """
        set_element(self, element, index) -> bool

        set array element at index

        Parameters:
        -----------

        element:  element to set

        index:  index

        if setting was successful 
        """
        return _Library.DynamicShortRealArray_set_element(*args)

    def insert_element(*args):
        """
        insert_element(self, element, index) -> bool

        insert array element at index

        Parameters:
        -----------

        element:  element to insert

        index:  index

        if setting was successful 
        """
        return _Library.DynamicShortRealArray_insert_element(*args)

    def append_element(*args):
        """
        append_element(self, element) -> bool

        append array element to the end of array

        Parameters:
        -----------

        element:  element to append

        if setting was successful 
        """
        return _Library.DynamicShortRealArray_append_element(*args)

    def find_element(*args):
        """
        find_element(self, element) ->  int

        find first occurence of array element and return its index or -1 if
        not available

        Parameters:
        -----------

        element:  element to search for

        index of element or -1 
        """
        return _Library.DynamicShortRealArray_find_element(*args)

    def delete_element(*args):
        """
        delete_element(self, idx) -> bool

        delete array element at idx (does not call delete[] or the like)

        Parameters:
        -----------

        idx:  index

        if deleting was successful 
        """
        return _Library.DynamicShortRealArray_delete_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize the array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.DynamicShortRealArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> float

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.DynamicShortRealArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_num_elements, array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  new array

        p_num_elements:  last element index + 1

        array_size:  number of elements in array 
        """
        return _Library.DynamicShortRealArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.DynamicShortRealArray_clear_array(*args)

DynamicShortRealArray_swigregister = _Library.DynamicShortRealArray_swigregister
DynamicShortRealArray_swigregister(DynamicShortRealArray)

class DynamicRealArray(SGObject):
    """
    Template Dynamic array class that creates an array that can be used
    like a list or an array.

    It grows and shrinks dynamically, while elements can be accessed via
    index. It is performance tuned for simple types like float etc. and
    for hi-level objects only stores pointers, which are not automagically
    SG_REF'd/deleted.

    C++ includes: DynamicArray.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicRealArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicRealArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, p_resize_granularity=128) -> DynamicRealArray
        __init__(self) -> DynamicRealArray

        constructor

        Parameters:
        -----------

        p_resize_granularity:  resize granularity 
        """
        this = _Library.new_DynamicRealArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_DynamicRealArray
    __del__ = lambda self : None;
    def set_granularity(*args):
        """
        set_granularity(self, g) ->  int

        set the resize granularity

        Parameters:
        -----------

        g:  new granularity

        what has been set (minimum is 128) 
        """
        return _Library.DynamicRealArray_set_granularity(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size (including granularity buffer) 
        """
        return _Library.DynamicRealArray_get_array_size(*args)

    def get_num_elements(*args):
        """
        get_num_elements(self) ->  int

        get number of elements

        number of elements 
        """
        return _Library.DynamicRealArray_get_num_elements(*args)

    def get_element(*args):
        """
        get_element(self, index) -> float

        get array element at index

        (does NOT do bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicRealArray_get_element(*args)

    def get_element_safe(*args):
        """
        get_element_safe(self, index) -> float

        get array element at index

        (does bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicRealArray_get_element_safe(*args)

    def set_element(*args):
        """
        set_element(self, element, index) -> bool

        set array element at index

        Parameters:
        -----------

        element:  element to set

        index:  index

        if setting was successful 
        """
        return _Library.DynamicRealArray_set_element(*args)

    def insert_element(*args):
        """
        insert_element(self, element, index) -> bool

        insert array element at index

        Parameters:
        -----------

        element:  element to insert

        index:  index

        if setting was successful 
        """
        return _Library.DynamicRealArray_insert_element(*args)

    def append_element(*args):
        """
        append_element(self, element) -> bool

        append array element to the end of array

        Parameters:
        -----------

        element:  element to append

        if setting was successful 
        """
        return _Library.DynamicRealArray_append_element(*args)

    def find_element(*args):
        """
        find_element(self, element) ->  int

        find first occurence of array element and return its index or -1 if
        not available

        Parameters:
        -----------

        element:  element to search for

        index of element or -1 
        """
        return _Library.DynamicRealArray_find_element(*args)

    def delete_element(*args):
        """
        delete_element(self, idx) -> bool

        delete array element at idx (does not call delete[] or the like)

        Parameters:
        -----------

        idx:  index

        if deleting was successful 
        """
        return _Library.DynamicRealArray_delete_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize the array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.DynamicRealArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> float

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.DynamicRealArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_num_elements, array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  new array

        p_num_elements:  last element index + 1

        array_size:  number of elements in array 
        """
        return _Library.DynamicRealArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.DynamicRealArray_clear_array(*args)

DynamicRealArray_swigregister = _Library.DynamicRealArray_swigregister
DynamicRealArray_swigregister(DynamicRealArray)

class DynamicPlifArray(SGObject):
    """
    Template Dynamic array class that creates an array that can be used
    like a list or an array.

    It grows and shrinks dynamically, while elements can be accessed via
    index. It is performance tuned for simple types like float etc. and
    for hi-level objects only stores pointers, which are not automagically
    SG_REF'd/deleted.

    C++ includes: DynamicArray.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicPlifArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicPlifArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, p_resize_granularity=128) -> DynamicPlifArray
        __init__(self) -> DynamicPlifArray

        constructor

        Parameters:
        -----------

        p_resize_granularity:  resize granularity 
        """
        this = _Library.new_DynamicPlifArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_DynamicPlifArray
    __del__ = lambda self : None;
    def set_granularity(*args):
        """
        set_granularity(self, g) ->  int

        set the resize granularity

        Parameters:
        -----------

        g:  new granularity

        what has been set (minimum is 128) 
        """
        return _Library.DynamicPlifArray_set_granularity(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size (including granularity buffer) 
        """
        return _Library.DynamicPlifArray_get_array_size(*args)

    def get_num_elements(*args):
        """
        get_num_elements(self) ->  int

        get number of elements

        number of elements 
        """
        return _Library.DynamicPlifArray_get_num_elements(*args)

    def get_element(*args):
        """
        get_element(self, index) -> shogun::CPlifBase

        get array element at index

        (does NOT do bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicPlifArray_get_element(*args)

    def get_element_safe(*args):
        """
        get_element_safe(self, index) -> shogun::CPlifBase

        get array element at index

        (does bounds checking)

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.DynamicPlifArray_get_element_safe(*args)

    def set_element(*args):
        """
        set_element(self, element, index) -> bool

        set array element at index

        Parameters:
        -----------

        element:  element to set

        index:  index

        if setting was successful 
        """
        return _Library.DynamicPlifArray_set_element(*args)

    def insert_element(*args):
        """
        insert_element(self, element, index) -> bool

        insert array element at index

        Parameters:
        -----------

        element:  element to insert

        index:  index

        if setting was successful 
        """
        return _Library.DynamicPlifArray_insert_element(*args)

    def append_element(*args):
        """
        append_element(self, element) -> bool

        append array element to the end of array

        Parameters:
        -----------

        element:  element to append

        if setting was successful 
        """
        return _Library.DynamicPlifArray_append_element(*args)

    def find_element(*args):
        """
        find_element(self, element) ->  int

        find first occurence of array element and return its index or -1 if
        not available

        Parameters:
        -----------

        element:  element to search for

        index of element or -1 
        """
        return _Library.DynamicPlifArray_find_element(*args)

    def delete_element(*args):
        """
        delete_element(self, idx) -> bool

        delete array element at idx (does not call delete[] or the like)

        Parameters:
        -----------

        idx:  index

        if deleting was successful 
        """
        return _Library.DynamicPlifArray_delete_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize the array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.DynamicPlifArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> shogun::CPlifBase

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.DynamicPlifArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_num_elements, array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  new array

        p_num_elements:  last element index + 1

        array_size:  number of elements in array 
        """
        return _Library.DynamicPlifArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.DynamicPlifArray_clear_array(*args)

DynamicPlifArray_swigregister = _Library.DynamicPlifArray_swigregister
DynamicPlifArray_swigregister(DynamicPlifArray)

class PlifGCArray(SGObject):
    """
    Template class GCArray implements a garbage collecting static array.

    This array is meant to be used for Shogun Objects (CSGObject) only, as
    it deals with garbage collection, i.e. on read and array assignment
    the reference count is increased (and decreased on delete and
    overwriting elements).

    C++ includes: GCArray.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PlifGCArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PlifGCArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, sz) -> PlifGCArray

        Constructor

        Parameters:
        -----------

        sz:  length of array 
        """
        this = _Library.new_PlifGCArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_PlifGCArray
    __del__ = lambda self : None;
    def set(*args):
        """
        set(self, element, index)

        write access operator

        Parameters:
        -----------

        element:  - element to write

        index:  - index to write to 
        """
        return _Library.PlifGCArray_set(*args)

    def get(*args):
        """
        get(self, index) -> shogun::CPlifBase

        read only access operator

        Parameters:
        -----------

        index:  index to write to

        element element 
        """
        return _Library.PlifGCArray_get(*args)

PlifGCArray_swigregister = _Library.PlifGCArray_swigregister
PlifGCArray_swigregister(PlifGCArray)

class Hash(SGObject):
    """
    Collection of Hashing Functions.

    This class implements a number of hashing functions like crc32, md5
    and murmur.

    C++ includes: Hash.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hash, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Hash, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Hash

        default constructor 
        """
        this = _Library.new_Hash(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_Hash
    __del__ = lambda self : None;
    def crc32(*args):
        """crc32(data) -> int"""
        return _Library.Hash_crc32(*args)

    if _newclass:crc32 = staticmethod(crc32)
    __swig_getmethods__["crc32"] = lambda x: crc32
    def MD5(*args):
        """MD5(x, l, buf)"""
        return _Library.Hash_MD5(*args)

    if _newclass:MD5 = staticmethod(MD5)
    __swig_getmethods__["MD5"] = lambda x: MD5
    def MurmurHash2(*args):
        """
        MurmurHash2(self, data, seed) -> int

        Murmur Hash2

        Parameters:
        -----------

        data:  data to checksum (needs to be 32bit aligned on some archs)

        len:  length in number of bytes

        seed:  initial seed

        hash 
        """
        return _Library.Hash_MurmurHash2(*args)

Hash_swigregister = _Library.Hash_swigregister
Hash_swigregister(Hash)

def Hash_crc32(*args):
  """Hash_crc32(data) -> int"""
  return _Library.Hash_crc32(*args)

def Hash_MD5(*args):
  """Hash_MD5(x, l, buf)"""
  return _Library.Hash_MD5(*args)

class CharArray(SGObject):
    """
    Template class Array implements a dense one dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance array implementation without
    error checking.

    C++ includes: Array.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CharArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CharArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, initial_size=1) -> CharArray
        __init__(self) -> CharArray
        __init__(self, p_array, p_array_size, p_free_array=True, p_copy_array=False) -> CharArray
        __init__(self, p_array, p_array_size, p_free_array=True) -> CharArray
        __init__(self, p_array, p_array_size) -> CharArray
        __init__(self, p_array, p_array_size) -> CharArray

        constructor

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        this = _Library.new_CharArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_CharArray
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.CharArray_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.CharArray_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.CharArray_get_dim1(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.CharArray_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.CharArray_set_const(*args)

    def get_element(*args):
        """
        get_element(self, index) -> str

        get array element at index

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.CharArray_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, index) -> bool

        set array element at index 'index' return false in case of trouble

        Parameters:
        -----------

        p_element:  array element to set

        index:  index

        if setting was successful 
        """
        return _Library.CharArray_set_element(*args)

    def element(*args):
        """
        element(self, idx1) -> str
        element(self, index) -> str
        element(self, p_array, index) -> str

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        index:  index

        element of given array at given index 
        """
        return _Library.CharArray_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.CharArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> str

        call get_array just before messing with it DO NOT call any
        [],resize/delete functions after get_array(), the pointer may become
        invalid!

        the array 
        """
        return _Library.CharArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_array_size, p_free_array=True, copy_array=False)
        set_array(self, p_array, p_array_size, p_free_array=True)
        set_array(self, p_array, p_array_size)
        set_array(self, p_array, p_array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        return _Library.CharArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.CharArray_clear_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.CharArray_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.CharArray_display_array(*args)

CharArray_swigregister = _Library.CharArray_swigregister
CharArray_swigregister(CharArray)

class ByteArray(SGObject):
    """
    Template class Array implements a dense one dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance array implementation without
    error checking.

    C++ includes: Array.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, initial_size=1) -> ByteArray
        __init__(self) -> ByteArray
        __init__(self, p_array, p_array_size, p_free_array=True, p_copy_array=False) -> ByteArray
        __init__(self, p_array, p_array_size, p_free_array=True) -> ByteArray
        __init__(self, p_array, p_array_size) -> ByteArray
        __init__(self, p_array, p_array_size) -> ByteArray

        constructor

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        this = _Library.new_ByteArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_ByteArray
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.ByteArray_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.ByteArray_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.ByteArray_get_dim1(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.ByteArray_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.ByteArray_set_const(*args)

    def get_element(*args):
        """
        get_element(self, index) -> unsigned str

        get array element at index

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.ByteArray_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, index) -> bool

        set array element at index 'index' return false in case of trouble

        Parameters:
        -----------

        p_element:  array element to set

        index:  index

        if setting was successful 
        """
        return _Library.ByteArray_set_element(*args)

    def element(*args):
        """
        element(self, idx1) -> unsigned str
        element(self, index) -> unsigned str
        element(self, p_array, index) -> unsigned str

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        index:  index

        element of given array at given index 
        """
        return _Library.ByteArray_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.ByteArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned str

        call get_array just before messing with it DO NOT call any
        [],resize/delete functions after get_array(), the pointer may become
        invalid!

        the array 
        """
        return _Library.ByteArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_array_size, p_free_array=True, copy_array=False)
        set_array(self, p_array, p_array_size, p_free_array=True)
        set_array(self, p_array, p_array_size)
        set_array(self, p_array, p_array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        return _Library.ByteArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.ByteArray_clear_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.ByteArray_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.ByteArray_display_array(*args)

ByteArray_swigregister = _Library.ByteArray_swigregister
ByteArray_swigregister(ByteArray)

class ShortArray(SGObject):
    """
    Template class Array implements a dense one dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance array implementation without
    error checking.

    C++ includes: Array.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShortArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShortArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, initial_size=1) -> ShortArray
        __init__(self) -> ShortArray
        __init__(self, p_array, p_array_size, p_free_array=True, p_copy_array=False) -> ShortArray
        __init__(self, p_array, p_array_size, p_free_array=True) -> ShortArray
        __init__(self, p_array, p_array_size) -> ShortArray
        __init__(self, p_array, p_array_size) -> ShortArray

        constructor

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        this = _Library.new_ShortArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_ShortArray
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.ShortArray_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.ShortArray_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.ShortArray_get_dim1(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.ShortArray_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.ShortArray_set_const(*args)

    def get_element(*args):
        """
        get_element(self, index) -> short

        get array element at index

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.ShortArray_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, index) -> bool

        set array element at index 'index' return false in case of trouble

        Parameters:
        -----------

        p_element:  array element to set

        index:  index

        if setting was successful 
        """
        return _Library.ShortArray_set_element(*args)

    def element(*args):
        """
        element(self, idx1) -> short
        element(self, index) -> short
        element(self, p_array, index) -> short

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        index:  index

        element of given array at given index 
        """
        return _Library.ShortArray_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.ShortArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> short

        call get_array just before messing with it DO NOT call any
        [],resize/delete functions after get_array(), the pointer may become
        invalid!

        the array 
        """
        return _Library.ShortArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_array_size, p_free_array=True, copy_array=False)
        set_array(self, p_array, p_array_size, p_free_array=True)
        set_array(self, p_array, p_array_size)
        set_array(self, p_array, p_array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        return _Library.ShortArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.ShortArray_clear_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.ShortArray_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.ShortArray_display_array(*args)

ShortArray_swigregister = _Library.ShortArray_swigregister
ShortArray_swigregister(ShortArray)

class WordArray(SGObject):
    """
    Template class Array implements a dense one dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance array implementation without
    error checking.

    C++ includes: Array.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WordArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WordArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, initial_size=1) -> WordArray
        __init__(self) -> WordArray
        __init__(self, p_array, p_array_size, p_free_array=True, p_copy_array=False) -> WordArray
        __init__(self, p_array, p_array_size, p_free_array=True) -> WordArray
        __init__(self, p_array, p_array_size) -> WordArray
        __init__(self, p_array, p_array_size) -> WordArray

        constructor

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        this = _Library.new_WordArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_WordArray
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.WordArray_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.WordArray_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.WordArray_get_dim1(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.WordArray_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.WordArray_set_const(*args)

    def get_element(*args):
        """
        get_element(self, index) -> unsigned short

        get array element at index

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.WordArray_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, index) -> bool

        set array element at index 'index' return false in case of trouble

        Parameters:
        -----------

        p_element:  array element to set

        index:  index

        if setting was successful 
        """
        return _Library.WordArray_set_element(*args)

    def element(*args):
        """
        element(self, idx1) -> unsigned short
        element(self, index) -> unsigned short
        element(self, p_array, index) -> unsigned short

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        index:  index

        element of given array at given index 
        """
        return _Library.WordArray_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.WordArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned short

        call get_array just before messing with it DO NOT call any
        [],resize/delete functions after get_array(), the pointer may become
        invalid!

        the array 
        """
        return _Library.WordArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_array_size, p_free_array=True, copy_array=False)
        set_array(self, p_array, p_array_size, p_free_array=True)
        set_array(self, p_array, p_array_size)
        set_array(self, p_array, p_array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        return _Library.WordArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.WordArray_clear_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.WordArray_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.WordArray_display_array(*args)

WordArray_swigregister = _Library.WordArray_swigregister
WordArray_swigregister(WordArray)

class IntArray(SGObject):
    """
    Template class Array implements a dense one dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance array implementation without
    error checking.

    C++ includes: Array.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, initial_size=1) -> IntArray
        __init__(self) -> IntArray
        __init__(self, p_array, p_array_size, p_free_array=True, p_copy_array=False) -> IntArray
        __init__(self, p_array, p_array_size, p_free_array=True) -> IntArray
        __init__(self, p_array, p_array_size) -> IntArray
        __init__(self, p_array, p_array_size) -> IntArray

        constructor

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        this = _Library.new_IntArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_IntArray
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.IntArray_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.IntArray_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.IntArray_get_dim1(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.IntArray_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.IntArray_set_const(*args)

    def get_element(*args):
        """
        get_element(self, index) -> int

        get array element at index

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.IntArray_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, index) -> bool

        set array element at index 'index' return false in case of trouble

        Parameters:
        -----------

        p_element:  array element to set

        index:  index

        if setting was successful 
        """
        return _Library.IntArray_set_element(*args)

    def element(*args):
        """
        element(self, idx1) -> int
        element(self, index) -> int
        element(self, p_array, index) -> int

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        index:  index

        element of given array at given index 
        """
        return _Library.IntArray_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.IntArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> int

        call get_array just before messing with it DO NOT call any
        [],resize/delete functions after get_array(), the pointer may become
        invalid!

        the array 
        """
        return _Library.IntArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_array_size, p_free_array=True, copy_array=False)
        set_array(self, p_array, p_array_size, p_free_array=True)
        set_array(self, p_array, p_array_size)
        set_array(self, p_array, p_array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        return _Library.IntArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.IntArray_clear_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.IntArray_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.IntArray_display_array(*args)

IntArray_swigregister = _Library.IntArray_swigregister
IntArray_swigregister(IntArray)

class UIntArray(SGObject):
    """
    Template class Array implements a dense one dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance array implementation without
    error checking.

    C++ includes: Array.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UIntArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UIntArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, initial_size=1) -> UIntArray
        __init__(self) -> UIntArray
        __init__(self, p_array, p_array_size, p_free_array=True, p_copy_array=False) -> UIntArray
        __init__(self, p_array, p_array_size, p_free_array=True) -> UIntArray
        __init__(self, p_array, p_array_size) -> UIntArray
        __init__(self, p_array, p_array_size) -> UIntArray

        constructor

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        this = _Library.new_UIntArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_UIntArray
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.UIntArray_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.UIntArray_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.UIntArray_get_dim1(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.UIntArray_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.UIntArray_set_const(*args)

    def get_element(*args):
        """
        get_element(self, index) -> unsigned int

        get array element at index

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.UIntArray_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, index) -> bool

        set array element at index 'index' return false in case of trouble

        Parameters:
        -----------

        p_element:  array element to set

        index:  index

        if setting was successful 
        """
        return _Library.UIntArray_set_element(*args)

    def element(*args):
        """
        element(self, idx1) -> unsigned int
        element(self, index) -> unsigned int
        element(self, p_array, index) -> unsigned int

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        index:  index

        element of given array at given index 
        """
        return _Library.UIntArray_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.UIntArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned int

        call get_array just before messing with it DO NOT call any
        [],resize/delete functions after get_array(), the pointer may become
        invalid!

        the array 
        """
        return _Library.UIntArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_array_size, p_free_array=True, copy_array=False)
        set_array(self, p_array, p_array_size, p_free_array=True)
        set_array(self, p_array, p_array_size)
        set_array(self, p_array, p_array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        return _Library.UIntArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.UIntArray_clear_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.UIntArray_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.UIntArray_display_array(*args)

UIntArray_swigregister = _Library.UIntArray_swigregister
UIntArray_swigregister(UIntArray)

class LongArray(SGObject):
    """
    Template class Array implements a dense one dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance array implementation without
    error checking.

    C++ includes: Array.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LongArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, initial_size=1) -> LongArray
        __init__(self) -> LongArray
        __init__(self, p_array, p_array_size, p_free_array=True, p_copy_array=False) -> LongArray
        __init__(self, p_array, p_array_size, p_free_array=True) -> LongArray
        __init__(self, p_array, p_array_size) -> LongArray
        __init__(self, p_array, p_array_size) -> LongArray

        constructor

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        this = _Library.new_LongArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_LongArray
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.LongArray_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.LongArray_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.LongArray_get_dim1(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.LongArray_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.LongArray_set_const(*args)

    def get_element(*args):
        """
        get_element(self, index) -> long long

        get array element at index

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.LongArray_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, index) -> bool

        set array element at index 'index' return false in case of trouble

        Parameters:
        -----------

        p_element:  array element to set

        index:  index

        if setting was successful 
        """
        return _Library.LongArray_set_element(*args)

    def element(*args):
        """
        element(self, idx1) -> long long
        element(self, index) -> long long
        element(self, p_array, index) -> long long

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        index:  index

        element of given array at given index 
        """
        return _Library.LongArray_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.LongArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> long long

        call get_array just before messing with it DO NOT call any
        [],resize/delete functions after get_array(), the pointer may become
        invalid!

        the array 
        """
        return _Library.LongArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_array_size, p_free_array=True, copy_array=False)
        set_array(self, p_array, p_array_size, p_free_array=True)
        set_array(self, p_array, p_array_size)
        set_array(self, p_array, p_array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        return _Library.LongArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.LongArray_clear_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.LongArray_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.LongArray_display_array(*args)

LongArray_swigregister = _Library.LongArray_swigregister
LongArray_swigregister(LongArray)

class ULongArray(SGObject):
    """
    Template class Array implements a dense one dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance array implementation without
    error checking.

    C++ includes: Array.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ULongArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ULongArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, initial_size=1) -> ULongArray
        __init__(self) -> ULongArray
        __init__(self, p_array, p_array_size, p_free_array=True, p_copy_array=False) -> ULongArray
        __init__(self, p_array, p_array_size, p_free_array=True) -> ULongArray
        __init__(self, p_array, p_array_size) -> ULongArray
        __init__(self, p_array, p_array_size) -> ULongArray

        constructor

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        this = _Library.new_ULongArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_ULongArray
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.ULongArray_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.ULongArray_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.ULongArray_get_dim1(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.ULongArray_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.ULongArray_set_const(*args)

    def get_element(*args):
        """
        get_element(self, index) -> unsigned long long

        get array element at index

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.ULongArray_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, index) -> bool

        set array element at index 'index' return false in case of trouble

        Parameters:
        -----------

        p_element:  array element to set

        index:  index

        if setting was successful 
        """
        return _Library.ULongArray_set_element(*args)

    def element(*args):
        """
        element(self, idx1) -> unsigned long long
        element(self, index) -> unsigned long long
        element(self, p_array, index) -> unsigned long long

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        index:  index

        element of given array at given index 
        """
        return _Library.ULongArray_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.ULongArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned long long

        call get_array just before messing with it DO NOT call any
        [],resize/delete functions after get_array(), the pointer may become
        invalid!

        the array 
        """
        return _Library.ULongArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_array_size, p_free_array=True, copy_array=False)
        set_array(self, p_array, p_array_size, p_free_array=True)
        set_array(self, p_array, p_array_size)
        set_array(self, p_array, p_array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        return _Library.ULongArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.ULongArray_clear_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.ULongArray_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.ULongArray_display_array(*args)

ULongArray_swigregister = _Library.ULongArray_swigregister
ULongArray_swigregister(ULongArray)

class ShortRealArray(SGObject):
    """
    Template class Array implements a dense one dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance array implementation without
    error checking.

    C++ includes: Array.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShortRealArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShortRealArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, initial_size=1) -> ShortRealArray
        __init__(self) -> ShortRealArray
        __init__(self, p_array, p_array_size, p_free_array=True, p_copy_array=False) -> ShortRealArray
        __init__(self, p_array, p_array_size, p_free_array=True) -> ShortRealArray
        __init__(self, p_array, p_array_size) -> ShortRealArray
        __init__(self, p_array, p_array_size) -> ShortRealArray

        constructor

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        this = _Library.new_ShortRealArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_ShortRealArray
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.ShortRealArray_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.ShortRealArray_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.ShortRealArray_get_dim1(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.ShortRealArray_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.ShortRealArray_set_const(*args)

    def get_element(*args):
        """
        get_element(self, index) -> float

        get array element at index

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.ShortRealArray_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, index) -> bool

        set array element at index 'index' return false in case of trouble

        Parameters:
        -----------

        p_element:  array element to set

        index:  index

        if setting was successful 
        """
        return _Library.ShortRealArray_set_element(*args)

    def element(*args):
        """
        element(self, idx1) -> float
        element(self, index) -> float
        element(self, p_array, index) -> float

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        index:  index

        element of given array at given index 
        """
        return _Library.ShortRealArray_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.ShortRealArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> float

        call get_array just before messing with it DO NOT call any
        [],resize/delete functions after get_array(), the pointer may become
        invalid!

        the array 
        """
        return _Library.ShortRealArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_array_size, p_free_array=True, copy_array=False)
        set_array(self, p_array, p_array_size, p_free_array=True)
        set_array(self, p_array, p_array_size)
        set_array(self, p_array, p_array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        return _Library.ShortRealArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.ShortRealArray_clear_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.ShortRealArray_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.ShortRealArray_display_array(*args)

ShortRealArray_swigregister = _Library.ShortRealArray_swigregister
ShortRealArray_swigregister(ShortRealArray)

class RealArray(SGObject):
    """
    Template class Array implements a dense one dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance array implementation without
    error checking.

    C++ includes: Array.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RealArray, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RealArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, initial_size=1) -> RealArray
        __init__(self) -> RealArray
        __init__(self, p_array, p_array_size, p_free_array=True, p_copy_array=False) -> RealArray
        __init__(self, p_array, p_array_size, p_free_array=True) -> RealArray
        __init__(self, p_array, p_array_size) -> RealArray
        __init__(self, p_array, p_array_size) -> RealArray

        constructor

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        this = _Library.new_RealArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_RealArray
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.RealArray_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.RealArray_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get array size (including granularity buffer)

        total array size 
        """
        return _Library.RealArray_get_dim1(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.RealArray_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.RealArray_set_const(*args)

    def get_element(*args):
        """
        get_element(self, index) -> float

        get array element at index

        Parameters:
        -----------

        index:  index

        array element at index 
        """
        return _Library.RealArray_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, index) -> bool

        set array element at index 'index' return false in case of trouble

        Parameters:
        -----------

        p_element:  array element to set

        index:  index

        if setting was successful 
        """
        return _Library.RealArray_set_element(*args)

    def element(*args):
        """
        element(self, idx1) -> float
        element(self, index) -> float
        element(self, p_array, index) -> float

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        index:  index

        element of given array at given index 
        """
        return _Library.RealArray_element(*args)

    def resize_array(*args):
        """
        resize_array(self, n) -> bool

        resize array

        Parameters:
        -----------

        n:  new size

        if resizing was successful 
        """
        return _Library.RealArray_resize_array(*args)

    def get_array(*args):
        """
        get_array(self) -> float

        call get_array just before messing with it DO NOT call any
        [],resize/delete functions after get_array(), the pointer may become
        invalid!

        the array 
        """
        return _Library.RealArray_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, p_array_size, p_free_array=True, copy_array=False)
        set_array(self, p_array, p_array_size, p_free_array=True)
        set_array(self, p_array, p_array_size)
        set_array(self, p_array, p_array_size)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        p_array_size:  size of another array 
        """
        return _Library.RealArray_set_array(*args)

    def clear_array(*args):
        """
        clear_array(self)

        clear the array (with zeros) 
        """
        return _Library.RealArray_clear_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.RealArray_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.RealArray_display_array(*args)

RealArray_swigregister = _Library.RealArray_swigregister
RealArray_swigregister(RealArray)

class CharArray2(CharArray):
    """
    Template class Array2 implements a dense two dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 2d-array implementation without
    error checking.

    C++ includes: Array2.h 
    """
    __swig_setmethods__ = {}
    for _s in [CharArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CharArray2, name, value)
    __swig_getmethods__ = {}
    for _s in [CharArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CharArray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, dim1=1, dim2=1) -> CharArray2
        __init__(self, dim1=1) -> CharArray2
        __init__(self) -> CharArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True, p_copy_array=False) -> CharArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True) -> CharArray2
        __init__(self, p_array, dim1, dim2) -> CharArray2
        __init__(self, p_array, dim1, dim2) -> CharArray2

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2 
        """
        this = _Library.new_CharArray2(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_CharArray2
    __del__ = lambda self : None;
    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here 
        """
        return _Library.CharArray2_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.CharArray2_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.CharArray2_get_dim2(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.CharArray2_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.CharArray2_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> str

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.CharArray2_get_array(*args)

    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.CharArray2_set_name(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, p_free_array=True, copy_array=False)
        set_array(self, p_array, dim1, dim2, p_free_array=True)
        set_array(self, p_array, dim1, dim2)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.CharArray2_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        if resizing was successful 
        """
        return _Library.CharArray2_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2) -> str

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        array element at index 
        """
        return _Library.CharArray2_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        if setting was successful 
        """
        return _Library.CharArray2_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2) -> str
        element(self, idx1, idx2) -> str
        element(self, p_array, idx1, idx2) -> str
        element(self, p_array, idx1, idx2, p_dim1_size) -> str

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        p_dim1_size:  size of dimension 1

        element of given array at given index 
        """
        return _Library.CharArray2_element(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.CharArray2_display_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.CharArray2_display_size(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.CharArray2_get_name(*args)

CharArray2_swigregister = _Library.CharArray2_swigregister
CharArray2_swigregister(CharArray2)

class ByteArray2(ByteArray):
    """
    Template class Array2 implements a dense two dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 2d-array implementation without
    error checking.

    C++ includes: Array2.h 
    """
    __swig_setmethods__ = {}
    for _s in [ByteArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteArray2, name, value)
    __swig_getmethods__ = {}
    for _s in [ByteArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteArray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, dim1=1, dim2=1) -> ByteArray2
        __init__(self, dim1=1) -> ByteArray2
        __init__(self) -> ByteArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True, p_copy_array=False) -> ByteArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True) -> ByteArray2
        __init__(self, p_array, dim1, dim2) -> ByteArray2
        __init__(self, p_array, dim1, dim2) -> ByteArray2

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2 
        """
        this = _Library.new_ByteArray2(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_ByteArray2
    __del__ = lambda self : None;
    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here 
        """
        return _Library.ByteArray2_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.ByteArray2_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.ByteArray2_get_dim2(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.ByteArray2_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.ByteArray2_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned str

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.ByteArray2_get_array(*args)

    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.ByteArray2_set_name(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, p_free_array=True, copy_array=False)
        set_array(self, p_array, dim1, dim2, p_free_array=True)
        set_array(self, p_array, dim1, dim2)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.ByteArray2_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        if resizing was successful 
        """
        return _Library.ByteArray2_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2) -> unsigned str

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        array element at index 
        """
        return _Library.ByteArray2_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        if setting was successful 
        """
        return _Library.ByteArray2_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2) -> unsigned str
        element(self, idx1, idx2) -> unsigned str
        element(self, p_array, idx1, idx2) -> unsigned str
        element(self, p_array, idx1, idx2, p_dim1_size) -> unsigned str

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        p_dim1_size:  size of dimension 1

        element of given array at given index 
        """
        return _Library.ByteArray2_element(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.ByteArray2_display_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.ByteArray2_display_size(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.ByteArray2_get_name(*args)

ByteArray2_swigregister = _Library.ByteArray2_swigregister
ByteArray2_swigregister(ByteArray2)

class ShortArray2(ShortArray):
    """
    Template class Array2 implements a dense two dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 2d-array implementation without
    error checking.

    C++ includes: Array2.h 
    """
    __swig_setmethods__ = {}
    for _s in [ShortArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShortArray2, name, value)
    __swig_getmethods__ = {}
    for _s in [ShortArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShortArray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, dim1=1, dim2=1) -> ShortArray2
        __init__(self, dim1=1) -> ShortArray2
        __init__(self) -> ShortArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True, p_copy_array=False) -> ShortArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True) -> ShortArray2
        __init__(self, p_array, dim1, dim2) -> ShortArray2
        __init__(self, p_array, dim1, dim2) -> ShortArray2

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2 
        """
        this = _Library.new_ShortArray2(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_ShortArray2
    __del__ = lambda self : None;
    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here 
        """
        return _Library.ShortArray2_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.ShortArray2_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.ShortArray2_get_dim2(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.ShortArray2_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.ShortArray2_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> short

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.ShortArray2_get_array(*args)

    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.ShortArray2_set_name(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, p_free_array=True, copy_array=False)
        set_array(self, p_array, dim1, dim2, p_free_array=True)
        set_array(self, p_array, dim1, dim2)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.ShortArray2_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        if resizing was successful 
        """
        return _Library.ShortArray2_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2) -> short

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        array element at index 
        """
        return _Library.ShortArray2_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        if setting was successful 
        """
        return _Library.ShortArray2_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2) -> short
        element(self, idx1, idx2) -> short
        element(self, p_array, idx1, idx2) -> short
        element(self, p_array, idx1, idx2, p_dim1_size) -> short

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        p_dim1_size:  size of dimension 1

        element of given array at given index 
        """
        return _Library.ShortArray2_element(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.ShortArray2_display_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.ShortArray2_display_size(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.ShortArray2_get_name(*args)

ShortArray2_swigregister = _Library.ShortArray2_swigregister
ShortArray2_swigregister(ShortArray2)

class WordArray2(WordArray):
    """
    Template class Array2 implements a dense two dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 2d-array implementation without
    error checking.

    C++ includes: Array2.h 
    """
    __swig_setmethods__ = {}
    for _s in [WordArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WordArray2, name, value)
    __swig_getmethods__ = {}
    for _s in [WordArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WordArray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, dim1=1, dim2=1) -> WordArray2
        __init__(self, dim1=1) -> WordArray2
        __init__(self) -> WordArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True, p_copy_array=False) -> WordArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True) -> WordArray2
        __init__(self, p_array, dim1, dim2) -> WordArray2
        __init__(self, p_array, dim1, dim2) -> WordArray2

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2 
        """
        this = _Library.new_WordArray2(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_WordArray2
    __del__ = lambda self : None;
    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here 
        """
        return _Library.WordArray2_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.WordArray2_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.WordArray2_get_dim2(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.WordArray2_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.WordArray2_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned short

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.WordArray2_get_array(*args)

    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.WordArray2_set_name(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, p_free_array=True, copy_array=False)
        set_array(self, p_array, dim1, dim2, p_free_array=True)
        set_array(self, p_array, dim1, dim2)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.WordArray2_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        if resizing was successful 
        """
        return _Library.WordArray2_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2) -> unsigned short

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        array element at index 
        """
        return _Library.WordArray2_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        if setting was successful 
        """
        return _Library.WordArray2_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2) -> unsigned short
        element(self, idx1, idx2) -> unsigned short
        element(self, p_array, idx1, idx2) -> unsigned short
        element(self, p_array, idx1, idx2, p_dim1_size) -> unsigned short

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        p_dim1_size:  size of dimension 1

        element of given array at given index 
        """
        return _Library.WordArray2_element(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.WordArray2_display_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.WordArray2_display_size(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.WordArray2_get_name(*args)

WordArray2_swigregister = _Library.WordArray2_swigregister
WordArray2_swigregister(WordArray2)

class IntArray2(IntArray):
    """
    Template class Array2 implements a dense two dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 2d-array implementation without
    error checking.

    C++ includes: Array2.h 
    """
    __swig_setmethods__ = {}
    for _s in [IntArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntArray2, name, value)
    __swig_getmethods__ = {}
    for _s in [IntArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntArray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, dim1=1, dim2=1) -> IntArray2
        __init__(self, dim1=1) -> IntArray2
        __init__(self) -> IntArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True, p_copy_array=False) -> IntArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True) -> IntArray2
        __init__(self, p_array, dim1, dim2) -> IntArray2
        __init__(self, p_array, dim1, dim2) -> IntArray2

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2 
        """
        this = _Library.new_IntArray2(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_IntArray2
    __del__ = lambda self : None;
    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here 
        """
        return _Library.IntArray2_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.IntArray2_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.IntArray2_get_dim2(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.IntArray2_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.IntArray2_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> int

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.IntArray2_get_array(*args)

    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.IntArray2_set_name(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, p_free_array=True, copy_array=False)
        set_array(self, p_array, dim1, dim2, p_free_array=True)
        set_array(self, p_array, dim1, dim2)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.IntArray2_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        if resizing was successful 
        """
        return _Library.IntArray2_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2) -> int

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        array element at index 
        """
        return _Library.IntArray2_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        if setting was successful 
        """
        return _Library.IntArray2_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2) -> int
        element(self, idx1, idx2) -> int
        element(self, p_array, idx1, idx2) -> int
        element(self, p_array, idx1, idx2, p_dim1_size) -> int

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        p_dim1_size:  size of dimension 1

        element of given array at given index 
        """
        return _Library.IntArray2_element(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.IntArray2_display_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.IntArray2_display_size(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.IntArray2_get_name(*args)

IntArray2_swigregister = _Library.IntArray2_swigregister
IntArray2_swigregister(IntArray2)

class UIntArray2(UIntArray):
    """
    Template class Array2 implements a dense two dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 2d-array implementation without
    error checking.

    C++ includes: Array2.h 
    """
    __swig_setmethods__ = {}
    for _s in [UIntArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UIntArray2, name, value)
    __swig_getmethods__ = {}
    for _s in [UIntArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UIntArray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, dim1=1, dim2=1) -> UIntArray2
        __init__(self, dim1=1) -> UIntArray2
        __init__(self) -> UIntArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True, p_copy_array=False) -> UIntArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True) -> UIntArray2
        __init__(self, p_array, dim1, dim2) -> UIntArray2
        __init__(self, p_array, dim1, dim2) -> UIntArray2

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2 
        """
        this = _Library.new_UIntArray2(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_UIntArray2
    __del__ = lambda self : None;
    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here 
        """
        return _Library.UIntArray2_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.UIntArray2_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.UIntArray2_get_dim2(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.UIntArray2_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.UIntArray2_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned int

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.UIntArray2_get_array(*args)

    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.UIntArray2_set_name(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, p_free_array=True, copy_array=False)
        set_array(self, p_array, dim1, dim2, p_free_array=True)
        set_array(self, p_array, dim1, dim2)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.UIntArray2_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        if resizing was successful 
        """
        return _Library.UIntArray2_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2) -> unsigned int

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        array element at index 
        """
        return _Library.UIntArray2_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        if setting was successful 
        """
        return _Library.UIntArray2_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2) -> unsigned int
        element(self, idx1, idx2) -> unsigned int
        element(self, p_array, idx1, idx2) -> unsigned int
        element(self, p_array, idx1, idx2, p_dim1_size) -> unsigned int

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        p_dim1_size:  size of dimension 1

        element of given array at given index 
        """
        return _Library.UIntArray2_element(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.UIntArray2_display_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.UIntArray2_display_size(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.UIntArray2_get_name(*args)

UIntArray2_swigregister = _Library.UIntArray2_swigregister
UIntArray2_swigregister(UIntArray2)

class LongArray2(LongArray):
    """
    Template class Array2 implements a dense two dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 2d-array implementation without
    error checking.

    C++ includes: Array2.h 
    """
    __swig_setmethods__ = {}
    for _s in [LongArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongArray2, name, value)
    __swig_getmethods__ = {}
    for _s in [LongArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LongArray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, dim1=1, dim2=1) -> LongArray2
        __init__(self, dim1=1) -> LongArray2
        __init__(self) -> LongArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True, p_copy_array=False) -> LongArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True) -> LongArray2
        __init__(self, p_array, dim1, dim2) -> LongArray2
        __init__(self, p_array, dim1, dim2) -> LongArray2

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2 
        """
        this = _Library.new_LongArray2(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_LongArray2
    __del__ = lambda self : None;
    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here 
        """
        return _Library.LongArray2_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.LongArray2_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.LongArray2_get_dim2(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.LongArray2_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.LongArray2_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> long long

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.LongArray2_get_array(*args)

    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.LongArray2_set_name(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, p_free_array=True, copy_array=False)
        set_array(self, p_array, dim1, dim2, p_free_array=True)
        set_array(self, p_array, dim1, dim2)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.LongArray2_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        if resizing was successful 
        """
        return _Library.LongArray2_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2) -> long long

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        array element at index 
        """
        return _Library.LongArray2_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        if setting was successful 
        """
        return _Library.LongArray2_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2) -> long long
        element(self, idx1, idx2) -> long long
        element(self, p_array, idx1, idx2) -> long long
        element(self, p_array, idx1, idx2, p_dim1_size) -> long long

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        p_dim1_size:  size of dimension 1

        element of given array at given index 
        """
        return _Library.LongArray2_element(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.LongArray2_display_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.LongArray2_display_size(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.LongArray2_get_name(*args)

LongArray2_swigregister = _Library.LongArray2_swigregister
LongArray2_swigregister(LongArray2)

class ULongArray2(ULongArray):
    """
    Template class Array2 implements a dense two dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 2d-array implementation without
    error checking.

    C++ includes: Array2.h 
    """
    __swig_setmethods__ = {}
    for _s in [ULongArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ULongArray2, name, value)
    __swig_getmethods__ = {}
    for _s in [ULongArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ULongArray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, dim1=1, dim2=1) -> ULongArray2
        __init__(self, dim1=1) -> ULongArray2
        __init__(self) -> ULongArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True, p_copy_array=False) -> ULongArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True) -> ULongArray2
        __init__(self, p_array, dim1, dim2) -> ULongArray2
        __init__(self, p_array, dim1, dim2) -> ULongArray2

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2 
        """
        this = _Library.new_ULongArray2(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_ULongArray2
    __del__ = lambda self : None;
    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here 
        """
        return _Library.ULongArray2_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.ULongArray2_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.ULongArray2_get_dim2(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.ULongArray2_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.ULongArray2_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned long long

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.ULongArray2_get_array(*args)

    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.ULongArray2_set_name(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, p_free_array=True, copy_array=False)
        set_array(self, p_array, dim1, dim2, p_free_array=True)
        set_array(self, p_array, dim1, dim2)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.ULongArray2_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        if resizing was successful 
        """
        return _Library.ULongArray2_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2) -> unsigned long long

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        array element at index 
        """
        return _Library.ULongArray2_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        if setting was successful 
        """
        return _Library.ULongArray2_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2) -> unsigned long long
        element(self, idx1, idx2) -> unsigned long long
        element(self, p_array, idx1, idx2) -> unsigned long long
        element(self, p_array, idx1, idx2, p_dim1_size) -> unsigned long long

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        p_dim1_size:  size of dimension 1

        element of given array at given index 
        """
        return _Library.ULongArray2_element(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.ULongArray2_display_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.ULongArray2_display_size(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.ULongArray2_get_name(*args)

ULongArray2_swigregister = _Library.ULongArray2_swigregister
ULongArray2_swigregister(ULongArray2)

class ShortRealArray2(ShortRealArray):
    """
    Template class Array2 implements a dense two dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 2d-array implementation without
    error checking.

    C++ includes: Array2.h 
    """
    __swig_setmethods__ = {}
    for _s in [ShortRealArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShortRealArray2, name, value)
    __swig_getmethods__ = {}
    for _s in [ShortRealArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShortRealArray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, dim1=1, dim2=1) -> ShortRealArray2
        __init__(self, dim1=1) -> ShortRealArray2
        __init__(self) -> ShortRealArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True, p_copy_array=False) -> ShortRealArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True) -> ShortRealArray2
        __init__(self, p_array, dim1, dim2) -> ShortRealArray2
        __init__(self, p_array, dim1, dim2) -> ShortRealArray2

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2 
        """
        this = _Library.new_ShortRealArray2(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_ShortRealArray2
    __del__ = lambda self : None;
    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here 
        """
        return _Library.ShortRealArray2_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.ShortRealArray2_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.ShortRealArray2_get_dim2(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.ShortRealArray2_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.ShortRealArray2_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> float

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.ShortRealArray2_get_array(*args)

    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.ShortRealArray2_set_name(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, p_free_array=True, copy_array=False)
        set_array(self, p_array, dim1, dim2, p_free_array=True)
        set_array(self, p_array, dim1, dim2)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.ShortRealArray2_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        if resizing was successful 
        """
        return _Library.ShortRealArray2_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2) -> float

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        array element at index 
        """
        return _Library.ShortRealArray2_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        if setting was successful 
        """
        return _Library.ShortRealArray2_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2) -> float
        element(self, idx1, idx2) -> float
        element(self, p_array, idx1, idx2) -> float
        element(self, p_array, idx1, idx2, p_dim1_size) -> float

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        p_dim1_size:  size of dimension 1

        element of given array at given index 
        """
        return _Library.ShortRealArray2_element(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.ShortRealArray2_display_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.ShortRealArray2_display_size(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.ShortRealArray2_get_name(*args)

ShortRealArray2_swigregister = _Library.ShortRealArray2_swigregister
ShortRealArray2_swigregister(ShortRealArray2)

class RealArray2(RealArray):
    """
    Template class Array2 implements a dense two dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 2d-array implementation without
    error checking.

    C++ includes: Array2.h 
    """
    __swig_setmethods__ = {}
    for _s in [RealArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RealArray2, name, value)
    __swig_getmethods__ = {}
    for _s in [RealArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RealArray2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, dim1=1, dim2=1) -> RealArray2
        __init__(self, dim1=1) -> RealArray2
        __init__(self) -> RealArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True, p_copy_array=False) -> RealArray2
        __init__(self, p_array, dim1, dim2, p_free_array=True) -> RealArray2
        __init__(self, p_array, dim1, dim2) -> RealArray2
        __init__(self, p_array, dim1, dim2) -> RealArray2

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2 
        """
        this = _Library.new_RealArray2(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_RealArray2
    __del__ = lambda self : None;
    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here 
        """
        return _Library.RealArray2_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.RealArray2_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.RealArray2_get_dim2(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.RealArray2_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.RealArray2_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> float

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.RealArray2_get_array(*args)

    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.RealArray2_set_name(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, p_free_array=True, copy_array=False)
        set_array(self, p_array, dim1, dim2, p_free_array=True)
        set_array(self, p_array, dim1, dim2)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.RealArray2_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        if resizing was successful 
        """
        return _Library.RealArray2_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2) -> float

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        array element at index 
        """
        return _Library.RealArray2_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        if setting was successful 
        """
        return _Library.RealArray2_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2) -> float
        element(self, idx1, idx2) -> float
        element(self, p_array, idx1, idx2) -> float
        element(self, p_array, idx1, idx2, p_dim1_size) -> float

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        p_dim1_size:  size of dimension 1

        element of given array at given index 
        """
        return _Library.RealArray2_element(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.RealArray2_display_array(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.RealArray2_display_size(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.RealArray2_get_name(*args)

RealArray2_swigregister = _Library.RealArray2_swigregister
RealArray2_swigregister(RealArray2)

class CharArray3(CharArray):
    """
    Template class Array3 implements a dense three dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 3d-array implementation without
    error checking.

    C++ includes: Array3.h 
    """
    __swig_setmethods__ = {}
    for _s in [CharArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CharArray3, name, value)
    __swig_getmethods__ = {}
    for _s in [CharArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CharArray3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> CharArray3
        __init__(self, dim1, dim2, dim3) -> CharArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True, p_copy_array=False) -> CharArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True) -> CharArray3
        __init__(self, p_array, dim1, dim2, dim3) -> CharArray3
        __init__(self, p_array, dim1, dim2, dim3) -> CharArray3

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2

        dim3:  dimension 3 
        """
        this = _Library.new_CharArray3(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_CharArray3
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.CharArray3_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2, dim3)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here

        dim3:  dimension 3 will be stored here 
        """
        return _Library.CharArray3_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.CharArray3_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.CharArray3_get_dim2(*args)

    def get_dim3(*args):
        """
        get_dim3(self) ->  int

        get dimension 3

        dimension 3 
        """
        return _Library.CharArray3_get_dim3(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.CharArray3_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.CharArray3_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> str

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.CharArray3_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, dim3, p_free_array, copy_array=False)
        set_array(self, p_array, dim1, dim2, dim3, p_free_array)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        dim3:  dimensino 3

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.CharArray3_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2, dim3) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        dim3:  new dimension 3

        if resizing was successful 
        """
        return _Library.CharArray3_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2, idx3) -> str

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        array element at index 
        """
        return _Library.CharArray3_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2, idx3) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        if setting was successful 
        """
        return _Library.CharArray3_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2, idx3) -> str
        element(self, idx1, idx2, idx3) -> str
        element(self, p_array, idx1, idx2, idx3) -> str
        element(self, p_array, idx1, idx2, idx3, p_dim1_size, p_dim2_size) -> str

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        p_dim1_size:  size of dimension 1

        p_dim2_size:  size of dimension 2

        element of given array at given index 
        """
        return _Library.CharArray3_element(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.CharArray3_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.CharArray3_display_array(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.CharArray3_get_name(*args)

CharArray3_swigregister = _Library.CharArray3_swigregister
CharArray3_swigregister(CharArray3)

class ByteArray3(ByteArray):
    """
    Template class Array3 implements a dense three dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 3d-array implementation without
    error checking.

    C++ includes: Array3.h 
    """
    __swig_setmethods__ = {}
    for _s in [ByteArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteArray3, name, value)
    __swig_getmethods__ = {}
    for _s in [ByteArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteArray3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> ByteArray3
        __init__(self, dim1, dim2, dim3) -> ByteArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True, p_copy_array=False) -> ByteArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True) -> ByteArray3
        __init__(self, p_array, dim1, dim2, dim3) -> ByteArray3
        __init__(self, p_array, dim1, dim2, dim3) -> ByteArray3

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2

        dim3:  dimension 3 
        """
        this = _Library.new_ByteArray3(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_ByteArray3
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.ByteArray3_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2, dim3)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here

        dim3:  dimension 3 will be stored here 
        """
        return _Library.ByteArray3_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.ByteArray3_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.ByteArray3_get_dim2(*args)

    def get_dim3(*args):
        """
        get_dim3(self) ->  int

        get dimension 3

        dimension 3 
        """
        return _Library.ByteArray3_get_dim3(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.ByteArray3_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.ByteArray3_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned str

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.ByteArray3_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, dim3, p_free_array, copy_array=False)
        set_array(self, p_array, dim1, dim2, dim3, p_free_array)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        dim3:  dimensino 3

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.ByteArray3_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2, dim3) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        dim3:  new dimension 3

        if resizing was successful 
        """
        return _Library.ByteArray3_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2, idx3) -> unsigned str

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        array element at index 
        """
        return _Library.ByteArray3_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2, idx3) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        if setting was successful 
        """
        return _Library.ByteArray3_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2, idx3) -> unsigned str
        element(self, idx1, idx2, idx3) -> unsigned str
        element(self, p_array, idx1, idx2, idx3) -> unsigned str
        element(self, p_array, idx1, idx2, idx3, p_dim1_size, p_dim2_size) -> unsigned str

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        p_dim1_size:  size of dimension 1

        p_dim2_size:  size of dimension 2

        element of given array at given index 
        """
        return _Library.ByteArray3_element(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.ByteArray3_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.ByteArray3_display_array(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.ByteArray3_get_name(*args)

ByteArray3_swigregister = _Library.ByteArray3_swigregister
ByteArray3_swigregister(ByteArray3)

class ShortArray3(ShortArray):
    """
    Template class Array3 implements a dense three dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 3d-array implementation without
    error checking.

    C++ includes: Array3.h 
    """
    __swig_setmethods__ = {}
    for _s in [ShortArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShortArray3, name, value)
    __swig_getmethods__ = {}
    for _s in [ShortArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShortArray3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> ShortArray3
        __init__(self, dim1, dim2, dim3) -> ShortArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True, p_copy_array=False) -> ShortArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True) -> ShortArray3
        __init__(self, p_array, dim1, dim2, dim3) -> ShortArray3
        __init__(self, p_array, dim1, dim2, dim3) -> ShortArray3

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2

        dim3:  dimension 3 
        """
        this = _Library.new_ShortArray3(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_ShortArray3
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.ShortArray3_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2, dim3)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here

        dim3:  dimension 3 will be stored here 
        """
        return _Library.ShortArray3_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.ShortArray3_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.ShortArray3_get_dim2(*args)

    def get_dim3(*args):
        """
        get_dim3(self) ->  int

        get dimension 3

        dimension 3 
        """
        return _Library.ShortArray3_get_dim3(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.ShortArray3_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.ShortArray3_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> short

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.ShortArray3_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, dim3, p_free_array, copy_array=False)
        set_array(self, p_array, dim1, dim2, dim3, p_free_array)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        dim3:  dimensino 3

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.ShortArray3_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2, dim3) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        dim3:  new dimension 3

        if resizing was successful 
        """
        return _Library.ShortArray3_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2, idx3) -> short

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        array element at index 
        """
        return _Library.ShortArray3_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2, idx3) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        if setting was successful 
        """
        return _Library.ShortArray3_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2, idx3) -> short
        element(self, idx1, idx2, idx3) -> short
        element(self, p_array, idx1, idx2, idx3) -> short
        element(self, p_array, idx1, idx2, idx3, p_dim1_size, p_dim2_size) -> short

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        p_dim1_size:  size of dimension 1

        p_dim2_size:  size of dimension 2

        element of given array at given index 
        """
        return _Library.ShortArray3_element(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.ShortArray3_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.ShortArray3_display_array(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.ShortArray3_get_name(*args)

ShortArray3_swigregister = _Library.ShortArray3_swigregister
ShortArray3_swigregister(ShortArray3)

class WordArray3(WordArray):
    """
    Template class Array3 implements a dense three dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 3d-array implementation without
    error checking.

    C++ includes: Array3.h 
    """
    __swig_setmethods__ = {}
    for _s in [WordArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WordArray3, name, value)
    __swig_getmethods__ = {}
    for _s in [WordArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WordArray3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> WordArray3
        __init__(self, dim1, dim2, dim3) -> WordArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True, p_copy_array=False) -> WordArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True) -> WordArray3
        __init__(self, p_array, dim1, dim2, dim3) -> WordArray3
        __init__(self, p_array, dim1, dim2, dim3) -> WordArray3

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2

        dim3:  dimension 3 
        """
        this = _Library.new_WordArray3(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_WordArray3
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.WordArray3_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2, dim3)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here

        dim3:  dimension 3 will be stored here 
        """
        return _Library.WordArray3_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.WordArray3_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.WordArray3_get_dim2(*args)

    def get_dim3(*args):
        """
        get_dim3(self) ->  int

        get dimension 3

        dimension 3 
        """
        return _Library.WordArray3_get_dim3(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.WordArray3_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.WordArray3_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned short

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.WordArray3_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, dim3, p_free_array, copy_array=False)
        set_array(self, p_array, dim1, dim2, dim3, p_free_array)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        dim3:  dimensino 3

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.WordArray3_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2, dim3) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        dim3:  new dimension 3

        if resizing was successful 
        """
        return _Library.WordArray3_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2, idx3) -> unsigned short

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        array element at index 
        """
        return _Library.WordArray3_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2, idx3) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        if setting was successful 
        """
        return _Library.WordArray3_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2, idx3) -> unsigned short
        element(self, idx1, idx2, idx3) -> unsigned short
        element(self, p_array, idx1, idx2, idx3) -> unsigned short
        element(self, p_array, idx1, idx2, idx3, p_dim1_size, p_dim2_size) -> unsigned short

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        p_dim1_size:  size of dimension 1

        p_dim2_size:  size of dimension 2

        element of given array at given index 
        """
        return _Library.WordArray3_element(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.WordArray3_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.WordArray3_display_array(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.WordArray3_get_name(*args)

WordArray3_swigregister = _Library.WordArray3_swigregister
WordArray3_swigregister(WordArray3)

class IntArray3(IntArray):
    """
    Template class Array3 implements a dense three dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 3d-array implementation without
    error checking.

    C++ includes: Array3.h 
    """
    __swig_setmethods__ = {}
    for _s in [IntArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntArray3, name, value)
    __swig_getmethods__ = {}
    for _s in [IntArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntArray3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IntArray3
        __init__(self, dim1, dim2, dim3) -> IntArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True, p_copy_array=False) -> IntArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True) -> IntArray3
        __init__(self, p_array, dim1, dim2, dim3) -> IntArray3
        __init__(self, p_array, dim1, dim2, dim3) -> IntArray3

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2

        dim3:  dimension 3 
        """
        this = _Library.new_IntArray3(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_IntArray3
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.IntArray3_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2, dim3)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here

        dim3:  dimension 3 will be stored here 
        """
        return _Library.IntArray3_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.IntArray3_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.IntArray3_get_dim2(*args)

    def get_dim3(*args):
        """
        get_dim3(self) ->  int

        get dimension 3

        dimension 3 
        """
        return _Library.IntArray3_get_dim3(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.IntArray3_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.IntArray3_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> int

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.IntArray3_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, dim3, p_free_array, copy_array=False)
        set_array(self, p_array, dim1, dim2, dim3, p_free_array)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        dim3:  dimensino 3

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.IntArray3_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2, dim3) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        dim3:  new dimension 3

        if resizing was successful 
        """
        return _Library.IntArray3_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2, idx3) -> int

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        array element at index 
        """
        return _Library.IntArray3_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2, idx3) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        if setting was successful 
        """
        return _Library.IntArray3_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2, idx3) -> int
        element(self, idx1, idx2, idx3) -> int
        element(self, p_array, idx1, idx2, idx3) -> int
        element(self, p_array, idx1, idx2, idx3, p_dim1_size, p_dim2_size) -> int

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        p_dim1_size:  size of dimension 1

        p_dim2_size:  size of dimension 2

        element of given array at given index 
        """
        return _Library.IntArray3_element(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.IntArray3_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.IntArray3_display_array(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.IntArray3_get_name(*args)

IntArray3_swigregister = _Library.IntArray3_swigregister
IntArray3_swigregister(IntArray3)

class UIntArray3(UIntArray):
    """
    Template class Array3 implements a dense three dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 3d-array implementation without
    error checking.

    C++ includes: Array3.h 
    """
    __swig_setmethods__ = {}
    for _s in [UIntArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UIntArray3, name, value)
    __swig_getmethods__ = {}
    for _s in [UIntArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UIntArray3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> UIntArray3
        __init__(self, dim1, dim2, dim3) -> UIntArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True, p_copy_array=False) -> UIntArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True) -> UIntArray3
        __init__(self, p_array, dim1, dim2, dim3) -> UIntArray3
        __init__(self, p_array, dim1, dim2, dim3) -> UIntArray3

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2

        dim3:  dimension 3 
        """
        this = _Library.new_UIntArray3(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_UIntArray3
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.UIntArray3_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2, dim3)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here

        dim3:  dimension 3 will be stored here 
        """
        return _Library.UIntArray3_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.UIntArray3_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.UIntArray3_get_dim2(*args)

    def get_dim3(*args):
        """
        get_dim3(self) ->  int

        get dimension 3

        dimension 3 
        """
        return _Library.UIntArray3_get_dim3(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.UIntArray3_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.UIntArray3_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned int

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.UIntArray3_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, dim3, p_free_array, copy_array=False)
        set_array(self, p_array, dim1, dim2, dim3, p_free_array)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        dim3:  dimensino 3

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.UIntArray3_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2, dim3) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        dim3:  new dimension 3

        if resizing was successful 
        """
        return _Library.UIntArray3_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2, idx3) -> unsigned int

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        array element at index 
        """
        return _Library.UIntArray3_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2, idx3) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        if setting was successful 
        """
        return _Library.UIntArray3_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2, idx3) -> unsigned int
        element(self, idx1, idx2, idx3) -> unsigned int
        element(self, p_array, idx1, idx2, idx3) -> unsigned int
        element(self, p_array, idx1, idx2, idx3, p_dim1_size, p_dim2_size) -> unsigned int

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        p_dim1_size:  size of dimension 1

        p_dim2_size:  size of dimension 2

        element of given array at given index 
        """
        return _Library.UIntArray3_element(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.UIntArray3_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.UIntArray3_display_array(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.UIntArray3_get_name(*args)

UIntArray3_swigregister = _Library.UIntArray3_swigregister
UIntArray3_swigregister(UIntArray3)

class LongArray3(LongArray):
    """
    Template class Array3 implements a dense three dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 3d-array implementation without
    error checking.

    C++ includes: Array3.h 
    """
    __swig_setmethods__ = {}
    for _s in [LongArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongArray3, name, value)
    __swig_getmethods__ = {}
    for _s in [LongArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LongArray3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> LongArray3
        __init__(self, dim1, dim2, dim3) -> LongArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True, p_copy_array=False) -> LongArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True) -> LongArray3
        __init__(self, p_array, dim1, dim2, dim3) -> LongArray3
        __init__(self, p_array, dim1, dim2, dim3) -> LongArray3

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2

        dim3:  dimension 3 
        """
        this = _Library.new_LongArray3(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_LongArray3
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.LongArray3_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2, dim3)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here

        dim3:  dimension 3 will be stored here 
        """
        return _Library.LongArray3_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.LongArray3_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.LongArray3_get_dim2(*args)

    def get_dim3(*args):
        """
        get_dim3(self) ->  int

        get dimension 3

        dimension 3 
        """
        return _Library.LongArray3_get_dim3(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.LongArray3_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.LongArray3_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> long long

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.LongArray3_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, dim3, p_free_array, copy_array=False)
        set_array(self, p_array, dim1, dim2, dim3, p_free_array)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        dim3:  dimensino 3

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.LongArray3_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2, dim3) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        dim3:  new dimension 3

        if resizing was successful 
        """
        return _Library.LongArray3_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2, idx3) -> long long

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        array element at index 
        """
        return _Library.LongArray3_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2, idx3) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        if setting was successful 
        """
        return _Library.LongArray3_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2, idx3) -> long long
        element(self, idx1, idx2, idx3) -> long long
        element(self, p_array, idx1, idx2, idx3) -> long long
        element(self, p_array, idx1, idx2, idx3, p_dim1_size, p_dim2_size) -> long long

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        p_dim1_size:  size of dimension 1

        p_dim2_size:  size of dimension 2

        element of given array at given index 
        """
        return _Library.LongArray3_element(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.LongArray3_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.LongArray3_display_array(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.LongArray3_get_name(*args)

LongArray3_swigregister = _Library.LongArray3_swigregister
LongArray3_swigregister(LongArray3)

class ULongArray3(ULongArray):
    """
    Template class Array3 implements a dense three dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 3d-array implementation without
    error checking.

    C++ includes: Array3.h 
    """
    __swig_setmethods__ = {}
    for _s in [ULongArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ULongArray3, name, value)
    __swig_getmethods__ = {}
    for _s in [ULongArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ULongArray3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> ULongArray3
        __init__(self, dim1, dim2, dim3) -> ULongArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True, p_copy_array=False) -> ULongArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True) -> ULongArray3
        __init__(self, p_array, dim1, dim2, dim3) -> ULongArray3
        __init__(self, p_array, dim1, dim2, dim3) -> ULongArray3

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2

        dim3:  dimension 3 
        """
        this = _Library.new_ULongArray3(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_ULongArray3
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.ULongArray3_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2, dim3)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here

        dim3:  dimension 3 will be stored here 
        """
        return _Library.ULongArray3_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.ULongArray3_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.ULongArray3_get_dim2(*args)

    def get_dim3(*args):
        """
        get_dim3(self) ->  int

        get dimension 3

        dimension 3 
        """
        return _Library.ULongArray3_get_dim3(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.ULongArray3_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.ULongArray3_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> unsigned long long

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.ULongArray3_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, dim3, p_free_array, copy_array=False)
        set_array(self, p_array, dim1, dim2, dim3, p_free_array)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        dim3:  dimensino 3

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.ULongArray3_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2, dim3) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        dim3:  new dimension 3

        if resizing was successful 
        """
        return _Library.ULongArray3_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2, idx3) -> unsigned long long

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        array element at index 
        """
        return _Library.ULongArray3_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2, idx3) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        if setting was successful 
        """
        return _Library.ULongArray3_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2, idx3) -> unsigned long long
        element(self, idx1, idx2, idx3) -> unsigned long long
        element(self, p_array, idx1, idx2, idx3) -> unsigned long long
        element(self, p_array, idx1, idx2, idx3, p_dim1_size, p_dim2_size) -> unsigned long long

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        p_dim1_size:  size of dimension 1

        p_dim2_size:  size of dimension 2

        element of given array at given index 
        """
        return _Library.ULongArray3_element(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.ULongArray3_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.ULongArray3_display_array(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.ULongArray3_get_name(*args)

ULongArray3_swigregister = _Library.ULongArray3_swigregister
ULongArray3_swigregister(ULongArray3)

class ShortRealArray3(ShortRealArray):
    """
    Template class Array3 implements a dense three dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 3d-array implementation without
    error checking.

    C++ includes: Array3.h 
    """
    __swig_setmethods__ = {}
    for _s in [ShortRealArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShortRealArray3, name, value)
    __swig_getmethods__ = {}
    for _s in [ShortRealArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShortRealArray3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> ShortRealArray3
        __init__(self, dim1, dim2, dim3) -> ShortRealArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True, p_copy_array=False) -> ShortRealArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True) -> ShortRealArray3
        __init__(self, p_array, dim1, dim2, dim3) -> ShortRealArray3
        __init__(self, p_array, dim1, dim2, dim3) -> ShortRealArray3

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2

        dim3:  dimension 3 
        """
        this = _Library.new_ShortRealArray3(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_ShortRealArray3
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.ShortRealArray3_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2, dim3)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here

        dim3:  dimension 3 will be stored here 
        """
        return _Library.ShortRealArray3_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.ShortRealArray3_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.ShortRealArray3_get_dim2(*args)

    def get_dim3(*args):
        """
        get_dim3(self) ->  int

        get dimension 3

        dimension 3 
        """
        return _Library.ShortRealArray3_get_dim3(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.ShortRealArray3_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.ShortRealArray3_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> float

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.ShortRealArray3_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, dim3, p_free_array, copy_array=False)
        set_array(self, p_array, dim1, dim2, dim3, p_free_array)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        dim3:  dimensino 3

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.ShortRealArray3_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2, dim3) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        dim3:  new dimension 3

        if resizing was successful 
        """
        return _Library.ShortRealArray3_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2, idx3) -> float

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        array element at index 
        """
        return _Library.ShortRealArray3_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2, idx3) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        if setting was successful 
        """
        return _Library.ShortRealArray3_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2, idx3) -> float
        element(self, idx1, idx2, idx3) -> float
        element(self, p_array, idx1, idx2, idx3) -> float
        element(self, p_array, idx1, idx2, idx3, p_dim1_size, p_dim2_size) -> float

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        p_dim1_size:  size of dimension 1

        p_dim2_size:  size of dimension 2

        element of given array at given index 
        """
        return _Library.ShortRealArray3_element(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.ShortRealArray3_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.ShortRealArray3_display_array(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.ShortRealArray3_get_name(*args)

ShortRealArray3_swigregister = _Library.ShortRealArray3_swigregister
ShortRealArray3_swigregister(ShortRealArray3)

class RealArray3(RealArray):
    """
    Template class Array3 implements a dense three dimensional array.

    Note that depending on compile options everything will be inlined,
    such that this is as high performance 3d-array implementation without
    error checking.

    C++ includes: Array3.h 
    """
    __swig_setmethods__ = {}
    for _s in [RealArray]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RealArray3, name, value)
    __swig_getmethods__ = {}
    for _s in [RealArray]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RealArray3, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> RealArray3
        __init__(self, dim1, dim2, dim3) -> RealArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True, p_copy_array=False) -> RealArray3
        __init__(self, p_array, dim1, dim2, dim3, p_free_array=True) -> RealArray3
        __init__(self, p_array, dim1, dim2, dim3) -> RealArray3
        __init__(self, p_array, dim1, dim2, dim3) -> RealArray3

        constructor

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimension 2

        dim3:  dimension 3 
        """
        this = _Library.new_RealArray3(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_RealArray3
    __del__ = lambda self : None;
    def set_name(*args):
        """
        set_name(self, p_name)

        set array's name

        Parameters:
        -----------

        p_name:  new name 
        """
        return _Library.RealArray3_set_name(*args)

    def get_array_size(*args):
        """
        get_array_size(self, dim1, dim2, dim3)

        return total array size (including granularity buffer)

        Parameters:
        -----------

        dim1:  dimension 1 will be stored here

        dim2:  dimension 2 will be stored here

        dim3:  dimension 3 will be stored here 
        """
        return _Library.RealArray3_get_array_size(*args)

    def get_dim1(*args):
        """
        get_dim1(self) ->  int

        get dimension 1

        dimension 1 
        """
        return _Library.RealArray3_get_dim1(*args)

    def get_dim2(*args):
        """
        get_dim2(self) ->  int

        get dimension 2

        dimension 2 
        """
        return _Library.RealArray3_get_dim2(*args)

    def get_dim3(*args):
        """
        get_dim3(self) ->  int

        get dimension 3

        dimension 3 
        """
        return _Library.RealArray3_get_dim3(*args)

    def zero(*args):
        """
        zero(self)

        zero array 
        """
        return _Library.RealArray3_zero(*args)

    def set_const(*args):
        """
        set_const(self, const_elem)

        set array with a constant 
        """
        return _Library.RealArray3_set_const(*args)

    def get_array(*args):
        """
        get_array(self) -> float

        get the array call get_array just before messing with it DO NOT call
        any [],resize/delete functions after get_array(), the pointer may
        become invalid !

        the array 
        """
        return _Library.RealArray3_get_array(*args)

    def set_array(*args):
        """
        set_array(self, p_array, dim1, dim2, dim3, p_free_array, copy_array=False)
        set_array(self, p_array, dim1, dim2, dim3, p_free_array)

        set the array pointer and free previously allocated memory

        Parameters:
        -----------

        p_array:  another array

        dim1:  dimension 1

        dim2:  dimensino 2

        dim3:  dimensino 3

        p_free_array:  if array must be freed

        copy_array:  if array must be copied 
        """
        return _Library.RealArray3_set_array(*args)

    def resize_array(*args):
        """
        resize_array(self, dim1, dim2, dim3) -> bool

        resize array

        Parameters:
        -----------

        dim1:  new dimension 1

        dim2:  new dimension 2

        dim3:  new dimension 3

        if resizing was successful 
        """
        return _Library.RealArray3_resize_array(*args)

    def get_element(*args):
        """
        get_element(self, idx1, idx2, idx3) -> float

        get array element at index

        Parameters:
        -----------

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        array element at index 
        """
        return _Library.RealArray3_get_element(*args)

    def set_element(*args):
        """
        set_element(self, p_element, idx1, idx2, idx3) -> bool

        set array element at index 'index'

        Parameters:
        -----------

        p_element:  array element

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        if setting was successful 
        """
        return _Library.RealArray3_set_element(*args)

    def element(*args):
        """
        element(self, idx1, idx2, idx3) -> float
        element(self, idx1, idx2, idx3) -> float
        element(self, p_array, idx1, idx2, idx3) -> float
        element(self, p_array, idx1, idx2, idx3, p_dim1_size, p_dim2_size) -> float

        get element of given array at given index

        Parameters:
        -----------

        p_array:  another array

        idx1:  index 1

        idx2:  index 2

        idx3:  index 3

        p_dim1_size:  size of dimension 1

        p_dim2_size:  size of dimension 2

        element of given array at given index 
        """
        return _Library.RealArray3_element(*args)

    def display_size(*args):
        """
        display_size(self)

        display array size 
        """
        return _Library.RealArray3_display_size(*args)

    def display_array(*args):
        """
        display_array(self)

        display array 
        """
        return _Library.RealArray3_display_array(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _Library.RealArray3_get_name(*args)

RealArray3_swigregister = _Library.RealArray3_swigregister
RealArray3_swigregister(RealArray3)

class File(SGObject):
    """
    A File access class.

    A file consists of a fourcc header then an alternation of a type
    header and data or just raw data (simplefile=true). However this
    implementation is not complete - the more complex stuff is currently
    not implemented.

    C++ includes: File.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, File, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, File, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, f) -> File
        __init__(self, fname, rw, type, fourcc=None) -> File
        __init__(self, fname, rw, type) -> File

        constructor

        Parameters:
        -----------

        fname:  filename to open

        rw:  mode, 'r' or 'w'

        type:  specifies the datatype used in the file (F_INT,...)

        fourcc:  in the case fourcc is 0, type will be ignored and the file is
        treated as if it has a header/[typeheader,data]+ else the files header
        will be checked to contain the specified fourcc (e.g. 'RFEA') 
        """
        this = _Library.new_File(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_File
    __del__ = lambda self : None;
    def parse_first_header(*args):
        """
        parse_first_header(self, type) ->  int

        parse first header - defunct!

        Parameters:
        -----------

        type:  feature type

        -1 
        """
        return _Library.File_parse_first_header(*args)

    def parse_next_header(*args):
        """
        parse_next_header(self, type) ->  int

        parse next header - defunct!

        Parameters:
        -----------

        type:  feature type

        -1 
        """
        return _Library.File_parse_next_header(*args)

    def load_int_data(*args):
        """
        load_int_data(self, target, num) ->  int

        load integer data

        Parameters:
        -----------

        target:  loaded data

        num:  number of data elements

        loaded data 
        """
        return _Library.File_load_int_data(*args)

    def load_real_data(*args):
        """
        load_real_data(self, target, num) -> float

        load real data

        Parameters:
        -----------

        target:  loaded data

        num:  number of data elements

        loaded data 
        """
        return _Library.File_load_real_data(*args)

    def load_shortreal_data(*args):
        """
        load_shortreal_data(self, target, num) -> float

        load shortreal data

        Parameters:
        -----------

        target:  loaded data

        num:  number of data elements

        loaded data 
        """
        return _Library.File_load_shortreal_data(*args)

    def load_char_data(*args):
        """
        load_char_data(self, target, num) -> str

        load str data

        Parameters:
        -----------

        target:  loaded data

        num:  number of data elements

        loaded data 
        """
        return _Library.File_load_char_data(*args)

    def load_byte_data(*args):
        """
        load_byte_data(self, target, num) -> int

        load byte data

        Parameters:
        -----------

        target:  loaded data

        num:  number of data elements

        loaded data 
        """
        return _Library.File_load_byte_data(*args)

    def load_word_data(*args):
        """
        load_word_data(self, target, num) -> int

        load word data

        Parameters:
        -----------

        target:  loaded data

        num:  number of data elements

        loaded data 
        """
        return _Library.File_load_word_data(*args)

    def load_short_data(*args):
        """
        load_short_data(self, target, num) -> int

        load short data

        Parameters:
        -----------

        target:  loaded data

        num:  number of data elements

        loaded data 
        """
        return _Library.File_load_short_data(*args)

    def save_int_data(*args):
        """
        save_int_data(self, src, num) -> bool

        save integer data

        Parameters:
        -----------

        src:  data to save

        num:  number of data elements

        whether operation was successful 
        """
        return _Library.File_save_int_data(*args)

    def save_real_data(*args):
        """
        save_real_data(self, src, num) -> bool

        save real data

        Parameters:
        -----------

        src:  data to save

        num:  number of data elements

        whether operation was successful 
        """
        return _Library.File_save_real_data(*args)

    def save_shortreal_data(*args):
        """
        save_shortreal_data(self, src, num) -> bool

        save shortreal data

        Parameters:
        -----------

        src:  data to save

        num:  number of data elements

        whether operation was successful 
        """
        return _Library.File_save_shortreal_data(*args)

    def save_char_data(*args):
        """
        save_char_data(self, src, num) -> bool

        save str data

        Parameters:
        -----------

        src:  data to save

        num:  number of data elements

        whether operation was successful 
        """
        return _Library.File_save_char_data(*args)

    def save_byte_data(*args):
        """
        save_byte_data(self, src, num) -> bool

        save byte data

        Parameters:
        -----------

        src:  data to save

        num:  number of data elements

        whether operation was successful 
        """
        return _Library.File_save_byte_data(*args)

    def save_word_data(*args):
        """
        save_word_data(self, src, num) -> bool

        save word data

        Parameters:
        -----------

        src:  data to save

        num:  number of data elements

        whether operation was successful 
        """
        return _Library.File_save_word_data(*args)

    def save_short_data(*args):
        """
        save_short_data(self, src, num) -> bool

        save short data

        Parameters:
        -----------

        src:  data to save

        num:  number of data elements

        whether operation was successful 
        """
        return _Library.File_save_short_data(*args)

    def is_ok(*args):
        """
        is_ok(self) -> bool

        check if status is ok

        whether status is ok 
        """
        return _Library.File_is_ok(*args)

    def read_real_valued_sparse(*args):
        """
        read_real_valued_sparse(self, matrix, num_feat, num_vec) -> bool

        read sparse real valued features in svm light format e.g. -1 1:10.0
        2:100.2 1000:1.3 with -1 == (optional) label and dim 1 - value 10.0
        dim 2 - value 100.2 dim 1000 - value 1.3

        Parameters:
        -----------

        matrix:  matrix to read into

        num_feat:  number of features for each vector

        num_vec:  number of vectors in matrix

        if reading was successful 
        """
        return _Library.File_read_real_valued_sparse(*args)

    def write_real_valued_sparse(*args):
        """
        write_real_valued_sparse(self, matrix, num_feat, num_vec) -> bool

        write sparse real valued features in svm light format

        Parameters:
        -----------

        matrix:  matrix to write

        num_feat:  number of features for each vector

        num_vec:  number of vectros in matrix

        if writing was successful 
        """
        return _Library.File_write_real_valued_sparse(*args)

    def read_real_valued_dense(*args):
        """
        read_real_valued_dense(self, matrix, num_feat, num_vec) -> bool

        read dense real valued features, simple ascii format e.g. 1.0 1.1 0.2
        2.3 3.5 5

        a matrix that consists of 3 vectors with each of 2d

        Parameters:
        -----------

        matrix:  matrix to read into

        num_feat:  number of features for each vector

        num_vec:  number of vectors in matrix

        if reading was successful 
        """
        return _Library.File_read_real_valued_dense(*args)

    def write_real_valued_dense(*args):
        """
        write_real_valued_dense(self, matrix, num_feat, num_vec) -> bool

        write dense real valued features, simple ascii format

        Parameters:
        -----------

        matrix:  matrix to write

        num_feat:  number of features for each vector

        num_vec:  number of vectros in matrix

        if writing was successful 
        """
        return _Library.File_write_real_valued_dense(*args)

    def read_char_valued_strings(*args):
        """
        read_char_valued_strings(self, strings, num_str, max_string_len) -> bool

        read str string features, simple ascii format e.g. foo bar
        ACGTACGTATCT

        two strings

        Parameters:
        -----------

        strings:  strings to read into

        num_str:  number of strings

        max_string_len:  length of longest string

        if reading was successful 
        """
        return _Library.File_read_char_valued_strings(*args)

    def write_char_valued_strings(*args):
        """
        write_char_valued_strings(self, strings, num_str) -> bool

        write str string features, simple ascii format

        Parameters:
        -----------

        strings:  strings to write

        num_str:  number of strings

        if writing was successful 
        """
        return _Library.File_write_char_valued_strings(*args)

File_swigregister = _Library.File_swigregister
File_swigregister(File)

RNG_SEED_SIZE = _Library.RNG_SEED_SIZE
class Math(SGObject):
    """
    Class which collects generic mathematical functions.

    C++ includes: Mathematics.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Math, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Math, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Math

        Constructor - initializes log-table. 
        """
        this = _Library.new_Math(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_Math
    __del__ = lambda self : None;
    def round(*args):
        """round(d) -> float"""
        return _Library.Math_round(*args)

    if _newclass:round = staticmethod(round)
    __swig_getmethods__["round"] = lambda x: round
    def floor(*args):
        """floor(d) -> float"""
        return _Library.Math_floor(*args)

    if _newclass:floor = staticmethod(floor)
    __swig_getmethods__["floor"] = lambda x: floor
    def ceil(*args):
        """ceil(d) -> float"""
        return _Library.Math_ceil(*args)

    if _newclass:ceil = staticmethod(ceil)
    __swig_getmethods__["ceil"] = lambda x: ceil
    def sqrt(*args):
        """
        sqrt(x) -> float
        sqrt(x) -> float
        sqrt(x) -> floatmax_t

        x^0.5 
        """
        return _Library.Math_sqrt(*args)

    if _newclass:sqrt = staticmethod(sqrt)
    __swig_getmethods__["sqrt"] = lambda x: sqrt
    def powl(*args):
        """
        powl(x, n) -> floatmax_t

        x^n 
        """
        return _Library.Math_powl(*args)

    if _newclass:powl = staticmethod(powl)
    __swig_getmethods__["powl"] = lambda x: powl
    def pow(*args):
        """
        pow(x, n) ->  int
        pow(x, n) -> float
        pow(x, n) -> float
        """
        return _Library.Math_pow(*args)

    if _newclass:pow = staticmethod(pow)
    __swig_getmethods__["pow"] = lambda x: pow
    def exp(*args):
        """exp(x) -> float"""
        return _Library.Math_exp(*args)

    if _newclass:exp = staticmethod(exp)
    __swig_getmethods__["exp"] = lambda x: exp
    def log10(*args):
        """log10(v) -> float"""
        return _Library.Math_log10(*args)

    if _newclass:log10 = staticmethod(log10)
    __swig_getmethods__["log10"] = lambda x: log10
    def log2(*args):
        """log2(v) -> float"""
        return _Library.Math_log2(*args)

    if _newclass:log2 = staticmethod(log2)
    __swig_getmethods__["log2"] = lambda x: log2
    def log(*args):
        """log(v) -> float"""
        return _Library.Math_log(*args)

    if _newclass:log = staticmethod(log)
    __swig_getmethods__["log"] = lambda x: log
    def pinv(*args):
        """
        pinv(matrix, rows, cols, target=None) -> float
        pinv(matrix, rows, cols) -> float

        return the pseudo inverse for matrix when matrix has shape (rows,
        cols) the pseudo inverse has (cols, rows) 
        """
        return _Library.Math_pinv(*args)

    if _newclass:pinv = staticmethod(pinv)
    __swig_getmethods__["pinv"] = lambda x: pinv
    def dgemm(*args):
        """
        dgemm(alpha, A, rows, cols, transposeA, B, cols_B, transposeB, 
            beta, C)
        """
        return _Library.Math_dgemm(*args)

    if _newclass:dgemm = staticmethod(dgemm)
    __swig_getmethods__["dgemm"] = lambda x: dgemm
    def dgemv(*args):
        """dgemv(alpha, A, rows, cols, transposeA, X, beta, Y)"""
        return _Library.Math_dgemv(*args)

    if _newclass:dgemv = staticmethod(dgemv)
    __swig_getmethods__["dgemv"] = lambda x: dgemv
    def factorial(*args):
        """factorial(n) -> int"""
        return _Library.Math_factorial(*args)

    if _newclass:factorial = staticmethod(factorial)
    __swig_getmethods__["factorial"] = lambda x: factorial
    def init_random(*args):
        """
        init_random(initseed=0)
        init_random()
        """
        return _Library.Math_init_random(*args)

    if _newclass:init_random = staticmethod(init_random)
    __swig_getmethods__["init_random"] = lambda x: init_random
    def random(*args):
        """
        random() -> int
        random(min_value, max_value) ->  int
        random(min_value, max_value) -> float
        random(min_value, max_value) -> float
        """
        return _Library.Math_random(*args)

    if _newclass:random = staticmethod(random)
    __swig_getmethods__["random"] = lambda x: random
    def randperm(*args):
        """randperm(n) ->  int"""
        return _Library.Math_randperm(*args)

    if _newclass:randperm = staticmethod(randperm)
    __swig_getmethods__["randperm"] = lambda x: randperm
    def nchoosek(*args):
        """nchoosek(n, k) -> int"""
        return _Library.Math_nchoosek(*args)

    if _newclass:nchoosek = staticmethod(nchoosek)
    __swig_getmethods__["nchoosek"] = lambda x: nchoosek
    def dot(*args):
        """
        dot(v1, v2, n) -> float
        dot(v1, v2, n) -> floatmax_t
        dot(v1, v2, n) -> float
        dot(v1, v2, n) -> float
        dot(v1, v2, n) -> float
        dot(v1, v2, n) -> float
        dot(v1, v2, n) -> float
        dot(v1, v2, n) -> float
        dot(v1, v2, n) -> float
        dot(v1, v2, n) -> float
        dot(v1, v2, n) -> float
        dot(v1, v2, n) -> float
        dot(v1, v2, n) -> float

        compute dot product between v1 and v2 
        """
        return _Library.Math_dot(*args)

    if _newclass:dot = staticmethod(dot)
    __swig_getmethods__["dot"] = lambda x: dot
    def mean(*args):
        """mean(vec, len) -> float"""
        return _Library.Math_mean(*args)

    if _newclass:mean = staticmethod(mean)
    __swig_getmethods__["mean"] = lambda x: mean
    def trace(*args):
        """trace(mat, cols, rows) -> float"""
        return _Library.Math_trace(*args)

    if _newclass:trace = staticmethod(trace)
    __swig_getmethods__["trace"] = lambda x: trace
    def sort(*args):
        """
        sort(a, cols, sort_col=0)
        sort(a, cols)
        sort(a, idx, N)
        """
        return _Library.Math_sort(*args)

    if _newclass:sort = staticmethod(sort)
    __swig_getmethods__["sort"] = lambda x: sort
    def Align(*args):
        """
        Align(seq1, seq2, l1, l2, gapCost) -> float

        align two sequences seq1 & seq2 of length l1 and l2 using gapCost
        return alignment cost 
        """
        return _Library.Math_Align(*args)

    if _newclass:Align = staticmethod(Align)
    __swig_getmethods__["Align"] = lambda x: Align
    def calcroc(*args):
        """
        calcroc(fp, tp, output, label, size, possize, negsize, tresh, 
            rocfile) ->  int

        calculates ROC into (fp,tp) from output and label of length size
        returns index with smallest error=fp+fn 
        """
        return _Library.Math_calcroc(*args)

    if _newclass:calcroc = staticmethod(calcroc)
    __swig_getmethods__["calcroc"] = lambda x: calcroc
    def mutual_info(*args):
        """mutual_info(p1, p2, len) -> float"""
        return _Library.Math_mutual_info(*args)

    if _newclass:mutual_info = staticmethod(mutual_info)
    __swig_getmethods__["mutual_info"] = lambda x: mutual_info
    def relative_entropy(*args):
        """relative_entropy(p, q, len) -> float"""
        return _Library.Math_relative_entropy(*args)

    if _newclass:relative_entropy = staticmethod(relative_entropy)
    __swig_getmethods__["relative_entropy"] = lambda x: relative_entropy
    def entropy(*args):
        """entropy(p, len) -> float"""
        return _Library.Math_entropy(*args)

    if _newclass:entropy = staticmethod(entropy)
    __swig_getmethods__["entropy"] = lambda x: entropy
    def get_seed(*args):
        """get_seed() -> int"""
        return _Library.Math_get_seed(*args)

    if _newclass:get_seed = staticmethod(get_seed)
    __swig_getmethods__["get_seed"] = lambda x: get_seed
    def is_finite(*args):
        """is_finite(f) -> int"""
        return _Library.Math_is_finite(*args)

    if _newclass:is_finite = staticmethod(is_finite)
    __swig_getmethods__["is_finite"] = lambda x: is_finite
    def is_infinity(*args):
        """is_infinity(f) -> int"""
        return _Library.Math_is_infinity(*args)

    if _newclass:is_infinity = staticmethod(is_infinity)
    __swig_getmethods__["is_infinity"] = lambda x: is_infinity
    def is_nan(*args):
        """is_nan(f) -> int"""
        return _Library.Math_is_nan(*args)

    if _newclass:is_nan = staticmethod(is_nan)
    __swig_getmethods__["is_nan"] = lambda x: is_nan
    def logarithmic_sum(*args):
        """
        logarithmic_sum(p, q) -> float

        sum logarithmic probabilities. Probability measures are summed up but
        are now given in logspace where direct summation of exp(operand) is
        not possible due to numerical problems, i.e. eg. exp(-1000)=0.
        Therefore we do log( exp(a) + exp(b)) = a + log (1 + exp (b-a)) where
        a = max(p,q) and b min(p,q). 
        """
        return _Library.Math_logarithmic_sum(*args)

    if _newclass:logarithmic_sum = staticmethod(logarithmic_sum)
    __swig_getmethods__["logarithmic_sum"] = lambda x: logarithmic_sum
    __swig_setmethods__["LOGRANGE"] = _Library.Math_LOGRANGE_set
    __swig_getmethods__["LOGRANGE"] = _Library.Math_LOGRANGE_get
    if _newclass:LOGRANGE = _swig_property(_Library.Math_LOGRANGE_get, _Library.Math_LOGRANGE_set)
    __swig_setmethods__["seed"] = _Library.Math_seed_set
    __swig_getmethods__["seed"] = _Library.Math_seed_get
    if _newclass:seed = _swig_property(_Library.Math_seed_get, _Library.Math_seed_set)
    __swig_setmethods__["rand_state"] = _Library.Math_rand_state_set
    __swig_getmethods__["rand_state"] = _Library.Math_rand_state_get
    if _newclass:rand_state = _swig_property(_Library.Math_rand_state_get, _Library.Math_rand_state_set)
Math_swigregister = _Library.Math_swigregister
Math_swigregister(Math)

def Math_round(*args):
  """Math_round(d) -> float"""
  return _Library.Math_round(*args)

def Math_floor(*args):
  """Math_floor(d) -> float"""
  return _Library.Math_floor(*args)

def Math_ceil(*args):
  """Math_ceil(d) -> float"""
  return _Library.Math_ceil(*args)

def Math_sqrt(*args):
  """
    sqrt(x) -> float
    sqrt(x) -> float
    Math_sqrt(x) -> floatmax_t

    x^0.5 
    """
  return _Library.Math_sqrt(*args)

def Math_powl(*args):
  """
    Math_powl(x, n) -> floatmax_t

    x^n 
    """
  return _Library.Math_powl(*args)

def Math_pow(*args):
  """
    pow(x, n) ->  int
    pow(x, n) -> float
    Math_pow(x, n) -> float
    """
  return _Library.Math_pow(*args)

def Math_exp(*args):
  """Math_exp(x) -> float"""
  return _Library.Math_exp(*args)

def Math_log10(*args):
  """Math_log10(v) -> float"""
  return _Library.Math_log10(*args)

def Math_log2(*args):
  """Math_log2(v) -> float"""
  return _Library.Math_log2(*args)

def Math_log(*args):
  """Math_log(v) -> float"""
  return _Library.Math_log(*args)

def Math_pinv(*args):
  """
    pinv(matrix, rows, cols, target=None) -> float
    Math_pinv(matrix, rows, cols) -> float

    return the pseudo inverse for matrix when matrix has shape (rows,
    cols) the pseudo inverse has (cols, rows) 
    """
  return _Library.Math_pinv(*args)

def Math_dgemm(*args):
  """
    Math_dgemm(alpha, A, rows, cols, transposeA, B, cols_B, transposeB, 
        beta, C)
    """
  return _Library.Math_dgemm(*args)

def Math_dgemv(*args):
  """Math_dgemv(alpha, A, rows, cols, transposeA, X, beta, Y)"""
  return _Library.Math_dgemv(*args)

def Math_factorial(*args):
  """Math_factorial(n) -> int"""
  return _Library.Math_factorial(*args)

def Math_init_random(*args):
  """
    init_random(initseed=0)
    Math_init_random()
    """
  return _Library.Math_init_random(*args)

def Math_random(*args):
  """
    random() -> int
    random(min_value, max_value) ->  int
    random(min_value, max_value) -> float
    Math_random(min_value, max_value) -> float
    """
  return _Library.Math_random(*args)

def Math_randperm(*args):
  """Math_randperm(n) ->  int"""
  return _Library.Math_randperm(*args)

def Math_nchoosek(*args):
  """Math_nchoosek(n, k) -> int"""
  return _Library.Math_nchoosek(*args)

def Math_dot(*args):
  """
    dot(v1, v2, n) -> float
    dot(v1, v2, n) -> floatmax_t
    dot(v1, v2, n) -> float
    dot(v1, v2, n) -> float
    dot(v1, v2, n) -> float
    dot(v1, v2, n) -> float
    dot(v1, v2, n) -> float
    dot(v1, v2, n) -> float
    dot(v1, v2, n) -> float
    dot(v1, v2, n) -> float
    dot(v1, v2, n) -> float
    dot(v1, v2, n) -> float
    Math_dot(v1, v2, n) -> float

    compute dot product between v1 and v2 
    """
  return _Library.Math_dot(*args)

def Math_mean(*args):
  """Math_mean(vec, len) -> float"""
  return _Library.Math_mean(*args)

def Math_trace(*args):
  """Math_trace(mat, cols, rows) -> float"""
  return _Library.Math_trace(*args)

def Math_sort(*args):
  """
    sort(a, cols, sort_col=0)
    sort(a, cols)
    Math_sort(a, idx, N)
    """
  return _Library.Math_sort(*args)

def Math_Align(*args):
  """
    Math_Align(seq1, seq2, l1, l2, gapCost) -> float

    align two sequences seq1 & seq2 of length l1 and l2 using gapCost
    return alignment cost 
    """
  return _Library.Math_Align(*args)

def Math_calcroc(*args):
  """
    Math_calcroc(fp, tp, output, label, size, possize, negsize, tresh, 
        rocfile) ->  int

    calculates ROC into (fp,tp) from output and label of length size
    returns index with smallest error=fp+fn 
    """
  return _Library.Math_calcroc(*args)

def Math_mutual_info(*args):
  """Math_mutual_info(p1, p2, len) -> float"""
  return _Library.Math_mutual_info(*args)

def Math_relative_entropy(*args):
  """Math_relative_entropy(p, q, len) -> float"""
  return _Library.Math_relative_entropy(*args)

def Math_entropy(*args):
  """Math_entropy(p, len) -> float"""
  return _Library.Math_entropy(*args)

def Math_get_seed(*args):
  """Math_get_seed() -> int"""
  return _Library.Math_get_seed(*args)

def Math_is_finite(*args):
  """Math_is_finite(f) -> int"""
  return _Library.Math_is_finite(*args)

def Math_is_infinity(*args):
  """Math_is_infinity(f) -> int"""
  return _Library.Math_is_infinity(*args)

def Math_is_nan(*args):
  """Math_is_nan(f) -> int"""
  return _Library.Math_is_nan(*args)

def Math_logarithmic_sum(*args):
  """
    Math_logarithmic_sum(p, q) -> float

    sum logarithmic probabilities. Probability measures are summed up but
    are now given in logspace where direct summation of exp(operand) is
    not possible due to numerical problems, i.e. eg. exp(-1000)=0.
    Therefore we do log( exp(a) + exp(b)) = a + log (1 + exp (b-a)) where
    a = max(p,q) and b min(p,q). 
    """
  return _Library.Math_logarithmic_sum(*args)
Math.INFTY = _Library.cvar.Math_INFTY
Math.ALMOST_INFTY = _Library.cvar.Math_ALMOST_INFTY
Math.ALMOST_NEG_INFTY = _Library.cvar.Math_ALMOST_NEG_INFTY

class Signal(SGObject):
    """
    Class Signal implements signal handling to e.g. allow ctrl+c to cancel
    a long running process.

    This is done in two ways:

    A signal handler is attached to trap the SIGINT and SIGURG signal.
    Pressing ctrl+c or sending the SIGINT (kill ...) signal to the shogun
    process will make shogun print a message asking to immediately exit
    the running method and to fall back to the command line.

    When an URG signal is received or ctrl+c P is pressed shogun will
    prematurely stop a method and continue execution. For example when an
    SVM solver takes a long time without progressing much, one might still
    be interested in the result and should thus send SIGURG or
    interactively prematurely stop the method

    C++ includes: Signal.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Signal, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Signal, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Signal

        default constructor 
        """
        this = _Library.new_Signal(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_Signal
    __del__ = lambda self : None;
    def handler(*args):
        """handler(signal)"""
        return _Library.Signal_handler(*args)

    if _newclass:handler = staticmethod(handler)
    __swig_getmethods__["handler"] = lambda x: handler
    def set_handler(*args):
        """set_handler() -> bool"""
        return _Library.Signal_set_handler(*args)

    if _newclass:set_handler = staticmethod(set_handler)
    __swig_getmethods__["set_handler"] = lambda x: set_handler
    def unset_handler(*args):
        """unset_handler() -> bool"""
        return _Library.Signal_unset_handler(*args)

    if _newclass:unset_handler = staticmethod(unset_handler)
    __swig_getmethods__["unset_handler"] = lambda x: unset_handler
    def clear(*args):
        """clear()"""
        return _Library.Signal_clear(*args)

    if _newclass:clear = staticmethod(clear)
    __swig_getmethods__["clear"] = lambda x: clear
    def clear_cancel(*args):
        """clear_cancel()"""
        return _Library.Signal_clear_cancel(*args)

    if _newclass:clear_cancel = staticmethod(clear_cancel)
    __swig_getmethods__["clear_cancel"] = lambda x: clear_cancel
    def set_cancel(*args):
        """
        set_cancel(immediately=False)
        set_cancel()
        """
        return _Library.Signal_set_cancel(*args)

    if _newclass:set_cancel = staticmethod(set_cancel)
    __swig_getmethods__["set_cancel"] = lambda x: set_cancel
    def cancel_computations(*args):
        """cancel_computations() -> bool"""
        return _Library.Signal_cancel_computations(*args)

    if _newclass:cancel_computations = staticmethod(cancel_computations)
    __swig_getmethods__["cancel_computations"] = lambda x: cancel_computations
Signal_swigregister = _Library.Signal_swigregister
Signal_swigregister(Signal)

def Signal_handler(*args):
  """Signal_handler(signal)"""
  return _Library.Signal_handler(*args)

def Signal_set_handler(*args):
  """Signal_set_handler() -> bool"""
  return _Library.Signal_set_handler(*args)

def Signal_unset_handler(*args):
  """Signal_unset_handler() -> bool"""
  return _Library.Signal_unset_handler(*args)

def Signal_clear(*args):
  """Signal_clear()"""
  return _Library.Signal_clear(*args)

def Signal_clear_cancel(*args):
  """Signal_clear_cancel()"""
  return _Library.Signal_clear_cancel(*args)

def Signal_set_cancel(*args):
  """
    set_cancel(immediately=False)
    Signal_set_cancel()
    """
  return _Library.Signal_set_cancel(*args)

def Signal_cancel_computations(*args):
  """Signal_cancel_computations() -> bool"""
  return _Library.Signal_cancel_computations(*args)

class Time(SGObject):
    """
    Class Time that implements a stopwatch based on either cpu time or
    wall clock time.

    C++ includes: Time.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Time, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Time, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, start=True) -> Time
        __init__(self) -> Time

        constructor

        Parameters:
        -----------

        start:  if time measurement shall be started 
        """
        this = _Library.new_Time(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_Time
    __del__ = lambda self : None;
    def cur_runtime(*args):
        """
        cur_runtime(self, verbose=False) -> clock_t
        cur_runtime(self) -> clock_t

        get current cpu runtime

        Parameters:
        -----------

        verbose:  if time shall be printed

        current cpu runtime 
        """
        return _Library.Time_cur_runtime(*args)

    def cur_runtime_diff(*args):
        """
        cur_runtime_diff(self, verbose=False) -> clock_t
        cur_runtime_diff(self) -> clock_t

        get time difference between start and NOW

        Parameters:
        -----------

        verbose:  if time difference shall be printed

        time difference between start and NOW 
        """
        return _Library.Time_cur_runtime_diff(*args)

    def cur_runtime_diff_sec(*args):
        """
        cur_runtime_diff_sec(self, verbose=False) -> float
        cur_runtime_diff_sec(self) -> float

        get time difference between start and NOW in seconds

        Parameters:
        -----------

        verbose:  if time difference shall be printed

        time difference between start and NOW in seconds 
        """
        return _Library.Time_cur_runtime_diff_sec(*args)

    def start(*args):
        """
        start(self, verbose=False) -> float
        start(self) -> float

        start the counter

        Parameters:
        -----------

        verbose:  if start time shall be printed

        start time in seconds 
        """
        return _Library.Time_start(*args)

    def cur_time_diff(*args):
        """
        cur_time_diff(self, verbose=False) -> float
        cur_time_diff(self) -> float

        get time difference between start and NOW in seconds

        Parameters:
        -----------

        verbose:  if time difference shall be printed

        time difference between start and NOW in seconds 
        """
        return _Library.Time_cur_time_diff(*args)

    def time_diff_sec(*args):
        """
        time_diff_sec(self, verbose=False) -> float
        time_diff_sec(self) -> float

        get time difference between start and stop in seconds

        Parameters:
        -----------

        verbose:  if time difference shall be printed

        time difference between start and stop in seconds 
        """
        return _Library.Time_time_diff_sec(*args)

    def stop(*args):
        """
        stop(self, verbose=False) -> float
        stop(self) -> float

        stop the counter

        Parameters:
        -----------

        verbose:  if stop time shall be printed

        stop time in seconds 
        """
        return _Library.Time_stop(*args)

    def get_runtime(*args):
        """get_runtime() -> int"""
        return _Library.Time_get_runtime(*args)

    if _newclass:get_runtime = staticmethod(get_runtime)
    __swig_getmethods__["get_runtime"] = lambda x: get_runtime
    def get_curtime(*args):
        """get_curtime() -> float"""
        return _Library.Time_get_curtime(*args)

    if _newclass:get_curtime = staticmethod(get_curtime)
    __swig_getmethods__["get_curtime"] = lambda x: get_curtime
Time_swigregister = _Library.Time_swigregister
Time_swigregister(Time)

def Time_get_runtime(*args):
  """Time_get_runtime() -> int"""
  return _Library.Time_get_runtime(*args)

def Time_get_curtime(*args):
  """Time_get_curtime() -> float"""
  return _Library.Time_get_curtime(*args)

class ConsensusEntry(_object):
    """
    consensus entry

    C++ includes: Trie.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConsensusEntry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ConsensusEntry, name)
    __repr__ = _swig_repr
    __swig_setmethods__["string"] = _Library.ConsensusEntry_string_set
    __swig_getmethods__["string"] = _Library.ConsensusEntry_string_get
    if _newclass:string = _swig_property(_Library.ConsensusEntry_string_get, _Library.ConsensusEntry_string_set)
    __swig_setmethods__["score"] = _Library.ConsensusEntry_score_set
    __swig_getmethods__["score"] = _Library.ConsensusEntry_score_get
    if _newclass:score = _swig_property(_Library.ConsensusEntry_score_get, _Library.ConsensusEntry_score_set)
    __swig_setmethods__["bt"] = _Library.ConsensusEntry_bt_set
    __swig_getmethods__["bt"] = _Library.ConsensusEntry_bt_get
    if _newclass:bt = _swig_property(_Library.ConsensusEntry_bt_get, _Library.ConsensusEntry_bt_set)
    def __init__(self, *args): 
        """__init__(self) -> ConsensusEntry"""
        this = _Library.new_ConsensusEntry(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_ConsensusEntry
    __del__ = lambda self : None;
ConsensusEntry_swigregister = _Library.ConsensusEntry_swigregister
ConsensusEntry_swigregister(ConsensusEntry)

class POIMTrie(_object):
    """
    POIM trie

    C++ includes: Trie.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, POIMTrie, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, POIMTrie, name)
    __repr__ = _swig_repr
    __swig_setmethods__["weight"] = _Library.POIMTrie_weight_set
    __swig_getmethods__["weight"] = _Library.POIMTrie_weight_get
    if _newclass:weight = _swig_property(_Library.POIMTrie_weight_get, _Library.POIMTrie_weight_set)
    __swig_setmethods__["S"] = _Library.POIMTrie_S_set
    __swig_getmethods__["S"] = _Library.POIMTrie_S_get
    if _newclass:S = _swig_property(_Library.POIMTrie_S_get, _Library.POIMTrie_S_set)
    __swig_setmethods__["L"] = _Library.POIMTrie_L_set
    __swig_getmethods__["L"] = _Library.POIMTrie_L_get
    if _newclass:L = _swig_property(_Library.POIMTrie_L_get, _Library.POIMTrie_L_set)
    __swig_setmethods__["R"] = _Library.POIMTrie_R_set
    __swig_getmethods__["R"] = _Library.POIMTrie_R_get
    if _newclass:R = _swig_property(_Library.POIMTrie_R_get, _Library.POIMTrie_R_set)
    def __init__(self, *args): 
        """__init__(self) -> POIMTrie"""
        this = _Library.new_POIMTrie(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_POIMTrie
    __del__ = lambda self : None;
POIMTrie_swigregister = _Library.POIMTrie_swigregister
POIMTrie_swigregister(POIMTrie)

class DNATrie(_object):
    """
    DNA trie

    C++ includes: Trie.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DNATrie, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DNATrie, name)
    __repr__ = _swig_repr
    __swig_setmethods__["weight"] = _Library.DNATrie_weight_set
    __swig_getmethods__["weight"] = _Library.DNATrie_weight_get
    if _newclass:weight = _swig_property(_Library.DNATrie_weight_get, _Library.DNATrie_weight_set)
    def __init__(self, *args): 
        """__init__(self) -> DNATrie"""
        this = _Library.new_DNATrie(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_DNATrie
    __del__ = lambda self : None;
DNATrie_swigregister = _Library.DNATrie_swigregister
DNATrie_swigregister(DNATrie)

class TreeParseInfo(_object):
    """
    tree parse info

    C++ includes: Trie.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TreeParseInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TreeParseInfo, name)
    __repr__ = _swig_repr
    __swig_setmethods__["num_sym"] = _Library.TreeParseInfo_num_sym_set
    __swig_getmethods__["num_sym"] = _Library.TreeParseInfo_num_sym_get
    if _newclass:num_sym = _swig_property(_Library.TreeParseInfo_num_sym_get, _Library.TreeParseInfo_num_sym_set)
    __swig_setmethods__["num_feat"] = _Library.TreeParseInfo_num_feat_set
    __swig_getmethods__["num_feat"] = _Library.TreeParseInfo_num_feat_get
    if _newclass:num_feat = _swig_property(_Library.TreeParseInfo_num_feat_get, _Library.TreeParseInfo_num_feat_set)
    __swig_setmethods__["p"] = _Library.TreeParseInfo_p_set
    __swig_getmethods__["p"] = _Library.TreeParseInfo_p_get
    if _newclass:p = _swig_property(_Library.TreeParseInfo_p_get, _Library.TreeParseInfo_p_set)
    __swig_setmethods__["k"] = _Library.TreeParseInfo_k_set
    __swig_getmethods__["k"] = _Library.TreeParseInfo_k_get
    if _newclass:k = _swig_property(_Library.TreeParseInfo_k_get, _Library.TreeParseInfo_k_set)
    __swig_setmethods__["nofsKmers"] = _Library.TreeParseInfo_nofsKmers_set
    __swig_getmethods__["nofsKmers"] = _Library.TreeParseInfo_nofsKmers_get
    if _newclass:nofsKmers = _swig_property(_Library.TreeParseInfo_nofsKmers_get, _Library.TreeParseInfo_nofsKmers_set)
    __swig_setmethods__["margFactors"] = _Library.TreeParseInfo_margFactors_set
    __swig_getmethods__["margFactors"] = _Library.TreeParseInfo_margFactors_get
    if _newclass:margFactors = _swig_property(_Library.TreeParseInfo_margFactors_get, _Library.TreeParseInfo_margFactors_set)
    __swig_setmethods__["x"] = _Library.TreeParseInfo_x_set
    __swig_getmethods__["x"] = _Library.TreeParseInfo_x_get
    if _newclass:x = _swig_property(_Library.TreeParseInfo_x_get, _Library.TreeParseInfo_x_set)
    __swig_setmethods__["substrs"] = _Library.TreeParseInfo_substrs_set
    __swig_getmethods__["substrs"] = _Library.TreeParseInfo_substrs_get
    if _newclass:substrs = _swig_property(_Library.TreeParseInfo_substrs_get, _Library.TreeParseInfo_substrs_set)
    __swig_setmethods__["y0"] = _Library.TreeParseInfo_y0_set
    __swig_getmethods__["y0"] = _Library.TreeParseInfo_y0_get
    if _newclass:y0 = _swig_property(_Library.TreeParseInfo_y0_get, _Library.TreeParseInfo_y0_set)
    __swig_setmethods__["C_k"] = _Library.TreeParseInfo_C_k_set
    __swig_getmethods__["C_k"] = _Library.TreeParseInfo_C_k_get
    if _newclass:C_k = _swig_property(_Library.TreeParseInfo_C_k_get, _Library.TreeParseInfo_C_k_set)
    __swig_setmethods__["L_k"] = _Library.TreeParseInfo_L_k_set
    __swig_getmethods__["L_k"] = _Library.TreeParseInfo_L_k_get
    if _newclass:L_k = _swig_property(_Library.TreeParseInfo_L_k_get, _Library.TreeParseInfo_L_k_set)
    __swig_setmethods__["R_k"] = _Library.TreeParseInfo_R_k_set
    __swig_getmethods__["R_k"] = _Library.TreeParseInfo_R_k_get
    if _newclass:R_k = _swig_property(_Library.TreeParseInfo_R_k_get, _Library.TreeParseInfo_R_k_set)
    def __init__(self, *args): 
        """__init__(self) -> TreeParseInfo"""
        this = _Library.new_TreeParseInfo(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_TreeParseInfo
    __del__ = lambda self : None;
TreeParseInfo_swigregister = _Library.TreeParseInfo_swigregister
TreeParseInfo_swigregister(TreeParseInfo)

UNCOMPRESSED = _Library.UNCOMPRESSED
LZO = _Library.LZO
GZIP = _Library.GZIP
BZIP2 = _Library.BZIP2
LZMA = _Library.LZMA
class CCompressor(SGObject):
    """
    Compression library for compressing and decompressing buffers using
    one of the standard compression algorithms, LZO, GZIP, BZIP2 or LZMA.

    The general recommendation is to use LZO whenever lightweight
    compression is sufficient but high i/o throughputs are needed (at 1/2
    the speed of memcpy).

    If size is all that matters use LZMA (which especially when
    compressing can be very slow though).

    Note that besides lzo compression, this library is thread safe.

    C++ includes: Compressor.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CCompressor, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CCompressor, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ct) -> CCompressor

        default constructor

        Parameters:
        -----------

        ct:  compression to use: one of UNCOMPRESSED, LZO, GZIP, BZIP2 or LZMA

        """
        this = _Library.new_CCompressor(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Library.delete_CCompressor
    __del__ = lambda self : None;
    def compress(*args):
        """
        compress(self, uncompressed, uncompressed_size, compressed, compressed_size, 
            level=1)
        compress(self, uncompressed, uncompressed_size, compressed, compressed_size)

        compress data

        compresses the buffer uncompressed using the selected compression
        algorithm and returns compressed data and its size

        Parameters:
        -----------

        uncompressed:  - uncompressed data to be compressed

        uncompressed_size:  - size of the uncompressed data

        compressed:  - pointer to hold compressed data (returned)

        compressed_size:  - size of compressed data (returned)

        level:  - compression level between 1 and 9 
        """
        return _Library.CCompressor_compress(*args)

    def decompress(*args):
        """
        decompress(self, compressed, compressed_size, uncompressed, uncompressed_size)

        decompress data

        Decompresses the buffer using the selected compression algorithm to
        the memory block specified in uncompressed. Note: Compressed and
        uncompressed size must be known prior to calling this function.

        Parameters:
        -----------

        compressed:  - pointer to compressed data

        compressed_size:  - size of compressed data

        uncompressed:  - pointer to buffer to hold uncompressed data

        uncompressed_size:  - size of the uncompressed data 
        """
        return _Library.CCompressor_decompress(*args)

CCompressor_swigregister = _Library.CCompressor_swigregister
CCompressor_swigregister(CCompressor)



