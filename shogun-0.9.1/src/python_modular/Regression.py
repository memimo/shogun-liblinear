# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.
# This file is compatible with both classic and new-style classes.

"""
The `Regression` module gathers all regression methods available in the SHOGUN toolkit.
"""

import _Regression
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types


class ShogunException(_object):
    """Proxy of C++ ShogunException class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShogunException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ShogunException, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, str) -> ShogunException"""
        this = _Regression.new_ShogunException(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Regression.delete_ShogunException
    __del__ = lambda self : None;
    def get_exception_string(*args):
        """get_exception_string(self) -> str"""
        return _Regression.ShogunException_get_exception_string(*args)

ShogunException_swigregister = _Regression.ShogunException_swigregister
ShogunException_swigregister(ShogunException)

MSG_GCDEBUG = _Regression.MSG_GCDEBUG
MSG_DEBUG = _Regression.MSG_DEBUG
MSG_INFO = _Regression.MSG_INFO
MSG_NOTICE = _Regression.MSG_NOTICE
MSG_WARN = _Regression.MSG_WARN
MSG_ERROR = _Regression.MSG_ERROR
MSG_CRITICAL = _Regression.MSG_CRITICAL
MSG_ALERT = _Regression.MSG_ALERT
MSG_EMERGENCY = _Regression.MSG_EMERGENCY
MSG_MESSAGEONLY = _Regression.MSG_MESSAGEONLY
class IO(_object):
    """Proxy of C++ IO class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IO, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IO, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IO
        __init__(self, orig) -> IO
        """
        this = _Regression.new_IO(*args)
        try: self.this.append(this)
        except: self.this = this
    def set_loglevel(*args):
        """set_loglevel(self, level)"""
        return _Regression.IO_set_loglevel(*args)

    def get_loglevel(*args):
        """get_loglevel(self) -> EMessageType"""
        return _Regression.IO_get_loglevel(*args)

    def get_show_progress(*args):
        """get_show_progress(self) -> bool"""
        return _Regression.IO_get_show_progress(*args)

    def get_show_file_and_line(*args):
        """get_show_file_and_line(self) -> bool"""
        return _Regression.IO_get_show_file_and_line(*args)

    def message(*args):
        """message(self, prio, file, line, fmt, ?)"""
        return _Regression.IO_message(*args)

    def progress(*args):
        """
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1)
        progress(self, current_val, min_val=0.0, max_val=1.0)
        progress(self, current_val, min_val=0.0)
        progress(self, current_val)
        """
        return _Regression.IO_progress(*args)

    def absolute_progress(*args):
        """
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1)
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0)
        absolute_progress(self, current_val, val, min_val=0.0)
        absolute_progress(self, current_val, val)
        """
        return _Regression.IO_absolute_progress(*args)

    def done(*args):
        """done(self)"""
        return _Regression.IO_done(*args)

    def not_implemented(*args):
        """not_implemented(self, file, line)"""
        return _Regression.IO_not_implemented(*args)

    def deprecated(*args):
        """deprecated(self, file, line)"""
        return _Regression.IO_deprecated(*args)

    def buffered_message(*args):
        """buffered_message(self, prio, fmt, ?)"""
        return _Regression.IO_buffered_message(*args)

    def skip_spaces(*args):
        """skip_spaces(str) -> str"""
        return _Regression.IO_skip_spaces(*args)

    if _newclass:skip_spaces = staticmethod(skip_spaces)
    __swig_getmethods__["skip_spaces"] = lambda x: skip_spaces
    def skip_blanks(*args):
        """skip_blanks(str) -> str"""
        return _Regression.IO_skip_blanks(*args)

    if _newclass:skip_blanks = staticmethod(skip_blanks)
    __swig_getmethods__["skip_blanks"] = lambda x: skip_blanks
    def get_target(*args):
        """get_target(self) -> FILE"""
        return _Regression.IO_get_target(*args)

    def set_target(*args):
        """set_target(self, target)"""
        return _Regression.IO_set_target(*args)

    def set_target_to_stderr(*args):
        """set_target_to_stderr(self)"""
        return _Regression.IO_set_target_to_stderr(*args)

    def set_target_to_stdout(*args):
        """set_target_to_stdout(self)"""
        return _Regression.IO_set_target_to_stdout(*args)

    def enable_progress(*args):
        """enable_progress(self)"""
        return _Regression.IO_enable_progress(*args)

    def disable_progress(*args):
        """disable_progress(self)"""
        return _Regression.IO_disable_progress(*args)

    def enable_file_and_line(*args):
        """enable_file_and_line(self)"""
        return _Regression.IO_enable_file_and_line(*args)

    def disable_file_and_line(*args):
        """disable_file_and_line(self)"""
        return _Regression.IO_disable_file_and_line(*args)

    def set_dirname(*args):
        """set_dirname(dirname)"""
        return _Regression.IO_set_dirname(*args)

    if _newclass:set_dirname = staticmethod(set_dirname)
    __swig_getmethods__["set_dirname"] = lambda x: set_dirname
    def concat_filename(*args):
        """concat_filename(filename) -> str"""
        return _Regression.IO_concat_filename(*args)

    if _newclass:concat_filename = staticmethod(concat_filename)
    __swig_getmethods__["concat_filename"] = lambda x: concat_filename
    def filter(*args):
        """filter(d) -> int"""
        return _Regression.IO_filter(*args)

    if _newclass:filter = staticmethod(filter)
    __swig_getmethods__["filter"] = lambda x: filter
    def ref(*args):
        """ref(self) ->  int"""
        return _Regression.IO_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Regression.IO_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Regression.IO_unref(*args)

    def get_name(*args):
        """get_name(self) -> str"""
        return _Regression.IO_get_name(*args)

    __swig_destroy__ = _Regression.delete_IO
    __del__ = lambda self : None;
IO_swigregister = _Regression.IO_swigregister
IO_swigregister(IO)
cvar = _Regression.cvar

def IO_skip_spaces(*args):
  """IO_skip_spaces(str) -> str"""
  return _Regression.IO_skip_spaces(*args)

def IO_skip_blanks(*args):
  """IO_skip_blanks(str) -> str"""
  return _Regression.IO_skip_blanks(*args)

def IO_set_dirname(*args):
  """IO_set_dirname(dirname)"""
  return _Regression.IO_set_dirname(*args)

def IO_concat_filename(*args):
  """IO_concat_filename(filename) -> str"""
  return _Regression.IO_concat_filename(*args)

def IO_filter(*args):
  """IO_filter(d) -> int"""
  return _Regression.IO_filter(*args)

class SGObject(_object):
    """Proxy of C++ SGObject class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SGObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SGObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Regression.delete_SGObject
    __del__ = lambda self : None;
    def ref(*args):
        """ref(self) ->  int"""
        return _Regression.SGObject_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Regression.SGObject_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Regression.SGObject_unref(*args)

    def get_name(*args):
        """get_name(self) -> str"""
        return _Regression.SGObject_get_name(*args)

    __swig_setmethods__["io"] = _Regression.SGObject_io_set
    __swig_getmethods__["io"] = _Regression.SGObject_io_get
    if _newclass:io = _swig_property(_Regression.SGObject_io_get, _Regression.SGObject_io_set)
    __swig_setmethods__["parallel"] = _Regression.SGObject_parallel_set
    __swig_getmethods__["parallel"] = _Regression.SGObject_parallel_get
    if _newclass:parallel = _swig_property(_Regression.SGObject_parallel_get, _Regression.SGObject_parallel_set)
    __swig_setmethods__["version"] = _Regression.SGObject_version_set
    __swig_getmethods__["version"] = _Regression.SGObject_version_get
    if _newclass:version = _swig_property(_Regression.SGObject_version_get, _Regression.SGObject_version_set)
SGObject_swigregister = _Regression.SGObject_swigregister
SGObject_swigregister(SGObject)

class Version(_object):
    """Proxy of C++ Version class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Version, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Version, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self) -> Version"""
        this = _Regression.new_Version(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Regression.delete_Version
    __del__ = lambda self : None;
    def print_version(*args):
        """print_version()"""
        return _Regression.Version_print_version(*args)

    if _newclass:print_version = staticmethod(print_version)
    __swig_getmethods__["print_version"] = lambda x: print_version
    def get_version_extra(*args):
        """get_version_extra() -> str"""
        return _Regression.Version_get_version_extra(*args)

    if _newclass:get_version_extra = staticmethod(get_version_extra)
    __swig_getmethods__["get_version_extra"] = lambda x: get_version_extra
    def get_version_release(*args):
        """get_version_release() -> str"""
        return _Regression.Version_get_version_release(*args)

    if _newclass:get_version_release = staticmethod(get_version_release)
    __swig_getmethods__["get_version_release"] = lambda x: get_version_release
    def get_version_revision(*args):
        """get_version_revision() ->  int"""
        return _Regression.Version_get_version_revision(*args)

    if _newclass:get_version_revision = staticmethod(get_version_revision)
    __swig_getmethods__["get_version_revision"] = lambda x: get_version_revision
    def get_version_year(*args):
        """get_version_year() ->  int"""
        return _Regression.Version_get_version_year(*args)

    if _newclass:get_version_year = staticmethod(get_version_year)
    __swig_getmethods__["get_version_year"] = lambda x: get_version_year
    def get_version_month(*args):
        """get_version_month() ->  int"""
        return _Regression.Version_get_version_month(*args)

    if _newclass:get_version_month = staticmethod(get_version_month)
    __swig_getmethods__["get_version_month"] = lambda x: get_version_month
    def get_version_day(*args):
        """get_version_day() ->  int"""
        return _Regression.Version_get_version_day(*args)

    if _newclass:get_version_day = staticmethod(get_version_day)
    __swig_getmethods__["get_version_day"] = lambda x: get_version_day
    def get_version_hour(*args):
        """get_version_hour() ->  int"""
        return _Regression.Version_get_version_hour(*args)

    if _newclass:get_version_hour = staticmethod(get_version_hour)
    __swig_getmethods__["get_version_hour"] = lambda x: get_version_hour
    def get_version_minute(*args):
        """get_version_minute() ->  int"""
        return _Regression.Version_get_version_minute(*args)

    if _newclass:get_version_minute = staticmethod(get_version_minute)
    __swig_getmethods__["get_version_minute"] = lambda x: get_version_minute
    def get_version_in_minutes(*args):
        """get_version_in_minutes() -> int"""
        return _Regression.Version_get_version_in_minutes(*args)

    if _newclass:get_version_in_minutes = staticmethod(get_version_in_minutes)
    __swig_getmethods__["get_version_in_minutes"] = lambda x: get_version_in_minutes
    def ref(*args):
        """ref(self) ->  int"""
        return _Regression.Version_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Regression.Version_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Regression.Version_unref(*args)

Version_swigregister = _Regression.Version_swigregister
Version_swigregister(Version)

def Version_print_version(*args):
  """Version_print_version()"""
  return _Regression.Version_print_version(*args)

def Version_get_version_extra(*args):
  """Version_get_version_extra() -> str"""
  return _Regression.Version_get_version_extra(*args)

def Version_get_version_release(*args):
  """Version_get_version_release() -> str"""
  return _Regression.Version_get_version_release(*args)

def Version_get_version_revision(*args):
  """Version_get_version_revision() ->  int"""
  return _Regression.Version_get_version_revision(*args)

def Version_get_version_year(*args):
  """Version_get_version_year() ->  int"""
  return _Regression.Version_get_version_year(*args)

def Version_get_version_month(*args):
  """Version_get_version_month() ->  int"""
  return _Regression.Version_get_version_month(*args)

def Version_get_version_day(*args):
  """Version_get_version_day() ->  int"""
  return _Regression.Version_get_version_day(*args)

def Version_get_version_hour(*args):
  """Version_get_version_hour() ->  int"""
  return _Regression.Version_get_version_hour(*args)

def Version_get_version_minute(*args):
  """Version_get_version_minute() ->  int"""
  return _Regression.Version_get_version_minute(*args)

def Version_get_version_in_minutes(*args):
  """Version_get_version_in_minutes() -> int"""
  return _Regression.Version_get_version_in_minutes(*args)

class Parallel(_object):
    """Proxy of C++ Parallel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parallel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Parallel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Parallel
        __init__(self, orig) -> Parallel
        """
        this = _Regression.new_Parallel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Regression.delete_Parallel
    __del__ = lambda self : None;
    def get_num_cpus(*args):
        """get_num_cpus(self) ->  int"""
        return _Regression.Parallel_get_num_cpus(*args)

    def set_num_threads(*args):
        """set_num_threads(self, n)"""
        return _Regression.Parallel_set_num_threads(*args)

    def get_num_threads(*args):
        """get_num_threads(self) ->  int"""
        return _Regression.Parallel_get_num_threads(*args)

    def ref(*args):
        """ref(self) ->  int"""
        return _Regression.Parallel_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Regression.Parallel_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Regression.Parallel_unref(*args)

Parallel_swigregister = _Regression.Parallel_swigregister
Parallel_swigregister(Parallel)

class PySwigIterator(_object):
    """Proxy of C++ PySwigIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Regression.delete_PySwigIterator
    __del__ = lambda self : None;
    def value(*args):
        """value(self) -> PyObject"""
        return _Regression.PySwigIterator_value(*args)

    def incr(*args):
        """
        incr(self, n=1) -> PySwigIterator
        incr(self) -> PySwigIterator
        """
        return _Regression.PySwigIterator_incr(*args)

    def decr(*args):
        """
        decr(self, n=1) -> PySwigIterator
        decr(self) -> PySwigIterator
        """
        return _Regression.PySwigIterator_decr(*args)

    def distance(*args):
        """distance(self, x) -> ptrdiff_t"""
        return _Regression.PySwigIterator_distance(*args)

    def equal(*args):
        """equal(self, x) -> bool"""
        return _Regression.PySwigIterator_equal(*args)

    def copy(*args):
        """copy(self) -> PySwigIterator"""
        return _Regression.PySwigIterator_copy(*args)

    def next(*args):
        """next(self) -> PyObject"""
        return _Regression.PySwigIterator_next(*args)

    def previous(*args):
        """previous(self) -> PyObject"""
        return _Regression.PySwigIterator_previous(*args)

    def advance(*args):
        """advance(self, n) -> PySwigIterator"""
        return _Regression.PySwigIterator_advance(*args)

    def __eq__(*args):
        """__eq__(self, x) -> bool"""
        return _Regression.PySwigIterator___eq__(*args)

    def __ne__(*args):
        """__ne__(self, x) -> bool"""
        return _Regression.PySwigIterator___ne__(*args)

    def __iadd__(*args):
        """__iadd__(self, n) -> PySwigIterator"""
        return _Regression.PySwigIterator___iadd__(*args)

    def __isub__(*args):
        """__isub__(self, n) -> PySwigIterator"""
        return _Regression.PySwigIterator___isub__(*args)

    def __add__(*args):
        """__add__(self, n) -> PySwigIterator"""
        return _Regression.PySwigIterator___add__(*args)

    def __sub__(*args):
        """
        __sub__(self, n) -> PySwigIterator
        __sub__(self, x) -> ptrdiff_t
        """
        return _Regression.PySwigIterator___sub__(*args)

    def __iter__(self): return self
PySwigIterator_swigregister = _Regression.PySwigIterator_swigregister
PySwigIterator_swigregister(PySwigIterator)

class IntVector(_object):
    """Proxy of C++ IntVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _Regression.IntVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _Regression.IntVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(int)>::size_type"""
        return _Regression.IntVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(int)>::value_type"""
        return _Regression.IntVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> IntVector"""
        return _Regression.IntVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _Regression.IntVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _Regression.IntVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _Regression.IntVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(int)>::value_type"""
        return _Regression.IntVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _Regression.IntVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _Regression.IntVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _Regression.IntVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(int)>::size_type"""
        return _Regression.IntVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _Regression.IntVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _Regression.IntVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(int)>::allocator_type"""
        return _Regression.IntVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(int)>::const_iterator"""
        return _Regression.IntVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(int)>::const_iterator"""
        return _Regression.IntVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _Regression.IntVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _Regression.IntVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _Regression.IntVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(int)>::iterator
        erase(self, first, last) -> std::vector<(int)>::iterator
        """
        return _Regression.IntVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> IntVector
        __init__(self, ?) -> IntVector
        __init__(self, size) -> IntVector
        __init__(self, size, value) -> IntVector
        """
        this = _Regression.new_IntVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _Regression.IntVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(int)>::value_type"""
        return _Regression.IntVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(int)>::value_type"""
        return _Regression.IntVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _Regression.IntVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _Regression.IntVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(int)>::iterator
        insert(self, pos, n, x)
        """
        return _Regression.IntVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _Regression.IntVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(int)>::size_type"""
        return _Regression.IntVector_capacity(*args)

    __swig_destroy__ = _Regression.delete_IntVector
    __del__ = lambda self : None;
IntVector_swigregister = _Regression.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(_object):
    """Proxy of C++ DoubleVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _Regression.DoubleVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _Regression.DoubleVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(double)>::size_type"""
        return _Regression.DoubleVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(double)>::value_type"""
        return _Regression.DoubleVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> DoubleVector"""
        return _Regression.DoubleVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _Regression.DoubleVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _Regression.DoubleVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _Regression.DoubleVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(double)>::value_type"""
        return _Regression.DoubleVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _Regression.DoubleVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _Regression.DoubleVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _Regression.DoubleVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(double)>::size_type"""
        return _Regression.DoubleVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _Regression.DoubleVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _Regression.DoubleVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(double)>::allocator_type"""
        return _Regression.DoubleVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(double)>::const_iterator"""
        return _Regression.DoubleVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(double)>::const_iterator"""
        return _Regression.DoubleVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _Regression.DoubleVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _Regression.DoubleVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _Regression.DoubleVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(double)>::iterator
        erase(self, first, last) -> std::vector<(double)>::iterator
        """
        return _Regression.DoubleVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> DoubleVector
        __init__(self, ?) -> DoubleVector
        __init__(self, size) -> DoubleVector
        __init__(self, size, value) -> DoubleVector
        """
        this = _Regression.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _Regression.DoubleVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(double)>::value_type"""
        return _Regression.DoubleVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(double)>::value_type"""
        return _Regression.DoubleVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _Regression.DoubleVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _Regression.DoubleVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(double)>::iterator
        insert(self, pos, n, x)
        """
        return _Regression.DoubleVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _Regression.DoubleVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(double)>::size_type"""
        return _Regression.DoubleVector_capacity(*args)

    __swig_destroy__ = _Regression.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _Regression.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

RT_NONE = _Regression.RT_NONE
RT_LIGHT = _Regression.RT_LIGHT
RT_LIBSVM = _Regression.RT_LIBSVM
CT_NONE = _Regression.CT_NONE
CT_LIGHT = _Regression.CT_LIGHT
CT_LIBSVM = _Regression.CT_LIBSVM
CT_LIBSVMONECLASS = _Regression.CT_LIBSVMONECLASS
CT_LIBSVMMULTICLASS = _Regression.CT_LIBSVMMULTICLASS
CT_MPD = _Regression.CT_MPD
CT_GPBT = _Regression.CT_GPBT
CT_CPLEXSVM = _Regression.CT_CPLEXSVM
CT_PERCEPTRON = _Regression.CT_PERCEPTRON
CT_KERNELPERCEPTRON = _Regression.CT_KERNELPERCEPTRON
CT_LDA = _Regression.CT_LDA
CT_LPM = _Regression.CT_LPM
CT_LPBOOST = _Regression.CT_LPBOOST
CT_KNN = _Regression.CT_KNN
CT_SVMLIN = _Regression.CT_SVMLIN
CT_KRR = _Regression.CT_KRR
CT_GNPPSVM = _Regression.CT_GNPPSVM
CT_GMNPSVM = _Regression.CT_GMNPSVM
CT_SUBGRADIENTSVM = _Regression.CT_SUBGRADIENTSVM
CT_SUBGRADIENTLPM = _Regression.CT_SUBGRADIENTLPM
CT_SVMPERF = _Regression.CT_SVMPERF
CT_LIBSVR = _Regression.CT_LIBSVR
CT_SVRLIGHT = _Regression.CT_SVRLIGHT
CT_LIBLINEAR = _Regression.CT_LIBLINEAR
CT_KMEANS = _Regression.CT_KMEANS
CT_HIERARCHICAL = _Regression.CT_HIERARCHICAL
CT_SVMOCAS = _Regression.CT_SVMOCAS
CT_WDSVMOCAS = _Regression.CT_WDSVMOCAS
CT_SVMSGD = _Regression.CT_SVMSGD
CT_MKLMULTICLASS = _Regression.CT_MKLMULTICLASS
CT_MKLCLASSIFICATION = _Regression.CT_MKLCLASSIFICATION
CT_MKLONECLASS = _Regression.CT_MKLONECLASS
CT_MKLREGRESSION = _Regression.CT_MKLREGRESSION
CT_SCATTERSVM = _Regression.CT_SCATTERSVM
CT_DASVM = _Regression.CT_DASVM
CT_LARANK = _Regression.CT_LARANK
ST_AUTO = _Regression.ST_AUTO
ST_CPLEX = _Regression.ST_CPLEX
ST_GLPK = _Regression.ST_GLPK
ST_NEWTON = _Regression.ST_NEWTON
ST_DIRECT = _Regression.ST_DIRECT
class Classifier(SGObject):
    """Proxy of C++ Classifier class"""
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Classifier, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Classifier, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Regression.delete_Classifier
    __del__ = lambda self : None;
    def train(*args):
        """
        train(self, data=None) -> bool
        train(self) -> bool
        """
        return _Regression.Classifier_train(*args)

    def classify(*args):
        """
        classify(self) -> CLabels
        classify(self, data) -> CLabels
        """
        return _Regression.Classifier_classify(*args)

    def classify_example(*args):
        """classify_example(self, num) -> float"""
        return _Regression.Classifier_classify_example(*args)

    def load(*args):
        """load(self, srcfile) -> bool"""
        return _Regression.Classifier_load(*args)

    def save(*args):
        """save(self, dstfile) -> bool"""
        return _Regression.Classifier_save(*args)

    def set_labels(*args):
        """set_labels(self, lab)"""
        return _Regression.Classifier_set_labels(*args)

    def get_labels(*args):
        """get_labels(self) -> CLabels"""
        return _Regression.Classifier_get_labels(*args)

    def get_label(*args):
        """get_label(self, i) -> float"""
        return _Regression.Classifier_get_label(*args)

    def set_max_train_time(*args):
        """set_max_train_time(self, t)"""
        return _Regression.Classifier_set_max_train_time(*args)

    def get_max_train_time(*args):
        """get_max_train_time(self) -> float"""
        return _Regression.Classifier_get_max_train_time(*args)

    def get_classifier_type(*args):
        """get_classifier_type(self) -> EClassifierType"""
        return _Regression.Classifier_get_classifier_type(*args)

    def set_solver_type(*args):
        """set_solver_type(self, st)"""
        return _Regression.Classifier_set_solver_type(*args)

    def get_solver_type(*args):
        """get_solver_type(self) -> ESolverType"""
        return _Regression.Classifier_get_solver_type(*args)

Classifier_swigregister = _Regression.Classifier_swigregister
Classifier_swigregister(Classifier)

class KernelMachine(Classifier):
    """Proxy of C++ KernelMachine class"""
    __swig_setmethods__ = {}
    for _s in [Classifier]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KernelMachine, name, value)
    __swig_getmethods__ = {}
    for _s in [Classifier]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, KernelMachine, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Regression.delete_KernelMachine
    __del__ = lambda self : None;
    def set_kernel(*args):
        """set_kernel(self, k)"""
        return _Regression.KernelMachine_set_kernel(*args)

    def get_kernel(*args):
        """get_kernel(self) -> CKernel"""
        return _Regression.KernelMachine_get_kernel(*args)

    def set_batch_computation_enabled(*args):
        """set_batch_computation_enabled(self, enable)"""
        return _Regression.KernelMachine_set_batch_computation_enabled(*args)

    def get_batch_computation_enabled(*args):
        """get_batch_computation_enabled(self) -> bool"""
        return _Regression.KernelMachine_get_batch_computation_enabled(*args)

    def set_linadd_enabled(*args):
        """set_linadd_enabled(self, enable)"""
        return _Regression.KernelMachine_set_linadd_enabled(*args)

    def get_linadd_enabled(*args):
        """get_linadd_enabled(self) -> bool"""
        return _Regression.KernelMachine_get_linadd_enabled(*args)

    def set_bias_enabled(*args):
        """set_bias_enabled(self, enable_bias)"""
        return _Regression.KernelMachine_set_bias_enabled(*args)

    def get_bias_enabled(*args):
        """get_bias_enabled(self) -> bool"""
        return _Regression.KernelMachine_get_bias_enabled(*args)

    def get_bias(*args):
        """get_bias(self) -> float"""
        return _Regression.KernelMachine_get_bias(*args)

    def set_bias(*args):
        """set_bias(self, bias)"""
        return _Regression.KernelMachine_set_bias(*args)

    def get_support_vector(*args):
        """get_support_vector(self, idx) ->  int"""
        return _Regression.KernelMachine_get_support_vector(*args)

    def get_alpha(*args):
        """get_alpha(self, idx) -> float"""
        return _Regression.KernelMachine_get_alpha(*args)

    def set_support_vector(*args):
        """set_support_vector(self, idx, val) -> bool"""
        return _Regression.KernelMachine_set_support_vector(*args)

    def set_alpha(*args):
        """set_alpha(self, idx, val) -> bool"""
        return _Regression.KernelMachine_set_alpha(*args)

    def get_num_support_vectors(*args):
        """get_num_support_vectors(self) ->  int"""
        return _Regression.KernelMachine_get_num_support_vectors(*args)

    def set_alphas(*args):
        """set_alphas(self, alphas)"""
        return _Regression.KernelMachine_set_alphas(*args)

    def set_support_vectors(*args):
        """set_support_vectors(self, svs)"""
        return _Regression.KernelMachine_set_support_vectors(*args)

    def get_support_vectors(*args):
        """get_support_vectors(self, svs)"""
        return _Regression.KernelMachine_get_support_vectors(*args)

    def get_alphas(*args):
        """get_alphas(self, alphas)"""
        return _Regression.KernelMachine_get_alphas(*args)

    def create_new_model(*args):
        """create_new_model(self, num) -> bool"""
        return _Regression.KernelMachine_create_new_model(*args)

    def init_kernel_optimization(*args):
        """init_kernel_optimization(self) -> bool"""
        return _Regression.KernelMachine_init_kernel_optimization(*args)

    def classify(*args):
        """
        classify(self) -> CLabels
        classify(self, data) -> CLabels
        """
        return _Regression.KernelMachine_classify(*args)

    def classify_example_helper(*args):
        """classify_example_helper(p) -> void"""
        return _Regression.KernelMachine_classify_example_helper(*args)

    if _newclass:classify_example_helper = staticmethod(classify_example_helper)
    __swig_getmethods__["classify_example_helper"] = lambda x: classify_example_helper
KernelMachine_swigregister = _Regression.KernelMachine_swigregister
KernelMachine_swigregister(KernelMachine)

def KernelMachine_classify_example_helper(*args):
  """KernelMachine_classify_example_helper(p) -> void"""
  return _Regression.KernelMachine_classify_example_helper(*args)

class KRR(KernelMachine):
    """Proxy of C++ KRR class"""
    __swig_setmethods__ = {}
    for _s in [KernelMachine]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KRR, name, value)
    __swig_getmethods__ = {}
    for _s in [KernelMachine]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, KRR, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> KRR
        __init__(self, tau, k, lab) -> KRR
        """
        this = _Regression.new_KRR(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Regression.delete_KRR
    __del__ = lambda self : None;
    def set_tau(*args):
        """set_tau(self, t)"""
        return _Regression.KRR_set_tau(*args)

    def train(*args):
        """
        train(self, data=None) -> bool
        train(self) -> bool
        """
        return _Regression.KRR_train(*args)

    def classify(*args):
        """
        classify(self) -> CLabels
        classify(self, data) -> CLabels
        """
        return _Regression.KRR_classify(*args)

KRR_swigregister = _Regression.KRR_swigregister
KRR_swigregister(KRR)

class SVM(KernelMachine):
    """Proxy of C++ SVM class"""
    __swig_setmethods__ = {}
    for _s in [KernelMachine]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVM, name, value)
    __swig_getmethods__ = {}
    for _s in [KernelMachine]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SVM, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, num_sv=0) -> SVM
        __init__(self) -> SVM
        __init__(self, C, k, lab) -> SVM
        """
        this = _Regression.new_SVM(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Regression.delete_SVM
    __del__ = lambda self : None;
    def set_defaults(*args):
        """
        set_defaults(self, num_sv=0)
        set_defaults(self)
        """
        return _Regression.SVM_set_defaults(*args)

    def get_linear_term(*args):
        """get_linear_term(self) -> DoubleVector"""
        return _Regression.SVM_get_linear_term(*args)

    def set_linear_term(*args):
        """set_linear_term(self, lin)"""
        return _Regression.SVM_set_linear_term(*args)

    def set_nu(*args):
        """set_nu(self, nue)"""
        return _Regression.SVM_set_nu(*args)

    def set_C(*args):
        """set_C(self, c1, c2)"""
        return _Regression.SVM_set_C(*args)

    def set_epsilon(*args):
        """set_epsilon(self, eps)"""
        return _Regression.SVM_set_epsilon(*args)

    def set_tube_epsilon(*args):
        """set_tube_epsilon(self, eps)"""
        return _Regression.SVM_set_tube_epsilon(*args)

    def set_qpsize(*args):
        """set_qpsize(self, qps)"""
        return _Regression.SVM_set_qpsize(*args)

    def get_epsilon(*args):
        """get_epsilon(self) -> float"""
        return _Regression.SVM_get_epsilon(*args)

    def get_nu(*args):
        """get_nu(self) -> float"""
        return _Regression.SVM_get_nu(*args)

    def get_C1(*args):
        """get_C1(self) -> float"""
        return _Regression.SVM_get_C1(*args)

    def get_C2(*args):
        """get_C2(self) -> float"""
        return _Regression.SVM_get_C2(*args)

    def get_qpsize(*args):
        """get_qpsize(self) ->  int"""
        return _Regression.SVM_get_qpsize(*args)

    def set_shrinking_enabled(*args):
        """set_shrinking_enabled(self, enable)"""
        return _Regression.SVM_set_shrinking_enabled(*args)

    def get_shrinking_enabled(*args):
        """get_shrinking_enabled(self) -> bool"""
        return _Regression.SVM_get_shrinking_enabled(*args)

    def compute_svm_dual_objective(*args):
        """compute_svm_dual_objective(self) -> float"""
        return _Regression.SVM_compute_svm_dual_objective(*args)

    def compute_svm_primal_objective(*args):
        """compute_svm_primal_objective(self) -> float"""
        return _Regression.SVM_compute_svm_primal_objective(*args)

    def set_objective(*args):
        """set_objective(self, v)"""
        return _Regression.SVM_set_objective(*args)

    def get_objective(*args):
        """get_objective(self) -> float"""
        return _Regression.SVM_get_objective(*args)

    def set_callback_function(*args):
        """set_callback_function(self, m, cb)"""
        return _Regression.SVM_set_callback_function(*args)

SVM_swigregister = _Regression.SVM_swigregister
SVM_swigregister(SVM)

LIBSVM_C_SVC = _Regression.LIBSVM_C_SVC
LIBSVM_NU_SVC = _Regression.LIBSVM_NU_SVC
class LibSVM(SVM):
    """Proxy of C++ LibSVM class"""
    __swig_setmethods__ = {}
    for _s in [SVM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LibSVM, name, value)
    __swig_getmethods__ = {}
    for _s in [SVM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LibSVM, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, st=LIBSVM_C_SVC) -> LibSVM
        __init__(self) -> LibSVM
        __init__(self, C, k, lab) -> LibSVM
        """
        this = _Regression.new_LibSVM(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Regression.delete_LibSVM
    __del__ = lambda self : None;
    def train(*args):
        """
        train(self, data=None) -> bool
        train(self) -> bool
        """
        return _Regression.LibSVM_train(*args)

LibSVM_swigregister = _Regression.LibSVM_swigregister
LibSVM_swigregister(LibSVM)

class LibSVR(SVM):
    """
    Class LibSVR, performs support vector regression using LibSVM.

    The SVR solution can be expressed as \\[ f({\\bf
    x})=\\sum_{i=1}^{N} \\alpha_i k({\\bf x}, {\\bf x_i})+b \\]

    where $\\alpha$ and $b$ are determined in training, i.e. using a
    pre-specified kernel, a given tube-epsilon for the epsilon insensitive
    loss, the follwoing quadratic problem is minimized (using sequential
    minimal decomposition (SMO))

    \\begin{eqnarray*} \\max_{{\\bf \\alpha},{\\bf \\alpha}^*}
    &-\\frac{1}{2}\\sum_{i,j=1}^N(\\alpha_i-\\alpha_i^*)(\\alpha_j-\\alpha_j^*){\\bf
    x}_i^T {\\bf x}_j
    -\\sum_{i=1}^N(\\alpha_i+\\alpha_i^*)\\epsilon -
    \\sum_{i=1}^N(\\alpha_i-\\alpha_i^*)y_i\\\\ \\mbox{wrt}:&
    {\\bf \\alpha},{\\bf \\alpha}^*\\in{\\bf R}^N\\\\
    \\mbox{s.t.}:& 0\\leq \\alpha_i,\\alpha_i^*\\leq C,\\,
    \\forall i=1\\dots N\\\\
    &\\sum_{i=1}^N(\\alpha_i-\\alpha_i^*)y_i=0 \\end{eqnarray*}

    Note that the SV regression problem is reduced to the standard SV
    classification problem by introducing artificial labels $-y_i$ which
    leads to the epsilon insensitive loss constraints *
    \\begin{eqnarray*} {\\bf w}^T{\\bf x}_i+b-c_i-\\xi_i\\leq
    0,&\\, \\forall i=1\\dots N\\\\ -{\\bf w}^T{\\bf
    x}_i-b-c_i^*-\\xi_i^*\\leq 0,&\\, \\forall i=1\\dots N
    \\end{eqnarray*} with $c_i=y_i+ \\epsilon$ and $c_i^*=-y_i+
    \\epsilon$

    C++ includes: LibSVR.h 
    """
    __swig_setmethods__ = {}
    for _s in [SVM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LibSVR, name, value)
    __swig_getmethods__ = {}
    for _s in [SVM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LibSVR, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> LibSVR
        __init__(self, C, epsilon, k, lab) -> LibSVR

        constructor

        Parameters:
        -----------

        C:  constant C

        epsilon:  epsilon

        k:  kernel

        lab:  labels 
        """
        this = _Regression.new_LibSVR(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Regression.delete_LibSVR
    __del__ = lambda self : None;
    def train(*args):
        """
        train(self, data=None) -> bool
        train(self) -> bool

        train regression

        Parameters:
        -----------

        data:  training data (parameter can be avoided if distance or kernel-
        based regressor are used and distance/kernels are initialized with
        train data)

        whether training was successful 
        """
        return _Regression.LibSVR_train(*args)

LibSVR_swigregister = _Regression.LibSVR_swigregister
LibSVR_swigregister(LibSVR)

class MKL(SVM):
    """Proxy of C++ MKL class"""
    __swig_setmethods__ = {}
    for _s in [SVM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MKL, name, value)
    __swig_getmethods__ = {}
    for _s in [SVM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MKL, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Regression.delete_MKL
    __del__ = lambda self : None;
    def set_constraint_generator(*args):
        """set_constraint_generator(self, s)"""
        return _Regression.MKL_set_constraint_generator(*args)

    def set_svm(*args):
        """set_svm(self, s)"""
        return _Regression.MKL_set_svm(*args)

    def get_svm(*args):
        """get_svm(self) -> SVM"""
        return _Regression.MKL_get_svm(*args)

    def train(*args):
        """
        train(self, data=None) -> bool
        train(self) -> bool
        """
        return _Regression.MKL_train(*args)

    def set_C_mkl(*args):
        """set_C_mkl(self, C)"""
        return _Regression.MKL_set_C_mkl(*args)

    def set_mkl_norm(*args):
        """set_mkl_norm(self, norm)"""
        return _Regression.MKL_set_mkl_norm(*args)

    def set_interleaved_optimization_enabled(*args):
        """set_interleaved_optimization_enabled(self, enable)"""
        return _Regression.MKL_set_interleaved_optimization_enabled(*args)

    def get_interleaved_optimization_enabled(*args):
        """get_interleaved_optimization_enabled(self) -> bool"""
        return _Regression.MKL_get_interleaved_optimization_enabled(*args)

    def compute_mkl_primal_objective(*args):
        """compute_mkl_primal_objective(self) -> float"""
        return _Regression.MKL_compute_mkl_primal_objective(*args)

    def compute_mkl_dual_objective(*args):
        """compute_mkl_dual_objective(self) -> float"""
        return _Regression.MKL_compute_mkl_dual_objective(*args)

    def set_mkl_epsilon(*args):
        """set_mkl_epsilon(self, eps)"""
        return _Regression.MKL_set_mkl_epsilon(*args)

    def get_mkl_epsilon(*args):
        """get_mkl_epsilon(self) -> float"""
        return _Regression.MKL_get_mkl_epsilon(*args)

    def get_mkl_iterations(*args):
        """get_mkl_iterations(self) ->  int"""
        return _Regression.MKL_get_mkl_iterations(*args)

    def perform_mkl_step(*args):
        """perform_mkl_step(self, sumw, suma) -> bool"""
        return _Regression.MKL_perform_mkl_step(*args)

    def perform_mkl_step_helper(*args):
        """perform_mkl_step_helper(mkl, sumw, suma) -> bool"""
        return _Regression.MKL_perform_mkl_step_helper(*args)

    if _newclass:perform_mkl_step_helper = staticmethod(perform_mkl_step_helper)
    __swig_getmethods__["perform_mkl_step_helper"] = lambda x: perform_mkl_step_helper
    def compute_sum_alpha(*args):
        """compute_sum_alpha(self) -> float"""
        return _Regression.MKL_compute_sum_alpha(*args)

    def compute_sum_beta(*args):
        """compute_sum_beta(self, sumw)"""
        return _Regression.MKL_compute_sum_beta(*args)

MKL_swigregister = _Regression.MKL_swigregister
MKL_swigregister(MKL)

def MKL_perform_mkl_step_helper(*args):
  """MKL_perform_mkl_step_helper(mkl, sumw, suma) -> bool"""
  return _Regression.MKL_perform_mkl_step_helper(*args)

class MKLRegression(MKL):
    """
    Multiple Kernel Learning for regression.

    Performs support vector regression while learning kernel weights at
    the same time. Makes only sense if multiple kernels are used.

    See:  CMKL

    C++ includes: MKLRegression.h 
    """
    __swig_setmethods__ = {}
    for _s in [MKL]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MKLRegression, name, value)
    __swig_getmethods__ = {}
    for _s in [MKL]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MKLRegression, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, s=None) -> MKLRegression
        __init__(self) -> MKLRegression

        Constructor

        Parameters:
        -----------

        s:  SVM to use as constraint generator in MKL SILP 
        """
        this = _Regression.new_MKLRegression(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Regression.delete_MKLRegression
    __del__ = lambda self : None;
MKLRegression_swigregister = _Regression.MKLRegression_swigregister
MKLRegression_swigregister(MKLRegression)

DEF_PRECISION = _Regression.DEF_PRECISION
class QP(_object):
    """Proxy of C++ QP class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, QP, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, QP, name)
    __repr__ = _swig_repr
    __swig_setmethods__["opt_n"] = _Regression.QP_opt_n_set
    __swig_getmethods__["opt_n"] = _Regression.QP_opt_n_get
    if _newclass:opt_n = _swig_property(_Regression.QP_opt_n_get, _Regression.QP_opt_n_set)
    __swig_setmethods__["opt_m"] = _Regression.QP_opt_m_set
    __swig_getmethods__["opt_m"] = _Regression.QP_opt_m_get
    if _newclass:opt_m = _swig_property(_Regression.QP_opt_m_get, _Regression.QP_opt_m_set)
    __swig_setmethods__["opt_ce"] = _Regression.QP_opt_ce_set
    __swig_getmethods__["opt_ce"] = _Regression.QP_opt_ce_get
    if _newclass:opt_ce = _swig_property(_Regression.QP_opt_ce_get, _Regression.QP_opt_ce_set)
    __swig_setmethods__["opt_ce0"] = _Regression.QP_opt_ce0_set
    __swig_getmethods__["opt_ce0"] = _Regression.QP_opt_ce0_get
    if _newclass:opt_ce0 = _swig_property(_Regression.QP_opt_ce0_get, _Regression.QP_opt_ce0_set)
    __swig_setmethods__["opt_g"] = _Regression.QP_opt_g_set
    __swig_getmethods__["opt_g"] = _Regression.QP_opt_g_get
    if _newclass:opt_g = _swig_property(_Regression.QP_opt_g_get, _Regression.QP_opt_g_set)
    __swig_setmethods__["opt_g0"] = _Regression.QP_opt_g0_set
    __swig_getmethods__["opt_g0"] = _Regression.QP_opt_g0_get
    if _newclass:opt_g0 = _swig_property(_Regression.QP_opt_g0_get, _Regression.QP_opt_g0_set)
    __swig_setmethods__["opt_xinit"] = _Regression.QP_opt_xinit_set
    __swig_getmethods__["opt_xinit"] = _Regression.QP_opt_xinit_get
    if _newclass:opt_xinit = _swig_property(_Regression.QP_opt_xinit_get, _Regression.QP_opt_xinit_set)
    __swig_setmethods__["opt_low"] = _Regression.QP_opt_low_set
    __swig_getmethods__["opt_low"] = _Regression.QP_opt_low_get
    if _newclass:opt_low = _swig_property(_Regression.QP_opt_low_get, _Regression.QP_opt_low_set)
    __swig_setmethods__["opt_up"] = _Regression.QP_opt_up_set
    __swig_getmethods__["opt_up"] = _Regression.QP_opt_up_get
    if _newclass:opt_up = _swig_property(_Regression.QP_opt_up_get, _Regression.QP_opt_up_set)
    def __init__(self, *args): 
        """__init__(self) -> QP"""
        this = _Regression.new_QP(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Regression.delete_QP
    __del__ = lambda self : None;
QP_swigregister = _Regression.QP_swigregister
QP_swigregister(QP)

class SVMLight(SVM):
    """Proxy of C++ SVMLight class"""
    __swig_setmethods__ = {}
    for _s in [SVM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVMLight, name, value)
    __swig_getmethods__ = {}
    for _s in [SVM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SVMLight, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> SVMLight
        __init__(self, C, k, lab) -> SVMLight
        """
        this = _Regression.new_SVMLight(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Regression.delete_SVMLight
    __del__ = lambda self : None;
    def init(*args):
        """init(self)"""
        return _Regression.SVMLight_init(*args)

    def train(*args):
        """
        train(self, data=None) -> bool
        train(self) -> bool
        """
        return _Regression.SVMLight_train(*args)

    def get_runtime(*args):
        """get_runtime(self) ->  int"""
        return _Regression.SVMLight_get_runtime(*args)

    def svm_learn(*args):
        """svm_learn(self)"""
        return _Regression.SVMLight_svm_learn(*args)

    def optimize_to_convergence(*args):
        """
        optimize_to_convergence(self, docs, label, totdoc, shrink_state, inconsistent, a, 
            lin, c, timing_profile, maxdiff, heldout, retrain) ->  int
        """
        return _Regression.SVMLight_optimize_to_convergence(*args)

    def compute_objective_function(*args):
        """compute_objective_function(self, a, lin, c, eps, label, totdoc) -> float"""
        return _Regression.SVMLight_compute_objective_function(*args)

    def clear_index(*args):
        """clear_index(self, index)"""
        return _Regression.SVMLight_clear_index(*args)

    def add_to_index(*args):
        """add_to_index(self, index, elem)"""
        return _Regression.SVMLight_add_to_index(*args)

    def compute_index(*args):
        """compute_index(self, binfeature, range, index) ->  int"""
        return _Regression.SVMLight_compute_index(*args)

    def optimize_svm(*args):
        """
        optimize_svm(self, docs, label, exclude_from_eq_const, eq_target, chosen, 
            active2dnum, totdoc, working2dnum, varnum, 
            a, lin, c, aicache, qp, epsilon_crit_target)
        """
        return _Regression.SVMLight_optimize_svm(*args)

    def compute_matrices_for_optimization(*args):
        """
        compute_matrices_for_optimization(self, docs, label, exclude_from_eq_const, eq_target, chosen, 
            active2dnum, key, a, lin, c, varnum, totdoc, 
            aicache, qp)
        """
        return _Regression.SVMLight_compute_matrices_for_optimization(*args)

    def compute_matrices_for_optimization_parallel(*args):
        """
        compute_matrices_for_optimization_parallel(self, docs, label, exclude_from_eq_const, eq_target, chosen, 
            active2dnum, key, a, lin, c, varnum, totdoc, 
            aicache, qp)
        """
        return _Regression.SVMLight_compute_matrices_for_optimization_parallel(*args)

    def calculate_svm_model(*args):
        """calculate_svm_model(self, docs, label, lin, a, a_old, c, working2dnum, active2dnum) ->  int"""
        return _Regression.SVMLight_calculate_svm_model(*args)

    def check_optimality(*args):
        """
        check_optimality(self, label, a, lin, c, totdoc, maxdiff, epsilon_crit_org, 
            misclassified, inconsistent, active2dnum, last_suboptimal_at, 
            iteration) ->  int
        """
        return _Regression.SVMLight_check_optimality(*args)

    def update_linear_component(*args):
        """
        update_linear_component(self, docs, label, active2dnum, a, a_old, working2dnum, totdoc, 
            lin, aicache, c)
        """
        return _Regression.SVMLight_update_linear_component(*args)

    def update_linear_component_mkl_linadd_helper(*args):
        """update_linear_component_mkl_linadd_helper(p) -> void"""
        return _Regression.SVMLight_update_linear_component_mkl_linadd_helper(*args)

    if _newclass:update_linear_component_mkl_linadd_helper = staticmethod(update_linear_component_mkl_linadd_helper)
    __swig_getmethods__["update_linear_component_mkl_linadd_helper"] = lambda x: update_linear_component_mkl_linadd_helper
    def update_linear_component_mkl(*args):
        """
        update_linear_component_mkl(self, docs, label, active2dnum, a, a_old, working2dnum, totdoc, 
            lin, aicache)
        """
        return _Regression.SVMLight_update_linear_component_mkl(*args)

    def update_linear_component_mkl_linadd(*args):
        """
        update_linear_component_mkl_linadd(self, docs, label, active2dnum, a, a_old, working2dnum, totdoc, 
            lin, aicache)
        """
        return _Regression.SVMLight_update_linear_component_mkl_linadd(*args)

    def call_mkl_callback(*args):
        """call_mkl_callback(self, a, label, lin)"""
        return _Regression.SVMLight_call_mkl_callback(*args)

    def select_next_qp_subproblem_grad(*args):
        """
        select_next_qp_subproblem_grad(self, label, a, lin, c, totdoc, qp_size, inconsistent, active2dnum, 
            working2dnum, selcrit, select, cache_only, 
            key, chosen) ->  int
        """
        return _Regression.SVMLight_select_next_qp_subproblem_grad(*args)

    def select_next_qp_subproblem_rand(*args):
        """
        select_next_qp_subproblem_rand(self, label, a, lin, c, totdoc, qp_size, inconsistent, active2dnum, 
            working2dnum, selcrit, select, key, 
            chosen, iteration) ->  int
        """
        return _Regression.SVMLight_select_next_qp_subproblem_rand(*args)

    def select_top_n(*args):
        """select_top_n(self, selcrit, range, select, n)"""
        return _Regression.SVMLight_select_top_n(*args)

    def init_shrink_state(*args):
        """init_shrink_state(self, shrink_state, totdoc, maxhistory)"""
        return _Regression.SVMLight_init_shrink_state(*args)

    def shrink_state_cleanup(*args):
        """shrink_state_cleanup(self, shrink_state)"""
        return _Regression.SVMLight_shrink_state_cleanup(*args)

    def shrink_problem(*args):
        """
        shrink_problem(self, shrink_state, active2dnum, last_suboptimal_at, iteration, 
            totdoc, minshrink, a, inconsistent, c, 
            lin, label) ->  int
        """
        return _Regression.SVMLight_shrink_problem(*args)

    def reactivate_inactive_examples(*args):
        """
        reactivate_inactive_examples(self, label, a, shrink_state, lin, c, totdoc, iteration, 
            inconsistent, docs, aicache, maxdiff)
        """
        return _Regression.SVMLight_reactivate_inactive_examples(*args)

SVMLight_swigregister = _Regression.SVMLight_swigregister
SVMLight_swigregister(SVMLight)

def SVMLight_update_linear_component_mkl_linadd_helper(*args):
  """SVMLight_update_linear_component_mkl_linadd_helper(p) -> void"""
  return _Regression.SVMLight_update_linear_component_mkl_linadd_helper(*args)

class SVRLight(SVMLight):
    """Proxy of C++ SVRLight class"""
    __swig_setmethods__ = {}
    for _s in [SVMLight]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVRLight, name, value)
    __swig_getmethods__ = {}
    for _s in [SVMLight]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SVRLight, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> SVRLight
        __init__(self, C, epsilon, k, lab) -> SVRLight
        """
        this = _Regression.new_SVRLight(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Regression.delete_SVRLight
    __del__ = lambda self : None;
    def train(*args):
        """
        train(self, data=None) -> bool
        train(self) -> bool
        """
        return _Regression.SVRLight_train(*args)

    def svr_learn(*args):
        """svr_learn(self)"""
        return _Regression.SVRLight_svr_learn(*args)

    def update_linear_component_mkl(*args):
        """
        update_linear_component_mkl(self, docs, label, active2dnum, a, a_old, working2dnum, totdoc, 
            lin, aicache, c)
        """
        return _Regression.SVRLight_update_linear_component_mkl(*args)

    def update_linear_component_mkl_linadd(*args):
        """
        update_linear_component_mkl_linadd(self, docs, label, active2dnum, a, a_old, working2dnum, totdoc, 
            lin, aicache, c)
        """
        return _Regression.SVRLight_update_linear_component_mkl_linadd(*args)

    def call_mkl_callback(*args):
        """call_mkl_callback(self, a, label, lin, c, totdoc)"""
        return _Regression.SVRLight_call_mkl_callback(*args)

SVRLight_swigregister = _Regression.SVRLight_swigregister
SVRLight_swigregister(SVRLight)



