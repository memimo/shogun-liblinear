# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.
# This file is compatible with both classic and new-style classes.

"""
The `PreProc` module gathers all preprocessors available in the SHOGUN toolkit.
"""

import _PreProc
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types


class ShogunException(_object):
    """Proxy of C++ ShogunException class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShogunException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ShogunException, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, str) -> ShogunException"""
        this = _PreProc.new_ShogunException(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PreProc.delete_ShogunException
    __del__ = lambda self : None;
    def get_exception_string(*args):
        """get_exception_string(self) -> str"""
        return _PreProc.ShogunException_get_exception_string(*args)

ShogunException_swigregister = _PreProc.ShogunException_swigregister
ShogunException_swigregister(ShogunException)

MSG_GCDEBUG = _PreProc.MSG_GCDEBUG
MSG_DEBUG = _PreProc.MSG_DEBUG
MSG_INFO = _PreProc.MSG_INFO
MSG_NOTICE = _PreProc.MSG_NOTICE
MSG_WARN = _PreProc.MSG_WARN
MSG_ERROR = _PreProc.MSG_ERROR
MSG_CRITICAL = _PreProc.MSG_CRITICAL
MSG_ALERT = _PreProc.MSG_ALERT
MSG_EMERGENCY = _PreProc.MSG_EMERGENCY
MSG_MESSAGEONLY = _PreProc.MSG_MESSAGEONLY
class IO(_object):
    """Proxy of C++ IO class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IO, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IO, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IO
        __init__(self, orig) -> IO
        """
        this = _PreProc.new_IO(*args)
        try: self.this.append(this)
        except: self.this = this
    def set_loglevel(*args):
        """set_loglevel(self, level)"""
        return _PreProc.IO_set_loglevel(*args)

    def get_loglevel(*args):
        """get_loglevel(self) -> EMessageType"""
        return _PreProc.IO_get_loglevel(*args)

    def get_show_progress(*args):
        """get_show_progress(self) -> bool"""
        return _PreProc.IO_get_show_progress(*args)

    def get_show_file_and_line(*args):
        """get_show_file_and_line(self) -> bool"""
        return _PreProc.IO_get_show_file_and_line(*args)

    def message(*args):
        """message(self, prio, file, line, fmt, ?)"""
        return _PreProc.IO_message(*args)

    def progress(*args):
        """
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1)
        progress(self, current_val, min_val=0.0, max_val=1.0)
        progress(self, current_val, min_val=0.0)
        progress(self, current_val)
        """
        return _PreProc.IO_progress(*args)

    def absolute_progress(*args):
        """
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1)
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0)
        absolute_progress(self, current_val, val, min_val=0.0)
        absolute_progress(self, current_val, val)
        """
        return _PreProc.IO_absolute_progress(*args)

    def done(*args):
        """done(self)"""
        return _PreProc.IO_done(*args)

    def not_implemented(*args):
        """not_implemented(self, file, line)"""
        return _PreProc.IO_not_implemented(*args)

    def deprecated(*args):
        """deprecated(self, file, line)"""
        return _PreProc.IO_deprecated(*args)

    def buffered_message(*args):
        """buffered_message(self, prio, fmt, ?)"""
        return _PreProc.IO_buffered_message(*args)

    def skip_spaces(*args):
        """skip_spaces(str) -> str"""
        return _PreProc.IO_skip_spaces(*args)

    if _newclass:skip_spaces = staticmethod(skip_spaces)
    __swig_getmethods__["skip_spaces"] = lambda x: skip_spaces
    def skip_blanks(*args):
        """skip_blanks(str) -> str"""
        return _PreProc.IO_skip_blanks(*args)

    if _newclass:skip_blanks = staticmethod(skip_blanks)
    __swig_getmethods__["skip_blanks"] = lambda x: skip_blanks
    def get_target(*args):
        """get_target(self) -> FILE"""
        return _PreProc.IO_get_target(*args)

    def set_target(*args):
        """set_target(self, target)"""
        return _PreProc.IO_set_target(*args)

    def set_target_to_stderr(*args):
        """set_target_to_stderr(self)"""
        return _PreProc.IO_set_target_to_stderr(*args)

    def set_target_to_stdout(*args):
        """set_target_to_stdout(self)"""
        return _PreProc.IO_set_target_to_stdout(*args)

    def enable_progress(*args):
        """enable_progress(self)"""
        return _PreProc.IO_enable_progress(*args)

    def disable_progress(*args):
        """disable_progress(self)"""
        return _PreProc.IO_disable_progress(*args)

    def enable_file_and_line(*args):
        """enable_file_and_line(self)"""
        return _PreProc.IO_enable_file_and_line(*args)

    def disable_file_and_line(*args):
        """disable_file_and_line(self)"""
        return _PreProc.IO_disable_file_and_line(*args)

    def set_dirname(*args):
        """set_dirname(dirname)"""
        return _PreProc.IO_set_dirname(*args)

    if _newclass:set_dirname = staticmethod(set_dirname)
    __swig_getmethods__["set_dirname"] = lambda x: set_dirname
    def concat_filename(*args):
        """concat_filename(filename) -> str"""
        return _PreProc.IO_concat_filename(*args)

    if _newclass:concat_filename = staticmethod(concat_filename)
    __swig_getmethods__["concat_filename"] = lambda x: concat_filename
    def filter(*args):
        """filter(d) -> int"""
        return _PreProc.IO_filter(*args)

    if _newclass:filter = staticmethod(filter)
    __swig_getmethods__["filter"] = lambda x: filter
    def ref(*args):
        """ref(self) ->  int"""
        return _PreProc.IO_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _PreProc.IO_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _PreProc.IO_unref(*args)

    def get_name(*args):
        """get_name(self) -> str"""
        return _PreProc.IO_get_name(*args)

    __swig_destroy__ = _PreProc.delete_IO
    __del__ = lambda self : None;
IO_swigregister = _PreProc.IO_swigregister
IO_swigregister(IO)
cvar = _PreProc.cvar

def IO_skip_spaces(*args):
  """IO_skip_spaces(str) -> str"""
  return _PreProc.IO_skip_spaces(*args)

def IO_skip_blanks(*args):
  """IO_skip_blanks(str) -> str"""
  return _PreProc.IO_skip_blanks(*args)

def IO_set_dirname(*args):
  """IO_set_dirname(dirname)"""
  return _PreProc.IO_set_dirname(*args)

def IO_concat_filename(*args):
  """IO_concat_filename(filename) -> str"""
  return _PreProc.IO_concat_filename(*args)

def IO_filter(*args):
  """IO_filter(d) -> int"""
  return _PreProc.IO_filter(*args)

class SGObject(_object):
    """Proxy of C++ SGObject class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SGObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SGObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _PreProc.delete_SGObject
    __del__ = lambda self : None;
    def ref(*args):
        """ref(self) ->  int"""
        return _PreProc.SGObject_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _PreProc.SGObject_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _PreProc.SGObject_unref(*args)

    def get_name(*args):
        """get_name(self) -> str"""
        return _PreProc.SGObject_get_name(*args)

    __swig_setmethods__["io"] = _PreProc.SGObject_io_set
    __swig_getmethods__["io"] = _PreProc.SGObject_io_get
    if _newclass:io = _swig_property(_PreProc.SGObject_io_get, _PreProc.SGObject_io_set)
    __swig_setmethods__["parallel"] = _PreProc.SGObject_parallel_set
    __swig_getmethods__["parallel"] = _PreProc.SGObject_parallel_get
    if _newclass:parallel = _swig_property(_PreProc.SGObject_parallel_get, _PreProc.SGObject_parallel_set)
    __swig_setmethods__["version"] = _PreProc.SGObject_version_set
    __swig_getmethods__["version"] = _PreProc.SGObject_version_get
    if _newclass:version = _swig_property(_PreProc.SGObject_version_get, _PreProc.SGObject_version_set)
SGObject_swigregister = _PreProc.SGObject_swigregister
SGObject_swigregister(SGObject)

class Version(_object):
    """Proxy of C++ Version class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Version, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Version, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self) -> Version"""
        this = _PreProc.new_Version(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PreProc.delete_Version
    __del__ = lambda self : None;
    def print_version(*args):
        """print_version()"""
        return _PreProc.Version_print_version(*args)

    if _newclass:print_version = staticmethod(print_version)
    __swig_getmethods__["print_version"] = lambda x: print_version
    def get_version_extra(*args):
        """get_version_extra() -> str"""
        return _PreProc.Version_get_version_extra(*args)

    if _newclass:get_version_extra = staticmethod(get_version_extra)
    __swig_getmethods__["get_version_extra"] = lambda x: get_version_extra
    def get_version_release(*args):
        """get_version_release() -> str"""
        return _PreProc.Version_get_version_release(*args)

    if _newclass:get_version_release = staticmethod(get_version_release)
    __swig_getmethods__["get_version_release"] = lambda x: get_version_release
    def get_version_revision(*args):
        """get_version_revision() ->  int"""
        return _PreProc.Version_get_version_revision(*args)

    if _newclass:get_version_revision = staticmethod(get_version_revision)
    __swig_getmethods__["get_version_revision"] = lambda x: get_version_revision
    def get_version_year(*args):
        """get_version_year() ->  int"""
        return _PreProc.Version_get_version_year(*args)

    if _newclass:get_version_year = staticmethod(get_version_year)
    __swig_getmethods__["get_version_year"] = lambda x: get_version_year
    def get_version_month(*args):
        """get_version_month() ->  int"""
        return _PreProc.Version_get_version_month(*args)

    if _newclass:get_version_month = staticmethod(get_version_month)
    __swig_getmethods__["get_version_month"] = lambda x: get_version_month
    def get_version_day(*args):
        """get_version_day() ->  int"""
        return _PreProc.Version_get_version_day(*args)

    if _newclass:get_version_day = staticmethod(get_version_day)
    __swig_getmethods__["get_version_day"] = lambda x: get_version_day
    def get_version_hour(*args):
        """get_version_hour() ->  int"""
        return _PreProc.Version_get_version_hour(*args)

    if _newclass:get_version_hour = staticmethod(get_version_hour)
    __swig_getmethods__["get_version_hour"] = lambda x: get_version_hour
    def get_version_minute(*args):
        """get_version_minute() ->  int"""
        return _PreProc.Version_get_version_minute(*args)

    if _newclass:get_version_minute = staticmethod(get_version_minute)
    __swig_getmethods__["get_version_minute"] = lambda x: get_version_minute
    def get_version_in_minutes(*args):
        """get_version_in_minutes() -> int"""
        return _PreProc.Version_get_version_in_minutes(*args)

    if _newclass:get_version_in_minutes = staticmethod(get_version_in_minutes)
    __swig_getmethods__["get_version_in_minutes"] = lambda x: get_version_in_minutes
    def ref(*args):
        """ref(self) ->  int"""
        return _PreProc.Version_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _PreProc.Version_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _PreProc.Version_unref(*args)

Version_swigregister = _PreProc.Version_swigregister
Version_swigregister(Version)

def Version_print_version(*args):
  """Version_print_version()"""
  return _PreProc.Version_print_version(*args)

def Version_get_version_extra(*args):
  """Version_get_version_extra() -> str"""
  return _PreProc.Version_get_version_extra(*args)

def Version_get_version_release(*args):
  """Version_get_version_release() -> str"""
  return _PreProc.Version_get_version_release(*args)

def Version_get_version_revision(*args):
  """Version_get_version_revision() ->  int"""
  return _PreProc.Version_get_version_revision(*args)

def Version_get_version_year(*args):
  """Version_get_version_year() ->  int"""
  return _PreProc.Version_get_version_year(*args)

def Version_get_version_month(*args):
  """Version_get_version_month() ->  int"""
  return _PreProc.Version_get_version_month(*args)

def Version_get_version_day(*args):
  """Version_get_version_day() ->  int"""
  return _PreProc.Version_get_version_day(*args)

def Version_get_version_hour(*args):
  """Version_get_version_hour() ->  int"""
  return _PreProc.Version_get_version_hour(*args)

def Version_get_version_minute(*args):
  """Version_get_version_minute() ->  int"""
  return _PreProc.Version_get_version_minute(*args)

def Version_get_version_in_minutes(*args):
  """Version_get_version_in_minutes() -> int"""
  return _PreProc.Version_get_version_in_minutes(*args)

class Parallel(_object):
    """Proxy of C++ Parallel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parallel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Parallel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Parallel
        __init__(self, orig) -> Parallel
        """
        this = _PreProc.new_Parallel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PreProc.delete_Parallel
    __del__ = lambda self : None;
    def get_num_cpus(*args):
        """get_num_cpus(self) ->  int"""
        return _PreProc.Parallel_get_num_cpus(*args)

    def set_num_threads(*args):
        """set_num_threads(self, n)"""
        return _PreProc.Parallel_set_num_threads(*args)

    def get_num_threads(*args):
        """get_num_threads(self) ->  int"""
        return _PreProc.Parallel_get_num_threads(*args)

    def ref(*args):
        """ref(self) ->  int"""
        return _PreProc.Parallel_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _PreProc.Parallel_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _PreProc.Parallel_unref(*args)

Parallel_swigregister = _PreProc.Parallel_swigregister
Parallel_swigregister(Parallel)

class PySwigIterator(_object):
    """Proxy of C++ PySwigIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _PreProc.delete_PySwigIterator
    __del__ = lambda self : None;
    def value(*args):
        """value(self) -> PyObject"""
        return _PreProc.PySwigIterator_value(*args)

    def incr(*args):
        """
        incr(self, n=1) -> PySwigIterator
        incr(self) -> PySwigIterator
        """
        return _PreProc.PySwigIterator_incr(*args)

    def decr(*args):
        """
        decr(self, n=1) -> PySwigIterator
        decr(self) -> PySwigIterator
        """
        return _PreProc.PySwigIterator_decr(*args)

    def distance(*args):
        """distance(self, x) -> ptrdiff_t"""
        return _PreProc.PySwigIterator_distance(*args)

    def equal(*args):
        """equal(self, x) -> bool"""
        return _PreProc.PySwigIterator_equal(*args)

    def copy(*args):
        """copy(self) -> PySwigIterator"""
        return _PreProc.PySwigIterator_copy(*args)

    def next(*args):
        """next(self) -> PyObject"""
        return _PreProc.PySwigIterator_next(*args)

    def previous(*args):
        """previous(self) -> PyObject"""
        return _PreProc.PySwigIterator_previous(*args)

    def advance(*args):
        """advance(self, n) -> PySwigIterator"""
        return _PreProc.PySwigIterator_advance(*args)

    def __eq__(*args):
        """__eq__(self, x) -> bool"""
        return _PreProc.PySwigIterator___eq__(*args)

    def __ne__(*args):
        """__ne__(self, x) -> bool"""
        return _PreProc.PySwigIterator___ne__(*args)

    def __iadd__(*args):
        """__iadd__(self, n) -> PySwigIterator"""
        return _PreProc.PySwigIterator___iadd__(*args)

    def __isub__(*args):
        """__isub__(self, n) -> PySwigIterator"""
        return _PreProc.PySwigIterator___isub__(*args)

    def __add__(*args):
        """__add__(self, n) -> PySwigIterator"""
        return _PreProc.PySwigIterator___add__(*args)

    def __sub__(*args):
        """
        __sub__(self, n) -> PySwigIterator
        __sub__(self, x) -> ptrdiff_t
        """
        return _PreProc.PySwigIterator___sub__(*args)

    def __iter__(self): return self
PySwigIterator_swigregister = _PreProc.PySwigIterator_swigregister
PySwigIterator_swigregister(PySwigIterator)

class IntVector(_object):
    """Proxy of C++ IntVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _PreProc.IntVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _PreProc.IntVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(int)>::size_type"""
        return _PreProc.IntVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(int)>::value_type"""
        return _PreProc.IntVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> IntVector"""
        return _PreProc.IntVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _PreProc.IntVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _PreProc.IntVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _PreProc.IntVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(int)>::value_type"""
        return _PreProc.IntVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _PreProc.IntVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _PreProc.IntVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _PreProc.IntVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(int)>::size_type"""
        return _PreProc.IntVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _PreProc.IntVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _PreProc.IntVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(int)>::allocator_type"""
        return _PreProc.IntVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(int)>::const_iterator"""
        return _PreProc.IntVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(int)>::const_iterator"""
        return _PreProc.IntVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _PreProc.IntVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _PreProc.IntVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _PreProc.IntVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(int)>::iterator
        erase(self, first, last) -> std::vector<(int)>::iterator
        """
        return _PreProc.IntVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> IntVector
        __init__(self, ?) -> IntVector
        __init__(self, size) -> IntVector
        __init__(self, size, value) -> IntVector
        """
        this = _PreProc.new_IntVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _PreProc.IntVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(int)>::value_type"""
        return _PreProc.IntVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(int)>::value_type"""
        return _PreProc.IntVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _PreProc.IntVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _PreProc.IntVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(int)>::iterator
        insert(self, pos, n, x)
        """
        return _PreProc.IntVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _PreProc.IntVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(int)>::size_type"""
        return _PreProc.IntVector_capacity(*args)

    __swig_destroy__ = _PreProc.delete_IntVector
    __del__ = lambda self : None;
IntVector_swigregister = _PreProc.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(_object):
    """Proxy of C++ DoubleVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _PreProc.DoubleVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _PreProc.DoubleVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(double)>::size_type"""
        return _PreProc.DoubleVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(double)>::value_type"""
        return _PreProc.DoubleVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> DoubleVector"""
        return _PreProc.DoubleVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _PreProc.DoubleVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _PreProc.DoubleVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _PreProc.DoubleVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(double)>::value_type"""
        return _PreProc.DoubleVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _PreProc.DoubleVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _PreProc.DoubleVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _PreProc.DoubleVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(double)>::size_type"""
        return _PreProc.DoubleVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _PreProc.DoubleVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _PreProc.DoubleVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(double)>::allocator_type"""
        return _PreProc.DoubleVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(double)>::const_iterator"""
        return _PreProc.DoubleVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(double)>::const_iterator"""
        return _PreProc.DoubleVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _PreProc.DoubleVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _PreProc.DoubleVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _PreProc.DoubleVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(double)>::iterator
        erase(self, first, last) -> std::vector<(double)>::iterator
        """
        return _PreProc.DoubleVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> DoubleVector
        __init__(self, ?) -> DoubleVector
        __init__(self, size) -> DoubleVector
        __init__(self, size, value) -> DoubleVector
        """
        this = _PreProc.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _PreProc.DoubleVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(double)>::value_type"""
        return _PreProc.DoubleVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(double)>::value_type"""
        return _PreProc.DoubleVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _PreProc.DoubleVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _PreProc.DoubleVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(double)>::iterator
        insert(self, pos, n, x)
        """
        return _PreProc.DoubleVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _PreProc.DoubleVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(double)>::size_type"""
        return _PreProc.DoubleVector_capacity(*args)

    __swig_destroy__ = _PreProc.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _PreProc.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

P_UNKNOWN = _PreProc.P_UNKNOWN
P_NORMONE = _PreProc.P_NORMONE
P_LOGPLUSONE = _PreProc.P_LOGPLUSONE
P_SORTWORDSTRING = _PreProc.P_SORTWORDSTRING
P_SORTULONGSTRING = _PreProc.P_SORTULONGSTRING
P_SORTWORD = _PreProc.P_SORTWORD
P_PRUNEVARSUBMEAN = _PreProc.P_PRUNEVARSUBMEAN
P_DECOMPRESSCHARSTRING = _PreProc.P_DECOMPRESSCHARSTRING
P_DECOMPRESSBYTESTRING = _PreProc.P_DECOMPRESSBYTESTRING
P_DECOMPRESSWORDSTRING = _PreProc.P_DECOMPRESSWORDSTRING
P_DECOMPRESSULONGSTRING = _PreProc.P_DECOMPRESSULONGSTRING
class PreProc(SGObject):
    """
    Class PreProc defines a preprocessor interface.

    Preprocessors are transformation functions that don't change the
    domain of the input features. These functions can be applied in-place
    if the input features fit in memory or can be applied on-the-fly when
    (depending on features) a feature caching strategy is applied.
    However, if the individual features are in $\\bf{R}$ they have to
    stay in $\\bf{R}$ although the dimensionality of the feature vectors
    is allowed change.

    As preprocessors might need a certain initialization they may expect
    that the init() function is called before anything else. The actual
    preprocessing is feature type dependent and thus coordinated in the
    sub-classes, cf. e.g. CSimplePreProc .

    C++ includes: PreProc.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PreProc, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PreProc, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _PreProc.delete_PreProc
    __del__ = lambda self : None;
    def init(*args):
        """
        init(self, f) -> bool

        initialize preprocessor from features 
        """
        return _PreProc.PreProc_init(*args)

    def cleanup(*args):
        """
        cleanup(self)

        cleanup 
        """
        return _PreProc.PreProc_cleanup(*args)

    def get_feature_type(*args):
        """
        get_feature_type(self) -> EFeatureType

        return feature type with which objects derived from CPreProc can deal

        """
        return _PreProc.PreProc_get_feature_type(*args)

    def get_feature_class(*args):
        """
        get_feature_class(self) -> EFeatureClass

        return feature class like Sparse,Simple,... 
        """
        return _PreProc.PreProc_get_feature_class(*args)

    def get_id(*args):
        """
        get_id(self) -> str

        return a FOUR letter id of the preprocessor 
        """
        return _PreProc.PreProc_get_id(*args)

PreProc_swigregister = _PreProc.PreProc_swigregister
PreProc_swigregister(PreProc)

class SimpleRealPreProc(PreProc):
    """
    Template class SimplePreProc, base class for preprocessors (cf.
    CPreProc) that apply to CSimpleFeatures (i.e. rectangular dense
    matrices).

    Two new functions apply_to_feature_vector() and
    apply_to_feature_matrix() are defined in this interface that need to
    be implemented in each particular preprocessor operating on
    CSimpleFeatures. For examples see e.g. CLogPlusOne or CPCACut.

    C++ includes: SimplePreProc.h 
    """
    __swig_setmethods__ = {}
    for _s in [PreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimpleRealPreProc, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SimpleRealPreProc, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    def apply_to_feature_matrix(*args):
        """
        apply_to_feature_matrix(self, f) -> float

        apply preproc on feature matrix result in feature matrix return
        pointer to feature_matrix, i.e. f->get_feature_matrix(); 
        """
        return _PreProc.SimpleRealPreProc_apply_to_feature_matrix(*args)

    def apply_to_feature_vector(*args):
        """
        apply_to_feature_vector(self, f, len) -> float

        apply preproc on single feature vector result in feature matrix 
        """
        return _PreProc.SimpleRealPreProc_apply_to_feature_vector(*args)

    __swig_destroy__ = _PreProc.delete_SimpleRealPreProc
    __del__ = lambda self : None;
SimpleRealPreProc_swigregister = _PreProc.SimpleRealPreProc_swigregister
SimpleRealPreProc_swigregister(SimpleRealPreProc)

class SimpleUlongPreProc(PreProc):
    """
    Template class SimplePreProc, base class for preprocessors (cf.
    CPreProc) that apply to CSimpleFeatures (i.e. rectangular dense
    matrices).

    Two new functions apply_to_feature_vector() and
    apply_to_feature_matrix() are defined in this interface that need to
    be implemented in each particular preprocessor operating on
    CSimpleFeatures. For examples see e.g. CLogPlusOne or CPCACut.

    C++ includes: SimplePreProc.h 
    """
    __swig_setmethods__ = {}
    for _s in [PreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimpleUlongPreProc, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SimpleUlongPreProc, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    def apply_to_feature_matrix(*args):
        """
        apply_to_feature_matrix(self, f) -> unsigned long long

        apply preproc on feature matrix result in feature matrix return
        pointer to feature_matrix, i.e. f->get_feature_matrix(); 
        """
        return _PreProc.SimpleUlongPreProc_apply_to_feature_matrix(*args)

    def apply_to_feature_vector(*args):
        """
        apply_to_feature_vector(self, f, len) -> unsigned long long

        apply preproc on single feature vector result in feature matrix 
        """
        return _PreProc.SimpleUlongPreProc_apply_to_feature_vector(*args)

    __swig_destroy__ = _PreProc.delete_SimpleUlongPreProc
    __del__ = lambda self : None;
SimpleUlongPreProc_swigregister = _PreProc.SimpleUlongPreProc_swigregister
SimpleUlongPreProc_swigregister(SimpleUlongPreProc)

class SimpleWordPreProc(PreProc):
    """
    Template class SimplePreProc, base class for preprocessors (cf.
    CPreProc) that apply to CSimpleFeatures (i.e. rectangular dense
    matrices).

    Two new functions apply_to_feature_vector() and
    apply_to_feature_matrix() are defined in this interface that need to
    be implemented in each particular preprocessor operating on
    CSimpleFeatures. For examples see e.g. CLogPlusOne or CPCACut.

    C++ includes: SimplePreProc.h 
    """
    __swig_setmethods__ = {}
    for _s in [PreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimpleWordPreProc, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SimpleWordPreProc, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    def apply_to_feature_matrix(*args):
        """
        apply_to_feature_matrix(self, f) -> unsigned short

        apply preproc on feature matrix result in feature matrix return
        pointer to feature_matrix, i.e. f->get_feature_matrix(); 
        """
        return _PreProc.SimpleWordPreProc_apply_to_feature_matrix(*args)

    def apply_to_feature_vector(*args):
        """
        apply_to_feature_vector(self, f, len) -> unsigned short

        apply preproc on single feature vector result in feature matrix 
        """
        return _PreProc.SimpleWordPreProc_apply_to_feature_vector(*args)

    __swig_destroy__ = _PreProc.delete_SimpleWordPreProc
    __del__ = lambda self : None;
SimpleWordPreProc_swigregister = _PreProc.SimpleWordPreProc_swigregister
SimpleWordPreProc_swigregister(SimpleWordPreProc)

class SimpleShortPreProc(PreProc):
    """
    Template class SimplePreProc, base class for preprocessors (cf.
    CPreProc) that apply to CSimpleFeatures (i.e. rectangular dense
    matrices).

    Two new functions apply_to_feature_vector() and
    apply_to_feature_matrix() are defined in this interface that need to
    be implemented in each particular preprocessor operating on
    CSimpleFeatures. For examples see e.g. CLogPlusOne or CPCACut.

    C++ includes: SimplePreProc.h 
    """
    __swig_setmethods__ = {}
    for _s in [PreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimpleShortPreProc, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SimpleShortPreProc, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    def apply_to_feature_matrix(*args):
        """
        apply_to_feature_matrix(self, f) -> short

        apply preproc on feature matrix result in feature matrix return
        pointer to feature_matrix, i.e. f->get_feature_matrix(); 
        """
        return _PreProc.SimpleShortPreProc_apply_to_feature_matrix(*args)

    def apply_to_feature_vector(*args):
        """
        apply_to_feature_vector(self, f, len) -> short

        apply preproc on single feature vector result in feature matrix 
        """
        return _PreProc.SimpleShortPreProc_apply_to_feature_vector(*args)

    __swig_destroy__ = _PreProc.delete_SimpleShortPreProc
    __del__ = lambda self : None;
SimpleShortPreProc_swigregister = _PreProc.SimpleShortPreProc_swigregister
SimpleShortPreProc_swigregister(SimpleShortPreProc)

class SimpleBytePreProc(PreProc):
    """
    Template class SimplePreProc, base class for preprocessors (cf.
    CPreProc) that apply to CSimpleFeatures (i.e. rectangular dense
    matrices).

    Two new functions apply_to_feature_vector() and
    apply_to_feature_matrix() are defined in this interface that need to
    be implemented in each particular preprocessor operating on
    CSimpleFeatures. For examples see e.g. CLogPlusOne or CPCACut.

    C++ includes: SimplePreProc.h 
    """
    __swig_setmethods__ = {}
    for _s in [PreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimpleBytePreProc, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SimpleBytePreProc, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    def apply_to_feature_matrix(*args):
        """
        apply_to_feature_matrix(self, f) -> unsigned str

        apply preproc on feature matrix result in feature matrix return
        pointer to feature_matrix, i.e. f->get_feature_matrix(); 
        """
        return _PreProc.SimpleBytePreProc_apply_to_feature_matrix(*args)

    def apply_to_feature_vector(*args):
        """
        apply_to_feature_vector(self, f, len) -> unsigned str

        apply preproc on single feature vector result in feature matrix 
        """
        return _PreProc.SimpleBytePreProc_apply_to_feature_vector(*args)

    __swig_destroy__ = _PreProc.delete_SimpleBytePreProc
    __del__ = lambda self : None;
SimpleBytePreProc_swigregister = _PreProc.SimpleBytePreProc_swigregister
SimpleBytePreProc_swigregister(SimpleBytePreProc)

class SimpleCharPreProc(PreProc):
    """
    Template class SimplePreProc, base class for preprocessors (cf.
    CPreProc) that apply to CSimpleFeatures (i.e. rectangular dense
    matrices).

    Two new functions apply_to_feature_vector() and
    apply_to_feature_matrix() are defined in this interface that need to
    be implemented in each particular preprocessor operating on
    CSimpleFeatures. For examples see e.g. CLogPlusOne or CPCACut.

    C++ includes: SimplePreProc.h 
    """
    __swig_setmethods__ = {}
    for _s in [PreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimpleCharPreProc, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SimpleCharPreProc, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    def apply_to_feature_matrix(*args):
        """
        apply_to_feature_matrix(self, f) -> str

        apply preproc on feature matrix result in feature matrix return
        pointer to feature_matrix, i.e. f->get_feature_matrix(); 
        """
        return _PreProc.SimpleCharPreProc_apply_to_feature_matrix(*args)

    def apply_to_feature_vector(*args):
        """
        apply_to_feature_vector(self, f, len) -> str

        apply preproc on single feature vector result in feature matrix 
        """
        return _PreProc.SimpleCharPreProc_apply_to_feature_vector(*args)

    __swig_destroy__ = _PreProc.delete_SimpleCharPreProc
    __del__ = lambda self : None;
SimpleCharPreProc_swigregister = _PreProc.SimpleCharPreProc_swigregister
SimpleCharPreProc_swigregister(SimpleCharPreProc)

class StringUlongPreProc(PreProc):
    """
    Template class StringPreProc, base class for preprocessors (cf.
    CPreProc) that apply to CStringFeatures (i.e. strings of variable
    length).

    Two new functions apply_to_string() and apply_to_string_features() are
    defined in this interface that need to be implemented in each
    particular preprocessor operating on CStringFeatures.

    C++ includes: StringPreProc.h 
    """
    __swig_setmethods__ = {}
    for _s in [PreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringUlongPreProc, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StringUlongPreProc, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    def apply_to_string_features(*args):
        """
        apply_to_string_features(self, f) -> bool

        apply preproc on feature matrix result in feature matrix return
        pointer to feature_matrix, i.e. f->get_feature_matrix(); 
        """
        return _PreProc.StringUlongPreProc_apply_to_string_features(*args)

    def apply_to_string(*args):
        """
        apply_to_string(self, f, len) -> unsigned long long

        apply preproc on single feature vector 
        """
        return _PreProc.StringUlongPreProc_apply_to_string(*args)

    __swig_destroy__ = _PreProc.delete_StringUlongPreProc
    __del__ = lambda self : None;
StringUlongPreProc_swigregister = _PreProc.StringUlongPreProc_swigregister
StringUlongPreProc_swigregister(StringUlongPreProc)

class StringWordPreProc(PreProc):
    """
    Template class StringPreProc, base class for preprocessors (cf.
    CPreProc) that apply to CStringFeatures (i.e. strings of variable
    length).

    Two new functions apply_to_string() and apply_to_string_features() are
    defined in this interface that need to be implemented in each
    particular preprocessor operating on CStringFeatures.

    C++ includes: StringPreProc.h 
    """
    __swig_setmethods__ = {}
    for _s in [PreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringWordPreProc, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StringWordPreProc, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    def apply_to_string_features(*args):
        """
        apply_to_string_features(self, f) -> bool

        apply preproc on feature matrix result in feature matrix return
        pointer to feature_matrix, i.e. f->get_feature_matrix(); 
        """
        return _PreProc.StringWordPreProc_apply_to_string_features(*args)

    def apply_to_string(*args):
        """
        apply_to_string(self, f, len) -> unsigned short

        apply preproc on single feature vector 
        """
        return _PreProc.StringWordPreProc_apply_to_string(*args)

    __swig_destroy__ = _PreProc.delete_StringWordPreProc
    __del__ = lambda self : None;
StringWordPreProc_swigregister = _PreProc.StringWordPreProc_swigregister
StringWordPreProc_swigregister(StringWordPreProc)

class StringBytePreProc(PreProc):
    """
    Template class StringPreProc, base class for preprocessors (cf.
    CPreProc) that apply to CStringFeatures (i.e. strings of variable
    length).

    Two new functions apply_to_string() and apply_to_string_features() are
    defined in this interface that need to be implemented in each
    particular preprocessor operating on CStringFeatures.

    C++ includes: StringPreProc.h 
    """
    __swig_setmethods__ = {}
    for _s in [PreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringBytePreProc, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StringBytePreProc, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    def apply_to_string_features(*args):
        """
        apply_to_string_features(self, f) -> bool

        apply preproc on feature matrix result in feature matrix return
        pointer to feature_matrix, i.e. f->get_feature_matrix(); 
        """
        return _PreProc.StringBytePreProc_apply_to_string_features(*args)

    def apply_to_string(*args):
        """
        apply_to_string(self, f, len) -> unsigned str

        apply preproc on single feature vector 
        """
        return _PreProc.StringBytePreProc_apply_to_string(*args)

    __swig_destroy__ = _PreProc.delete_StringBytePreProc
    __del__ = lambda self : None;
StringBytePreProc_swigregister = _PreProc.StringBytePreProc_swigregister
StringBytePreProc_swigregister(StringBytePreProc)

class StringCharPreProc(PreProc):
    """
    Template class StringPreProc, base class for preprocessors (cf.
    CPreProc) that apply to CStringFeatures (i.e. strings of variable
    length).

    Two new functions apply_to_string() and apply_to_string_features() are
    defined in this interface that need to be implemented in each
    particular preprocessor operating on CStringFeatures.

    C++ includes: StringPreProc.h 
    """
    __swig_setmethods__ = {}
    for _s in [PreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringCharPreProc, name, value)
    __swig_getmethods__ = {}
    for _s in [PreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StringCharPreProc, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    def apply_to_string_features(*args):
        """
        apply_to_string_features(self, f) -> bool

        apply preproc on feature matrix result in feature matrix return
        pointer to feature_matrix, i.e. f->get_feature_matrix(); 
        """
        return _PreProc.StringCharPreProc_apply_to_string_features(*args)

    def apply_to_string(*args):
        """
        apply_to_string(self, f, len) -> str

        apply preproc on single feature vector 
        """
        return _PreProc.StringCharPreProc_apply_to_string(*args)

    __swig_destroy__ = _PreProc.delete_StringCharPreProc
    __del__ = lambda self : None;
StringCharPreProc_swigregister = _PreProc.StringCharPreProc_swigregister
StringCharPreProc_swigregister(StringCharPreProc)

class DecompressUlongString(StringUlongPreProc):
    """
    Preprocessor that decompresses compressed strings.

    Each string in CStringFeatures might be stored compressed in memory.
    This preprocessor decompresses these strings on the fly. This may be
    especially usefull for long strings and when datasets become too large
    to fit in memoryin uncompressed form but still when they are
    compressed.

    Then avoiding expensive disk i/o strings are on-the-fly decompressed.

    C++ includes: DecompressString.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringUlongPreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecompressUlongString, name, value)
    __swig_getmethods__ = {}
    for _s in [StringUlongPreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DecompressUlongString, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ct) -> DecompressUlongString

        constructor 
        """
        this = _PreProc.new_DecompressUlongString(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PreProc.delete_DecompressUlongString
    __del__ = lambda self : None;
    def load(*args):
        """
        load(self, f) -> bool

        initialize preprocessor from file 
        """
        return _PreProc.DecompressUlongString_load(*args)

    def save(*args):
        """
        save(self, f) -> bool

        save preprocessor init-data to file 
        """
        return _PreProc.DecompressUlongString_save(*args)

DecompressUlongString_swigregister = _PreProc.DecompressUlongString_swigregister
DecompressUlongString_swigregister(DecompressUlongString)

class DecompressWordString(StringWordPreProc):
    """
    Preprocessor that decompresses compressed strings.

    Each string in CStringFeatures might be stored compressed in memory.
    This preprocessor decompresses these strings on the fly. This may be
    especially usefull for long strings and when datasets become too large
    to fit in memoryin uncompressed form but still when they are
    compressed.

    Then avoiding expensive disk i/o strings are on-the-fly decompressed.

    C++ includes: DecompressString.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringWordPreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecompressWordString, name, value)
    __swig_getmethods__ = {}
    for _s in [StringWordPreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DecompressWordString, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ct) -> DecompressWordString

        constructor 
        """
        this = _PreProc.new_DecompressWordString(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PreProc.delete_DecompressWordString
    __del__ = lambda self : None;
    def load(*args):
        """
        load(self, f) -> bool

        initialize preprocessor from file 
        """
        return _PreProc.DecompressWordString_load(*args)

    def save(*args):
        """
        save(self, f) -> bool

        save preprocessor init-data to file 
        """
        return _PreProc.DecompressWordString_save(*args)

DecompressWordString_swigregister = _PreProc.DecompressWordString_swigregister
DecompressWordString_swigregister(DecompressWordString)

class DecompressByteString(StringBytePreProc):
    """
    Preprocessor that decompresses compressed strings.

    Each string in CStringFeatures might be stored compressed in memory.
    This preprocessor decompresses these strings on the fly. This may be
    especially usefull for long strings and when datasets become too large
    to fit in memoryin uncompressed form but still when they are
    compressed.

    Then avoiding expensive disk i/o strings are on-the-fly decompressed.

    C++ includes: DecompressString.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringBytePreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecompressByteString, name, value)
    __swig_getmethods__ = {}
    for _s in [StringBytePreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DecompressByteString, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ct) -> DecompressByteString

        constructor 
        """
        this = _PreProc.new_DecompressByteString(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PreProc.delete_DecompressByteString
    __del__ = lambda self : None;
    def load(*args):
        """
        load(self, f) -> bool

        initialize preprocessor from file 
        """
        return _PreProc.DecompressByteString_load(*args)

    def save(*args):
        """
        save(self, f) -> bool

        save preprocessor init-data to file 
        """
        return _PreProc.DecompressByteString_save(*args)

DecompressByteString_swigregister = _PreProc.DecompressByteString_swigregister
DecompressByteString_swigregister(DecompressByteString)

class DecompressCharString(StringCharPreProc):
    """
    Preprocessor that decompresses compressed strings.

    Each string in CStringFeatures might be stored compressed in memory.
    This preprocessor decompresses these strings on the fly. This may be
    especially usefull for long strings and when datasets become too large
    to fit in memoryin uncompressed form but still when they are
    compressed.

    Then avoiding expensive disk i/o strings are on-the-fly decompressed.

    C++ includes: DecompressString.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringCharPreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DecompressCharString, name, value)
    __swig_getmethods__ = {}
    for _s in [StringCharPreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DecompressCharString, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, ct) -> DecompressCharString

        constructor 
        """
        this = _PreProc.new_DecompressCharString(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PreProc.delete_DecompressCharString
    __del__ = lambda self : None;
    def load(*args):
        """
        load(self, f) -> bool

        initialize preprocessor from file 
        """
        return _PreProc.DecompressCharString_load(*args)

    def save(*args):
        """
        save(self, f) -> bool

        save preprocessor init-data to file 
        """
        return _PreProc.DecompressCharString_save(*args)

DecompressCharString_swigregister = _PreProc.DecompressCharString_swigregister
DecompressCharString_swigregister(DecompressCharString)

class LogPlusOne(SimpleRealPreProc):
    """
    Preprocessor LogPlusOne does what the name says, it adds one to a
    dense real valued vector and takes the logarithm of each component of
    it.

    \\[ {\\bf x}\\leftarrow \\log({\\bf x}+{\\bf 1} \\] It
    therefore does not need any initialization. It is most useful in
    situations where the inputs are counts: When one compares differences
    of small counts any difference may matter a lot, while small
    differences in large counts don't. This is what this log
    transformation controls for.

    C++ includes: LogPlusOne.h 
    """
    __swig_setmethods__ = {}
    for _s in [SimpleRealPreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LogPlusOne, name, value)
    __swig_getmethods__ = {}
    for _s in [SimpleRealPreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LogPlusOne, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> LogPlusOne

        default constructor 
        """
        this = _PreProc.new_LogPlusOne(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PreProc.delete_LogPlusOne
    __del__ = lambda self : None;
    def load(*args):
        """
        load(self, f) -> bool

        initialize preprocessor from file 
        """
        return _PreProc.LogPlusOne_load(*args)

    def save(*args):
        """
        save(self, f) -> bool

        save preprocessor init-data to file 
        """
        return _PreProc.LogPlusOne_save(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _PreProc.LogPlusOne_get_name(*args)

LogPlusOne_swigregister = _PreProc.LogPlusOne_swigregister
LogPlusOne_swigregister(LogPlusOne)

class NormDerivativeLem3(SimpleRealPreProc):
    """
    Preprocessor NormDerivativeLem3, performs the normalization used in
    Lemma3 in Jaakola Hausslers Fischer Kernel paper currently not
    implemented.

    C++ includes: NormDerivativeLem3.h 
    """
    __swig_setmethods__ = {}
    for _s in [SimpleRealPreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NormDerivativeLem3, name, value)
    __swig_getmethods__ = {}
    for _s in [SimpleRealPreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NormDerivativeLem3, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _PreProc.delete_NormDerivativeLem3
    __del__ = lambda self : None;
    def load(*args):
        """
        load(self, f) -> bool

        initialize preprocessor from file 
        """
        return _PreProc.NormDerivativeLem3_load(*args)

    def save(*args):
        """
        save(self, f) -> bool

        save preprocessor init-data to file 
        """
        return _PreProc.NormDerivativeLem3_save(*args)

    def apply_to_feature_vector(*args):
        """
        apply_to_feature_vector(self, f, len) -> float

        apply preproc on single feature vector result in feature matrix 
        """
        return _PreProc.NormDerivativeLem3_apply_to_feature_vector(*args)

NormDerivativeLem3_swigregister = _PreProc.NormDerivativeLem3_swigregister
NormDerivativeLem3_swigregister(NormDerivativeLem3)

class NormOne(SimpleRealPreProc):
    """
    Preprocessor NormOne, normalizes vectors to have norm 1.

    Formally, it computes

    \\[ {\\bf x} \\leftarrow \\frac{{\\bf x}}{||{\\bf x}||}
    \\]

    It therefore does not need any initialization. It is most useful to
    get data onto a ball of radius one.

    C++ includes: NormOne.h 
    """
    __swig_setmethods__ = {}
    for _s in [SimpleRealPreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NormOne, name, value)
    __swig_getmethods__ = {}
    for _s in [SimpleRealPreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, NormOne, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> NormOne

        default constructor 
        """
        this = _PreProc.new_NormOne(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PreProc.delete_NormOne
    __del__ = lambda self : None;
    def load(*args):
        """
        load(self, f) -> bool

        initialize preprocessor from file 
        """
        return _PreProc.NormOne_load(*args)

    def save(*args):
        """
        save(self, f) -> bool

        save preprocessor init-data to file 
        """
        return _PreProc.NormOne_save(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _PreProc.NormOne_get_name(*args)

NormOne_swigregister = _PreProc.NormOne_swigregister
NormOne_swigregister(NormOne)

class PCACut(SimpleRealPreProc):
    """Proxy of C++ PCACut class"""
    __swig_setmethods__ = {}
    for _s in [SimpleRealPreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PCACut, name, value)
    __swig_getmethods__ = {}
    for _s in [SimpleRealPreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PCACut, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, do_whitening=0, thresh=1e-6) -> PCACut
        __init__(self, do_whitening=0) -> PCACut
        __init__(self) -> PCACut
        """
        this = _PreProc.new_PCACut(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PreProc.delete_PCACut
    __del__ = lambda self : None;
    def get_name(*args):
        """
        get_name(self) -> str

        return the name of the preprocessor 
        """
        return _PreProc.PCACut_get_name(*args)

PCACut_swigregister = _PreProc.PCACut_swigregister
PCACut_swigregister(PCACut)

class PruneVarSubMean(SimpleRealPreProc):
    """
    Preprocessor PruneVarSubMean will substract the mean and remove
    features that have zero variance.

    It will optionally normalize standard deviation of features to 1 (by
    dividing by standard deviation of the feature)

    C++ includes: PruneVarSubMean.h 
    """
    __swig_setmethods__ = {}
    for _s in [SimpleRealPreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PruneVarSubMean, name, value)
    __swig_getmethods__ = {}
    for _s in [SimpleRealPreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PruneVarSubMean, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, divide=True) -> PruneVarSubMean
        __init__(self) -> PruneVarSubMean

        constructor

        Parameters:
        -----------

        divide:  if division shall be made 
        """
        this = _PreProc.new_PruneVarSubMean(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PreProc.delete_PruneVarSubMean
    __del__ = lambda self : None;
    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _PreProc.PruneVarSubMean_get_name(*args)

PruneVarSubMean_swigregister = _PreProc.PruneVarSubMean_swigregister
PruneVarSubMean_swigregister(PruneVarSubMean)

class SortUlongString(StringUlongPreProc):
    """
    Preprocessor SortUlongString, sorts the indivual strings in ascending
    order.

    This is useful in conjunction with the CCommUlongStringKernel and will
    result in the spectrum kernel. For this to work the strings have to be
    mapped into a binary higher order representation first (cf.
    obtain_from_*() functions in CStringFeatures)

    C++ includes: SortUlongString.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringUlongPreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SortUlongString, name, value)
    __swig_getmethods__ = {}
    for _s in [StringUlongPreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SortUlongString, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> SortUlongString

        default constructor 
        """
        this = _PreProc.new_SortUlongString(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PreProc.delete_SortUlongString
    __del__ = lambda self : None;
    def load(*args):
        """
        load(self, f) -> bool

        initialize preprocessor from file 
        """
        return _PreProc.SortUlongString_load(*args)

    def save(*args):
        """
        save(self, f) -> bool

        save preprocessor init-data to file 
        """
        return _PreProc.SortUlongString_save(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _PreProc.SortUlongString_get_name(*args)

SortUlongString_swigregister = _PreProc.SortUlongString_swigregister
SortUlongString_swigregister(SortUlongString)

class SortWordString(StringWordPreProc):
    """
    Preprocessor SortWordString, sorts the indivual strings in ascending
    order.

    This is useful in conjunction with the CCommWordStringKernel and will
    result in the spectrum kernel. For this to work the strings have to be
    mapped into a binary higher order representation first (cf.
    obtain_from_*() functions in CStringFeatures)

    C++ includes: SortWordString.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringWordPreProc]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SortWordString, name, value)
    __swig_getmethods__ = {}
    for _s in [StringWordPreProc]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SortWordString, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> SortWordString

        default constructor 
        """
        this = _PreProc.new_SortWordString(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PreProc.delete_SortWordString
    __del__ = lambda self : None;
    def load(*args):
        """
        load(self, f) -> bool

        initialize preprocessor from file 
        """
        return _PreProc.SortWordString_load(*args)

    def save(*args):
        """
        save(self, f) -> bool

        save preprocessor init-data to file 
        """
        return _PreProc.SortWordString_save(*args)

    def get_name(*args):
        """
        get_name(self) -> str

        object name 
        """
        return _PreProc.SortWordString_get_name(*args)

SortWordString_swigregister = _PreProc.SortWordString_swigregister
SortWordString_swigregister(SortWordString)



