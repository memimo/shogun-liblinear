# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.
# This file is compatible with both classic and new-style classes.

"""
The `Distribution` module gathers all distributions available in the SHOGUN toolkit.
"""

import _Distribution
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types


class ShogunException(_object):
    """Proxy of C++ ShogunException class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShogunException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ShogunException, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, str) -> ShogunException"""
        this = _Distribution.new_ShogunException(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Distribution.delete_ShogunException
    __del__ = lambda self : None;
    def get_exception_string(*args):
        """get_exception_string(self) -> str"""
        return _Distribution.ShogunException_get_exception_string(*args)

ShogunException_swigregister = _Distribution.ShogunException_swigregister
ShogunException_swigregister(ShogunException)

MSG_GCDEBUG = _Distribution.MSG_GCDEBUG
MSG_DEBUG = _Distribution.MSG_DEBUG
MSG_INFO = _Distribution.MSG_INFO
MSG_NOTICE = _Distribution.MSG_NOTICE
MSG_WARN = _Distribution.MSG_WARN
MSG_ERROR = _Distribution.MSG_ERROR
MSG_CRITICAL = _Distribution.MSG_CRITICAL
MSG_ALERT = _Distribution.MSG_ALERT
MSG_EMERGENCY = _Distribution.MSG_EMERGENCY
MSG_MESSAGEONLY = _Distribution.MSG_MESSAGEONLY
class IO(_object):
    """Proxy of C++ IO class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IO, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IO, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IO
        __init__(self, orig) -> IO
        """
        this = _Distribution.new_IO(*args)
        try: self.this.append(this)
        except: self.this = this
    def set_loglevel(*args):
        """set_loglevel(self, level)"""
        return _Distribution.IO_set_loglevel(*args)

    def get_loglevel(*args):
        """get_loglevel(self) -> EMessageType"""
        return _Distribution.IO_get_loglevel(*args)

    def get_show_progress(*args):
        """get_show_progress(self) -> bool"""
        return _Distribution.IO_get_show_progress(*args)

    def get_show_file_and_line(*args):
        """get_show_file_and_line(self) -> bool"""
        return _Distribution.IO_get_show_file_and_line(*args)

    def message(*args):
        """message(self, prio, file, line, fmt, ?)"""
        return _Distribution.IO_message(*args)

    def progress(*args):
        """
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1)
        progress(self, current_val, min_val=0.0, max_val=1.0)
        progress(self, current_val, min_val=0.0)
        progress(self, current_val)
        """
        return _Distribution.IO_progress(*args)

    def absolute_progress(*args):
        """
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1)
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0)
        absolute_progress(self, current_val, val, min_val=0.0)
        absolute_progress(self, current_val, val)
        """
        return _Distribution.IO_absolute_progress(*args)

    def done(*args):
        """done(self)"""
        return _Distribution.IO_done(*args)

    def not_implemented(*args):
        """not_implemented(self, file, line)"""
        return _Distribution.IO_not_implemented(*args)

    def deprecated(*args):
        """deprecated(self, file, line)"""
        return _Distribution.IO_deprecated(*args)

    def buffered_message(*args):
        """buffered_message(self, prio, fmt, ?)"""
        return _Distribution.IO_buffered_message(*args)

    def skip_spaces(*args):
        """skip_spaces(str) -> str"""
        return _Distribution.IO_skip_spaces(*args)

    if _newclass:skip_spaces = staticmethod(skip_spaces)
    __swig_getmethods__["skip_spaces"] = lambda x: skip_spaces
    def skip_blanks(*args):
        """skip_blanks(str) -> str"""
        return _Distribution.IO_skip_blanks(*args)

    if _newclass:skip_blanks = staticmethod(skip_blanks)
    __swig_getmethods__["skip_blanks"] = lambda x: skip_blanks
    def get_target(*args):
        """get_target(self) -> FILE"""
        return _Distribution.IO_get_target(*args)

    def set_target(*args):
        """set_target(self, target)"""
        return _Distribution.IO_set_target(*args)

    def set_target_to_stderr(*args):
        """set_target_to_stderr(self)"""
        return _Distribution.IO_set_target_to_stderr(*args)

    def set_target_to_stdout(*args):
        """set_target_to_stdout(self)"""
        return _Distribution.IO_set_target_to_stdout(*args)

    def enable_progress(*args):
        """enable_progress(self)"""
        return _Distribution.IO_enable_progress(*args)

    def disable_progress(*args):
        """disable_progress(self)"""
        return _Distribution.IO_disable_progress(*args)

    def enable_file_and_line(*args):
        """enable_file_and_line(self)"""
        return _Distribution.IO_enable_file_and_line(*args)

    def disable_file_and_line(*args):
        """disable_file_and_line(self)"""
        return _Distribution.IO_disable_file_and_line(*args)

    def set_dirname(*args):
        """set_dirname(dirname)"""
        return _Distribution.IO_set_dirname(*args)

    if _newclass:set_dirname = staticmethod(set_dirname)
    __swig_getmethods__["set_dirname"] = lambda x: set_dirname
    def concat_filename(*args):
        """concat_filename(filename) -> str"""
        return _Distribution.IO_concat_filename(*args)

    if _newclass:concat_filename = staticmethod(concat_filename)
    __swig_getmethods__["concat_filename"] = lambda x: concat_filename
    def filter(*args):
        """filter(d) -> int"""
        return _Distribution.IO_filter(*args)

    if _newclass:filter = staticmethod(filter)
    __swig_getmethods__["filter"] = lambda x: filter
    def ref(*args):
        """ref(self) ->  int"""
        return _Distribution.IO_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Distribution.IO_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Distribution.IO_unref(*args)

    def get_name(*args):
        """get_name(self) -> str"""
        return _Distribution.IO_get_name(*args)

    __swig_destroy__ = _Distribution.delete_IO
    __del__ = lambda self : None;
IO_swigregister = _Distribution.IO_swigregister
IO_swigregister(IO)
cvar = _Distribution.cvar

def IO_skip_spaces(*args):
  """IO_skip_spaces(str) -> str"""
  return _Distribution.IO_skip_spaces(*args)

def IO_skip_blanks(*args):
  """IO_skip_blanks(str) -> str"""
  return _Distribution.IO_skip_blanks(*args)

def IO_set_dirname(*args):
  """IO_set_dirname(dirname)"""
  return _Distribution.IO_set_dirname(*args)

def IO_concat_filename(*args):
  """IO_concat_filename(filename) -> str"""
  return _Distribution.IO_concat_filename(*args)

def IO_filter(*args):
  """IO_filter(d) -> int"""
  return _Distribution.IO_filter(*args)

class SGObject(_object):
    """Proxy of C++ SGObject class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SGObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SGObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Distribution.delete_SGObject
    __del__ = lambda self : None;
    def ref(*args):
        """ref(self) ->  int"""
        return _Distribution.SGObject_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Distribution.SGObject_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Distribution.SGObject_unref(*args)

    def get_name(*args):
        """get_name(self) -> str"""
        return _Distribution.SGObject_get_name(*args)

    __swig_setmethods__["io"] = _Distribution.SGObject_io_set
    __swig_getmethods__["io"] = _Distribution.SGObject_io_get
    if _newclass:io = _swig_property(_Distribution.SGObject_io_get, _Distribution.SGObject_io_set)
    __swig_setmethods__["parallel"] = _Distribution.SGObject_parallel_set
    __swig_getmethods__["parallel"] = _Distribution.SGObject_parallel_get
    if _newclass:parallel = _swig_property(_Distribution.SGObject_parallel_get, _Distribution.SGObject_parallel_set)
    __swig_setmethods__["version"] = _Distribution.SGObject_version_set
    __swig_getmethods__["version"] = _Distribution.SGObject_version_get
    if _newclass:version = _swig_property(_Distribution.SGObject_version_get, _Distribution.SGObject_version_set)
SGObject_swigregister = _Distribution.SGObject_swigregister
SGObject_swigregister(SGObject)

class Version(_object):
    """Proxy of C++ Version class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Version, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Version, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self) -> Version"""
        this = _Distribution.new_Version(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Distribution.delete_Version
    __del__ = lambda self : None;
    def print_version(*args):
        """print_version()"""
        return _Distribution.Version_print_version(*args)

    if _newclass:print_version = staticmethod(print_version)
    __swig_getmethods__["print_version"] = lambda x: print_version
    def get_version_extra(*args):
        """get_version_extra() -> str"""
        return _Distribution.Version_get_version_extra(*args)

    if _newclass:get_version_extra = staticmethod(get_version_extra)
    __swig_getmethods__["get_version_extra"] = lambda x: get_version_extra
    def get_version_release(*args):
        """get_version_release() -> str"""
        return _Distribution.Version_get_version_release(*args)

    if _newclass:get_version_release = staticmethod(get_version_release)
    __swig_getmethods__["get_version_release"] = lambda x: get_version_release
    def get_version_revision(*args):
        """get_version_revision() ->  int"""
        return _Distribution.Version_get_version_revision(*args)

    if _newclass:get_version_revision = staticmethod(get_version_revision)
    __swig_getmethods__["get_version_revision"] = lambda x: get_version_revision
    def get_version_year(*args):
        """get_version_year() ->  int"""
        return _Distribution.Version_get_version_year(*args)

    if _newclass:get_version_year = staticmethod(get_version_year)
    __swig_getmethods__["get_version_year"] = lambda x: get_version_year
    def get_version_month(*args):
        """get_version_month() ->  int"""
        return _Distribution.Version_get_version_month(*args)

    if _newclass:get_version_month = staticmethod(get_version_month)
    __swig_getmethods__["get_version_month"] = lambda x: get_version_month
    def get_version_day(*args):
        """get_version_day() ->  int"""
        return _Distribution.Version_get_version_day(*args)

    if _newclass:get_version_day = staticmethod(get_version_day)
    __swig_getmethods__["get_version_day"] = lambda x: get_version_day
    def get_version_hour(*args):
        """get_version_hour() ->  int"""
        return _Distribution.Version_get_version_hour(*args)

    if _newclass:get_version_hour = staticmethod(get_version_hour)
    __swig_getmethods__["get_version_hour"] = lambda x: get_version_hour
    def get_version_minute(*args):
        """get_version_minute() ->  int"""
        return _Distribution.Version_get_version_minute(*args)

    if _newclass:get_version_minute = staticmethod(get_version_minute)
    __swig_getmethods__["get_version_minute"] = lambda x: get_version_minute
    def get_version_in_minutes(*args):
        """get_version_in_minutes() -> int"""
        return _Distribution.Version_get_version_in_minutes(*args)

    if _newclass:get_version_in_minutes = staticmethod(get_version_in_minutes)
    __swig_getmethods__["get_version_in_minutes"] = lambda x: get_version_in_minutes
    def ref(*args):
        """ref(self) ->  int"""
        return _Distribution.Version_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Distribution.Version_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Distribution.Version_unref(*args)

Version_swigregister = _Distribution.Version_swigregister
Version_swigregister(Version)

def Version_print_version(*args):
  """Version_print_version()"""
  return _Distribution.Version_print_version(*args)

def Version_get_version_extra(*args):
  """Version_get_version_extra() -> str"""
  return _Distribution.Version_get_version_extra(*args)

def Version_get_version_release(*args):
  """Version_get_version_release() -> str"""
  return _Distribution.Version_get_version_release(*args)

def Version_get_version_revision(*args):
  """Version_get_version_revision() ->  int"""
  return _Distribution.Version_get_version_revision(*args)

def Version_get_version_year(*args):
  """Version_get_version_year() ->  int"""
  return _Distribution.Version_get_version_year(*args)

def Version_get_version_month(*args):
  """Version_get_version_month() ->  int"""
  return _Distribution.Version_get_version_month(*args)

def Version_get_version_day(*args):
  """Version_get_version_day() ->  int"""
  return _Distribution.Version_get_version_day(*args)

def Version_get_version_hour(*args):
  """Version_get_version_hour() ->  int"""
  return _Distribution.Version_get_version_hour(*args)

def Version_get_version_minute(*args):
  """Version_get_version_minute() ->  int"""
  return _Distribution.Version_get_version_minute(*args)

def Version_get_version_in_minutes(*args):
  """Version_get_version_in_minutes() -> int"""
  return _Distribution.Version_get_version_in_minutes(*args)

class Parallel(_object):
    """Proxy of C++ Parallel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parallel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Parallel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Parallel
        __init__(self, orig) -> Parallel
        """
        this = _Distribution.new_Parallel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Distribution.delete_Parallel
    __del__ = lambda self : None;
    def get_num_cpus(*args):
        """get_num_cpus(self) ->  int"""
        return _Distribution.Parallel_get_num_cpus(*args)

    def set_num_threads(*args):
        """set_num_threads(self, n)"""
        return _Distribution.Parallel_set_num_threads(*args)

    def get_num_threads(*args):
        """get_num_threads(self) ->  int"""
        return _Distribution.Parallel_get_num_threads(*args)

    def ref(*args):
        """ref(self) ->  int"""
        return _Distribution.Parallel_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Distribution.Parallel_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Distribution.Parallel_unref(*args)

Parallel_swigregister = _Distribution.Parallel_swigregister
Parallel_swigregister(Parallel)

class PySwigIterator(_object):
    """Proxy of C++ PySwigIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Distribution.delete_PySwigIterator
    __del__ = lambda self : None;
    def value(*args):
        """value(self) -> PyObject"""
        return _Distribution.PySwigIterator_value(*args)

    def incr(*args):
        """
        incr(self, n=1) -> PySwigIterator
        incr(self) -> PySwigIterator
        """
        return _Distribution.PySwigIterator_incr(*args)

    def decr(*args):
        """
        decr(self, n=1) -> PySwigIterator
        decr(self) -> PySwigIterator
        """
        return _Distribution.PySwigIterator_decr(*args)

    def distance(*args):
        """distance(self, x) -> ptrdiff_t"""
        return _Distribution.PySwigIterator_distance(*args)

    def equal(*args):
        """equal(self, x) -> bool"""
        return _Distribution.PySwigIterator_equal(*args)

    def copy(*args):
        """copy(self) -> PySwigIterator"""
        return _Distribution.PySwigIterator_copy(*args)

    def next(*args):
        """next(self) -> PyObject"""
        return _Distribution.PySwigIterator_next(*args)

    def previous(*args):
        """previous(self) -> PyObject"""
        return _Distribution.PySwigIterator_previous(*args)

    def advance(*args):
        """advance(self, n) -> PySwigIterator"""
        return _Distribution.PySwigIterator_advance(*args)

    def __eq__(*args):
        """__eq__(self, x) -> bool"""
        return _Distribution.PySwigIterator___eq__(*args)

    def __ne__(*args):
        """__ne__(self, x) -> bool"""
        return _Distribution.PySwigIterator___ne__(*args)

    def __iadd__(*args):
        """__iadd__(self, n) -> PySwigIterator"""
        return _Distribution.PySwigIterator___iadd__(*args)

    def __isub__(*args):
        """__isub__(self, n) -> PySwigIterator"""
        return _Distribution.PySwigIterator___isub__(*args)

    def __add__(*args):
        """__add__(self, n) -> PySwigIterator"""
        return _Distribution.PySwigIterator___add__(*args)

    def __sub__(*args):
        """
        __sub__(self, n) -> PySwigIterator
        __sub__(self, x) -> ptrdiff_t
        """
        return _Distribution.PySwigIterator___sub__(*args)

    def __iter__(self): return self
PySwigIterator_swigregister = _Distribution.PySwigIterator_swigregister
PySwigIterator_swigregister(PySwigIterator)

class IntVector(_object):
    """Proxy of C++ IntVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _Distribution.IntVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _Distribution.IntVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(int)>::size_type"""
        return _Distribution.IntVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(int)>::value_type"""
        return _Distribution.IntVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> IntVector"""
        return _Distribution.IntVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _Distribution.IntVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _Distribution.IntVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _Distribution.IntVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(int)>::value_type"""
        return _Distribution.IntVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _Distribution.IntVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _Distribution.IntVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _Distribution.IntVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(int)>::size_type"""
        return _Distribution.IntVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _Distribution.IntVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _Distribution.IntVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(int)>::allocator_type"""
        return _Distribution.IntVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(int)>::const_iterator"""
        return _Distribution.IntVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(int)>::const_iterator"""
        return _Distribution.IntVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _Distribution.IntVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _Distribution.IntVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _Distribution.IntVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(int)>::iterator
        erase(self, first, last) -> std::vector<(int)>::iterator
        """
        return _Distribution.IntVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> IntVector
        __init__(self, ?) -> IntVector
        __init__(self, size) -> IntVector
        __init__(self, size, value) -> IntVector
        """
        this = _Distribution.new_IntVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _Distribution.IntVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(int)>::value_type"""
        return _Distribution.IntVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(int)>::value_type"""
        return _Distribution.IntVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _Distribution.IntVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _Distribution.IntVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(int)>::iterator
        insert(self, pos, n, x)
        """
        return _Distribution.IntVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _Distribution.IntVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(int)>::size_type"""
        return _Distribution.IntVector_capacity(*args)

    __swig_destroy__ = _Distribution.delete_IntVector
    __del__ = lambda self : None;
IntVector_swigregister = _Distribution.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(_object):
    """Proxy of C++ DoubleVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _Distribution.DoubleVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _Distribution.DoubleVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(double)>::size_type"""
        return _Distribution.DoubleVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(double)>::value_type"""
        return _Distribution.DoubleVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> DoubleVector"""
        return _Distribution.DoubleVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _Distribution.DoubleVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _Distribution.DoubleVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _Distribution.DoubleVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(double)>::value_type"""
        return _Distribution.DoubleVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _Distribution.DoubleVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _Distribution.DoubleVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _Distribution.DoubleVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(double)>::size_type"""
        return _Distribution.DoubleVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _Distribution.DoubleVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _Distribution.DoubleVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(double)>::allocator_type"""
        return _Distribution.DoubleVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(double)>::const_iterator"""
        return _Distribution.DoubleVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(double)>::const_iterator"""
        return _Distribution.DoubleVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _Distribution.DoubleVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _Distribution.DoubleVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _Distribution.DoubleVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(double)>::iterator
        erase(self, first, last) -> std::vector<(double)>::iterator
        """
        return _Distribution.DoubleVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> DoubleVector
        __init__(self, ?) -> DoubleVector
        __init__(self, size) -> DoubleVector
        __init__(self, size, value) -> DoubleVector
        """
        this = _Distribution.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _Distribution.DoubleVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(double)>::value_type"""
        return _Distribution.DoubleVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(double)>::value_type"""
        return _Distribution.DoubleVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _Distribution.DoubleVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _Distribution.DoubleVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(double)>::iterator
        insert(self, pos, n, x)
        """
        return _Distribution.DoubleVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _Distribution.DoubleVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(double)>::size_type"""
        return _Distribution.DoubleVector_capacity(*args)

    __swig_destroy__ = _Distribution.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _Distribution.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class Distribution(SGObject):
    """
    Base class Distribution from which all methods implementing a
    distribution are derived.

    Distributions are based on some general feature object and have to
    implement interfaces to

    train() - for learning a distribution get_num_model_parameters() - for
    the total number of model parameters get_log_model_parameter() - for
    the n-th model parameter (logarithmic) get_log_derivative() - for the
    partial derivative wrt. to the n-th model parameter
    get_log_likelihood_example() - for the likelihood for the n-th example

    This way methods building on CDistribution, might enumerate over all
    possible model parameters and obtain the parameter vector and the
    gradient. This is used to compute e.g. the TOP and Fisher Kernel (cf.
    CPluginEstimate, CHistogramKernel, CTOPFeatures and CFKFeatures ).

    C++ includes: Distribution.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Distribution, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Distribution, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Distribution.delete_Distribution
    __del__ = lambda self : None;
    def train(*args):
        """
        train(self, data=None) -> bool
        train(self) -> bool

        learn distribution

        Parameters:
        -----------

        data:  training data (parameter can be avoided if distance or kernel-
        based classifiers are used and distance/kernels are initialized with
        train data)

        whether training was successful 
        """
        return _Distribution.Distribution_train(*args)

    def get_num_model_parameters(*args):
        """
        get_num_model_parameters(self) ->  int

        get number of parameters in model

        abstract base method

        number of parameters in model 
        """
        return _Distribution.Distribution_get_num_model_parameters(*args)

    def get_num_relevant_model_parameters(*args):
        """
        get_num_relevant_model_parameters(self) ->  int

        get number of parameters in model that are relevant, i.e. >
        ALMOST_NEG_INFTY

        number of relevant model parameters 
        """
        return _Distribution.Distribution_get_num_relevant_model_parameters(*args)

    def get_log_model_parameter(*args):
        """
        get_log_model_parameter(self, num_param) -> float

        get model parameter (logarithmic)

        abstrac base method

        model parameter (logarithmic) 
        """
        return _Distribution.Distribution_get_log_model_parameter(*args)

    def get_log_derivative(*args):
        """
        get_log_derivative(self, num_param, num_example) -> float

        get partial derivative of likelihood function (logarithmic)

        abstract base method

        Parameters:
        -----------

        num_param:  derivative against which param

        num_example:  which example

        derivative of likelihood (logarithmic) 
        """
        return _Distribution.Distribution_get_log_derivative(*args)

    def get_log_likelihood_example(*args):
        """
        get_log_likelihood_example(self, num_example) -> float

        compute log likelihood for example

        abstract base method

        Parameters:
        -----------

        num_example:  which example

        log likelihood for example 
        """
        return _Distribution.Distribution_get_log_likelihood_example(*args)

    def get_log_likelihood_sample(*args):
        """
        get_log_likelihood_sample(self) -> float

        compute log likelihood for whole sample

        log likelihood for whole sample 
        """
        return _Distribution.Distribution_get_log_likelihood_sample(*args)

    def get_log_likelihood(*args):
        """
        get_log_likelihood(self) -> numpy 1dim array of float

        compute log likelihood for each example

        Parameters:
        -----------

        dst:  where likelihood will be stored

        num:  where number of likelihoods will be stored 
        """
        return _Distribution.Distribution_get_log_likelihood(*args)

    def get_model_parameter(*args):
        """
        get_model_parameter(self, num_param) -> float

        get model parameter

        Parameters:
        -----------

        num_param:  which param

        model parameter 
        """
        return _Distribution.Distribution_get_model_parameter(*args)

    def get_derivative(*args):
        """
        get_derivative(self, num_param, num_example) -> float

        get partial derivative of likelihood function

        Parameters:
        -----------

        num_param:  partial derivative against which param

        num_example:  which example

        derivative of likelihood function 
        """
        return _Distribution.Distribution_get_derivative(*args)

    def get_likelihood_example(*args):
        """
        get_likelihood_example(self, num_example) -> float

        compute likelihood for example

        Parameters:
        -----------

        num_example:  which example

        likelihood for example 
        """
        return _Distribution.Distribution_get_likelihood_example(*args)

    def set_features(*args):
        """
        set_features(self, f)

        set feature vectors

        Parameters:
        -----------

        f:  new feature vectors 
        """
        return _Distribution.Distribution_set_features(*args)

    def get_features(*args):
        """
        get_features(self) -> Features

        get feature vectors

        feature vectors 
        """
        return _Distribution.Distribution_get_features(*args)

    def set_pseudo_count(*args):
        """
        set_pseudo_count(self, pseudo)

        set pseudo count

        Parameters:
        -----------

        pseudo:  new pseudo count 
        """
        return _Distribution.Distribution_set_pseudo_count(*args)

    def get_pseudo_count(*args):
        """
        get_pseudo_count(self) -> float

        get pseudo count

        pseudo count 
        """
        return _Distribution.Distribution_get_pseudo_count(*args)

Distribution_swigregister = _Distribution.Distribution_swigregister
Distribution_swigregister(Distribution)

class Histogram(Distribution):
    """
    Class Histogram computes a histogram over all 16bit unsigned integers
    in the features.

    Values in histogram are absolute counts (logarithmic)

    C++ includes: Histogram.h 
    """
    __swig_setmethods__ = {}
    for _s in [Distribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Histogram, name, value)
    __swig_getmethods__ = {}
    for _s in [Distribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Histogram, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Histogram
        __init__(self, f) -> Histogram

        constructor

        Parameters:
        -----------

        f:  histogram's features 
        """
        this = _Distribution.new_Histogram(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Distribution.delete_Histogram
    __del__ = lambda self : None;
    def train(*args):
        """
        train(self, data=None) -> bool
        train(self) -> bool

        learn distribution

        Parameters:
        -----------

        data:  training data (parameter can be avoided if distance or kernel-
        based classifiers are used and distance/kernels are initialized with
        train data)

        whether training was successful 
        """
        return _Distribution.Histogram_train(*args)

    def set_histogram(*args):
        """
        set_histogram(self, src) -> bool

        set histogram

        Parameters:
        -----------

        src:  new histogram

        num:  number of values in histogram 
        """
        return _Distribution.Histogram_set_histogram(*args)

    def get_histogram(*args):
        """
        get_histogram(self) -> numpy 1dim array of float

        get histogram

        Parameters:
        -----------

        dst:  where the histogram will be stored

        num:  where number of values in histogram will be stored 
        """
        return _Distribution.Histogram_get_histogram(*args)

Histogram_swigregister = _Distribution.Histogram_swigregister
Histogram_swigregister(Histogram)

USE_HMMPARALLEL_STRUCTURES = _Distribution.USE_HMMPARALLEL_STRUCTURES
class T_ALPHA_BETA(_object):
    """
    type for alpha/beta table

    C++ includes: HMM.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, T_ALPHA_BETA, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, T_ALPHA_BETA, name)
    __repr__ = _swig_repr
    __swig_setmethods__["dimension"] = _Distribution.T_ALPHA_BETA_dimension_set
    __swig_getmethods__["dimension"] = _Distribution.T_ALPHA_BETA_dimension_get
    if _newclass:dimension = _swig_property(_Distribution.T_ALPHA_BETA_dimension_get, _Distribution.T_ALPHA_BETA_dimension_set)
    __swig_setmethods__["table"] = _Distribution.T_ALPHA_BETA_table_set
    __swig_getmethods__["table"] = _Distribution.T_ALPHA_BETA_table_get
    if _newclass:table = _swig_property(_Distribution.T_ALPHA_BETA_table_get, _Distribution.T_ALPHA_BETA_table_set)
    __swig_setmethods__["updated"] = _Distribution.T_ALPHA_BETA_updated_set
    __swig_getmethods__["updated"] = _Distribution.T_ALPHA_BETA_updated_get
    if _newclass:updated = _swig_property(_Distribution.T_ALPHA_BETA_updated_get, _Distribution.T_ALPHA_BETA_updated_set)
    __swig_setmethods__["sum"] = _Distribution.T_ALPHA_BETA_sum_set
    __swig_getmethods__["sum"] = _Distribution.T_ALPHA_BETA_sum_get
    if _newclass:sum = _swig_property(_Distribution.T_ALPHA_BETA_sum_get, _Distribution.T_ALPHA_BETA_sum_set)
    def __init__(self, *args): 
        """__init__(self) -> T_ALPHA_BETA"""
        this = _Distribution.new_T_ALPHA_BETA(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Distribution.delete_T_ALPHA_BETA
    __del__ = lambda self : None;
T_ALPHA_BETA_swigregister = _Distribution.T_ALPHA_BETA_swigregister
T_ALPHA_BETA_swigregister(T_ALPHA_BETA)

BW_NORMAL = _Distribution.BW_NORMAL
BW_TRANS = _Distribution.BW_TRANS
BW_DEFINED = _Distribution.BW_DEFINED
VIT_NORMAL = _Distribution.VIT_NORMAL
VIT_DEFINED = _Distribution.VIT_DEFINED
class Model(_object):
    """
    class Model

    C++ includes: HMM.h 
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Model, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Model, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Model

        Constructor - initializes all variables/structures. 
        """
        this = _Distribution.new_Model(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Distribution.delete_Model
    __del__ = lambda self : None;
    def sort_learn_a(*args):
        """
        sort_learn_a(self)

        sorts learn_a matrix 
        """
        return _Distribution.Model_sort_learn_a(*args)

    def sort_learn_b(*args):
        """
        sort_learn_b(self)

        sorts learn_b matrix 
        """
        return _Distribution.Model_sort_learn_b(*args)

    def get_learn_a(*args):
        """
        get_learn_a(self, line, column) ->  int

        get entry out of learn_a matrix 
        """
        return _Distribution.Model_get_learn_a(*args)

    def get_learn_b(*args):
        """
        get_learn_b(self, line, column) ->  int

        get entry out of learn_b matrix 
        """
        return _Distribution.Model_get_learn_b(*args)

    def get_learn_p(*args):
        """
        get_learn_p(self, offset) ->  int

        get entry out of learn_p vector 
        """
        return _Distribution.Model_get_learn_p(*args)

    def get_learn_q(*args):
        """
        get_learn_q(self, offset) ->  int

        get entry out of learn_q vector 
        """
        return _Distribution.Model_get_learn_q(*args)

    def get_const_a(*args):
        """
        get_const_a(self, line, column) ->  int

        get entry out of const_a matrix 
        """
        return _Distribution.Model_get_const_a(*args)

    def get_const_b(*args):
        """
        get_const_b(self, line, column) ->  int

        get entry out of const_b matrix 
        """
        return _Distribution.Model_get_const_b(*args)

    def get_const_p(*args):
        """
        get_const_p(self, offset) ->  int

        get entry out of const_p vector 
        """
        return _Distribution.Model_get_const_p(*args)

    def get_const_q(*args):
        """
        get_const_q(self, offset) ->  int

        get entry out of const_q vector 
        """
        return _Distribution.Model_get_const_q(*args)

    def get_const_a_val(*args):
        """
        get_const_a_val(self, line) -> float

        get value out of const_a_val vector 
        """
        return _Distribution.Model_get_const_a_val(*args)

    def get_const_b_val(*args):
        """
        get_const_b_val(self, line) -> float

        get value out of const_b_val vector 
        """
        return _Distribution.Model_get_const_b_val(*args)

    def get_const_p_val(*args):
        """
        get_const_p_val(self, offset) -> float

        get value out of const_p_val vector 
        """
        return _Distribution.Model_get_const_p_val(*args)

    def get_const_q_val(*args):
        """
        get_const_q_val(self, offset) -> float

        get value out of const_q_val vector 
        """
        return _Distribution.Model_get_const_q_val(*args)

    def set_learn_a(*args):
        """
        set_learn_a(self, offset, value)

        set value in learn_a matrix 
        """
        return _Distribution.Model_set_learn_a(*args)

    def set_learn_b(*args):
        """
        set_learn_b(self, offset, value)

        set value in learn_b matrix 
        """
        return _Distribution.Model_set_learn_b(*args)

    def set_learn_p(*args):
        """
        set_learn_p(self, offset, value)

        set value in learn_p vector 
        """
        return _Distribution.Model_set_learn_p(*args)

    def set_learn_q(*args):
        """
        set_learn_q(self, offset, value)

        set value in learn_q vector 
        """
        return _Distribution.Model_set_learn_q(*args)

    def set_const_a(*args):
        """
        set_const_a(self, offset, value)

        set value in const_a matrix 
        """
        return _Distribution.Model_set_const_a(*args)

    def set_const_b(*args):
        """
        set_const_b(self, offset, value)

        set value in const_b matrix 
        """
        return _Distribution.Model_set_const_b(*args)

    def set_const_p(*args):
        """
        set_const_p(self, offset, value)

        set value in const_p vector 
        """
        return _Distribution.Model_set_const_p(*args)

    def set_const_q(*args):
        """
        set_const_q(self, offset, value)

        set value in const_q vector 
        """
        return _Distribution.Model_set_const_q(*args)

    def set_const_a_val(*args):
        """
        set_const_a_val(self, offset, value)

        set value in const_a_val vector 
        """
        return _Distribution.Model_set_const_a_val(*args)

    def set_const_b_val(*args):
        """
        set_const_b_val(self, offset, value)

        set value in const_b_val vector 
        """
        return _Distribution.Model_set_const_b_val(*args)

    def set_const_p_val(*args):
        """
        set_const_p_val(self, offset, value)

        set value in const_p_val vector 
        """
        return _Distribution.Model_set_const_p_val(*args)

    def set_const_q_val(*args):
        """
        set_const_q_val(self, offset, value)

        set value in const_q_val vector 
        """
        return _Distribution.Model_set_const_q_val(*args)

Model_swigregister = _Distribution.Model_swigregister
Model_swigregister(Model)

class HMM(Distribution):
    """
    Hidden Markov Model.

    Structure and Function collection. This Class implements a Hidden
    Markov Model. For a tutorial on HMMs see Rabiner et.al A Tutorial on
    Hidden Markov Models and Selected Applications in Speech Recognition,
    1989

    Several functions for tasks such as training,reading/writing models,
    reading observations, calculation of derivatives are supplied.

    C++ includes: HMM.h 
    """
    __swig_setmethods__ = {}
    for _s in [Distribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HMM, name, value)
    __swig_getmethods__ = {}
    for _s in [Distribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HMM, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, N, M, model, PSEUDO) -> HMM
        __init__(self, obs, N, M, PSEUDO) -> HMM
        __init__(self, N, p, q, a) -> HMM
        __init__(self, N, p, q, num_trans, a_trans) -> HMM
        __init__(self, model_file, PSEUDO) -> HMM
        __init__(self, h) -> HMM

        Constructor - Clone model h. 
        """
        this = _Distribution.new_HMM(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Distribution.delete_HMM
    __del__ = lambda self : None;
    def train(*args):
        """
        train(self, data=None) -> bool
        train(self) -> bool

        learn distribution

        Parameters:
        -----------

        data:  training data (parameter can be avoided if distance or kernel-
        based classifiers are used and distance/kernels are initialized with
        train data)

        whether training was successful 
        """
        return _Distribution.HMM_train(*args)

    def initialize(*args):
        """
        initialize(self, model, PSEUDO, model_file=None) -> bool
        initialize(self, model, PSEUDO) -> bool

        initialization function - gets called by constructors.

        Parameters:
        -----------

        model:  model which holds definitions of states to be learned + consts

        PSEUDO:  Pseudo Value

        model_file:  Filehandle to a hmm model file (*.mod) 
        """
        return _Distribution.HMM_initialize(*args)

    def alloc_state_dependend_arrays(*args):
        """
        alloc_state_dependend_arrays(self) -> bool

        allocates memory that depends on N 
        """
        return _Distribution.HMM_alloc_state_dependend_arrays(*args)

    def free_state_dependend_arrays(*args):
        """
        free_state_dependend_arrays(self)

        free memory that depends on N 
        """
        return _Distribution.HMM_free_state_dependend_arrays(*args)

    def forward_comp(*args):
        """
        forward_comp(self, time, state, dimension) -> float

        forward algorithm. calculates Pr[O_0,O_1, ..., O_t, q_time=S_i|
        lambda] for 0<= time <= T-1 Pr[O|lambda] for time > T

        Parameters:
        -----------

        time:  t

        state:  i

        dimension:  dimension of observation (observations are a matrix, where
        a row stands for one dimension i.e. 0_0,O_1,...,O_{T-1} 
        """
        return _Distribution.HMM_forward_comp(*args)

    def forward_comp_old(*args):
        """forward_comp_old(self, time, state, dimension) -> float"""
        return _Distribution.HMM_forward_comp_old(*args)

    def backward_comp(*args):
        """
        backward_comp(self, time, state, dimension) -> float

        backward algorithm. calculates Pr[O_t+1,O_t+2, ..., O_T-1| q_time=S_i,
        lambda] for 0<= time <= T-1 Pr[O|lambda] for time >= T

        Parameters:
        -----------

        time:  t

        state:  i

        dimension:  dimension of observation (observations are a matrix, where
        a row stands for one dimension i.e. 0_0,O_1,...,O_{T-1} 
        """
        return _Distribution.HMM_backward_comp(*args)

    def backward_comp_old(*args):
        """backward_comp_old(self, time, state, dimension) -> float"""
        return _Distribution.HMM_backward_comp_old(*args)

    def best_path(*args):
        """
        best_path(self, dimension) -> float

        calculates probability of best state sequence s_0,...,s_T-1 AND path
        itself using viterbi algorithm. The path can be found in the array
        PATH(dimension)[0..T-1] afterwards

        Parameters:
        -----------

        dimension:  dimension of observation for which the most probable path
        is calculated (observations are a matrix, where a row stands for one
        dimension i.e. 0_0,O_1,...,O_{T-1} 
        """
        return _Distribution.HMM_best_path(*args)

    def get_best_path_state(*args):
        """get_best_path_state(self, dim, t) -> int"""
        return _Distribution.HMM_get_best_path_state(*args)

    def model_probability_comp(*args):
        """
        model_probability_comp(self) -> float

        calculates probability that observations were generated by the model
        using forward algorithm. 
        """
        return _Distribution.HMM_model_probability_comp(*args)

    def model_probability(*args):
        """
        model_probability(self, dimension=-1) -> float
        model_probability(self) -> float

        inline proxy for model probability. 
        """
        return _Distribution.HMM_model_probability(*args)

    def linear_model_probability(*args):
        """
        linear_model_probability(self, dimension) -> float

        calculates likelihood for linear model on observations in MEMORY

        Parameters:
        -----------

        dimension:  dimension for which probability is calculated

        model probability 
        """
        return _Distribution.HMM_linear_model_probability(*args)

    def set_iterations(*args):
        """set_iterations(self, num) -> bool"""
        return _Distribution.HMM_set_iterations(*args)

    def get_iterations(*args):
        """get_iterations(self) ->  int"""
        return _Distribution.HMM_get_iterations(*args)

    def set_epsilon(*args):
        """set_epsilon(self, eps) -> bool"""
        return _Distribution.HMM_set_epsilon(*args)

    def get_epsilon(*args):
        """get_epsilon(self) -> float"""
        return _Distribution.HMM_get_epsilon(*args)

    def baum_welch_viterbi_train(*args):
        """
        baum_welch_viterbi_train(self, type) -> bool

        interface for e.g. GUIHMM to run BaumWelch or Viterbi training

        Parameters:
        -----------

        type:  type of BaumWelch/Viterbi training 
        """
        return _Distribution.HMM_baum_welch_viterbi_train(*args)

    def estimate_model_baum_welch(*args):
        """
        estimate_model_baum_welch(self, train)

        uses baum-welch-algorithm to train a fully connected HMM.

        Parameters:
        -----------

        train:  model from which the new model is estimated 
        """
        return _Distribution.HMM_estimate_model_baum_welch(*args)

    def estimate_model_baum_welch_trans(*args):
        """estimate_model_baum_welch_trans(self, train)"""
        return _Distribution.HMM_estimate_model_baum_welch_trans(*args)

    def ab_buf_comp(*args):
        """ab_buf_comp(self, p_buf, q_buf, a_buf, b_buf, dim)"""
        return _Distribution.HMM_ab_buf_comp(*args)

    def estimate_model_baum_welch_defined(*args):
        """
        estimate_model_baum_welch_defined(self, train)

        uses baum-welch-algorithm to train the defined transitions etc.

        Parameters:
        -----------

        train:  model from which the new model is estimated 
        """
        return _Distribution.HMM_estimate_model_baum_welch_defined(*args)

    def estimate_model_viterbi(*args):
        """
        estimate_model_viterbi(self, train)

        uses viterbi training to train a fully connected HMM

        Parameters:
        -----------

        train:  model from which the new model is estimated 
        """
        return _Distribution.HMM_estimate_model_viterbi(*args)

    def estimate_model_viterbi_defined(*args):
        """
        estimate_model_viterbi_defined(self, train)

        uses viterbi training to train the defined transitions etc.

        Parameters:
        -----------

        train:  model from which the new model is estimated 
        """
        return _Distribution.HMM_estimate_model_viterbi_defined(*args)

    def linear_train(*args):
        """
        linear_train(self, right_align=False) -> bool
        linear_train(self) -> bool

        estimates linear model from observations. 
        """
        return _Distribution.HMM_linear_train(*args)

    def permutation_entropy(*args):
        """
        permutation_entropy(self, window_width, sequence_number) -> bool

        compute permutation entropy 
        """
        return _Distribution.HMM_permutation_entropy(*args)

    def output_model(*args):
        """
        output_model(self, verbose=False)
        output_model(self)

        prints the model parameters on screen.

        Parameters:
        -----------

        verbose:  when false only the model probability will be printed when
        true the whole model will be printed additionally 
        """
        return _Distribution.HMM_output_model(*args)

    def output_model_defined(*args):
        """
        output_model_defined(self, verbose=False)
        output_model_defined(self)

        performs output_model only for the defined transitions etc 
        """
        return _Distribution.HMM_output_model_defined(*args)

    def normalize(*args):
        """
        normalize(self, keep_dead_states=False)
        normalize(self)

        normalize the model to satisfy stochasticity 
        """
        return _Distribution.HMM_normalize(*args)

    def add_states(*args):
        """
        add_states(self, num_states, default_val=0)
        add_states(self, num_states)

        increases the number of states by num_states the new a/b/p/q values
        are given the value default_val where 0<=default_val<=1 
        """
        return _Distribution.HMM_add_states(*args)

    def append_model(*args):
        """
        append_model(self, append_model, cur_out, app_out) -> bool
        append_model(self, append_model) -> bool

        appends the append_model to the current hmm, here no extra states are
        created. former q_i are multiplied by q_ji to give the a_ij from the
        current hmm to the append_model 
        """
        return _Distribution.HMM_append_model(*args)

    def chop(*args):
        """
        chop(self, value)

        set any model parameter with probability smaller than value to ZERO 
        """
        return _Distribution.HMM_chop(*args)

    def convert_to_log(*args):
        """
        convert_to_log(self)

        convert model to log probabilities 
        """
        return _Distribution.HMM_convert_to_log(*args)

    def init_model_random(*args):
        """
        init_model_random(self)

        init model with random values 
        """
        return _Distribution.HMM_init_model_random(*args)

    def init_model_defined(*args):
        """
        init_model_defined(self)

        init model according to const_x, learn_x. first model is initialized
        with 0 for all parameters then parameters in learn_x are initialized
        with random values finally const_x parameters are set and model is
        normalized. 
        """
        return _Distribution.HMM_init_model_defined(*args)

    def clear_model(*args):
        """
        clear_model(self)

        initializes model with log(PSEUDO) 
        """
        return _Distribution.HMM_clear_model(*args)

    def clear_model_defined(*args):
        """
        clear_model_defined(self)

        initializes only parameters in learn_x with log(PSEUDO) 
        """
        return _Distribution.HMM_clear_model_defined(*args)

    def copy_model(*args):
        """
        copy_model(self, l)

        copies the the modelparameters from l 
        """
        return _Distribution.HMM_copy_model(*args)

    def invalidate_model(*args):
        """
        invalidate_model(self)

        invalidates all caches. this function has to be called when direct
        changes to the model have been made. this is necessary for the
        forward/backward/viterbi algorithms to not work with old tables 
        """
        return _Distribution.HMM_invalidate_model(*args)

    def get_status(*args):
        """
        get_status(self) -> bool

        get status true if everything is ok, else false 
        """
        return _Distribution.HMM_get_status(*args)

    def get_pseudo(*args):
        """
        get_pseudo(self) -> float

        returns current pseudo value 
        """
        return _Distribution.HMM_get_pseudo(*args)

    def set_pseudo(*args):
        """
        set_pseudo(self, pseudo)

        sets current pseudo value 
        """
        return _Distribution.HMM_set_pseudo(*args)

    def bw_dim_prefetch(*args):
        """bw_dim_prefetch(params) -> void"""
        return _Distribution.HMM_bw_dim_prefetch(*args)

    if _newclass:bw_dim_prefetch = staticmethod(bw_dim_prefetch)
    __swig_getmethods__["bw_dim_prefetch"] = lambda x: bw_dim_prefetch
    def bw_single_dim_prefetch(*args):
        """bw_single_dim_prefetch(params) -> void"""
        return _Distribution.HMM_bw_single_dim_prefetch(*args)

    if _newclass:bw_single_dim_prefetch = staticmethod(bw_single_dim_prefetch)
    __swig_getmethods__["bw_single_dim_prefetch"] = lambda x: bw_single_dim_prefetch
    def vit_dim_prefetch(*args):
        """vit_dim_prefetch(params) -> void"""
        return _Distribution.HMM_vit_dim_prefetch(*args)

    if _newclass:vit_dim_prefetch = staticmethod(vit_dim_prefetch)
    __swig_getmethods__["vit_dim_prefetch"] = lambda x: vit_dim_prefetch
    def set_observations(*args):
        """
        set_observations(self, obs, hmm=None)
        set_observations(self, obs)

        observation functions set/get observation matrix set new observations
        sets the observation pointer and initializes observation-dependent
        caches if hmm is given, then the caches of the model hmm are used 
        """
        return _Distribution.HMM_set_observations(*args)

    def set_observation_nocache(*args):
        """
        set_observation_nocache(self, obs)

        set new observations only set the observation pointer and drop caches
        if there were any 
        """
        return _Distribution.HMM_set_observation_nocache(*args)

    def get_observations(*args):
        """
        get_observations(self) -> shogun::CStringFeatures<(uint16_t)>

        return observation pointer 
        """
        return _Distribution.HMM_get_observations(*args)

    def load_definitions(*args):
        """
        load_definitions(self, file, verbose, initialize=True) -> bool
        load_definitions(self, file, verbose) -> bool

        read definitions file (learn_x,const_x) used for training. -format
        specs: definition_file (train.def) % HMM-TRAIN - specification %
        learn_a - elements in state_transition_matrix to be learned % learn_b
        - elements in oberservation_per_state_matrix to be learned % note:
        each line stands for % state, observation(0),
        observation(1)...observation(NOW) % learn_p - elements in initial
        distribution to be learned % learn_q - elements in the end-state
        distribution to be learned % % const_x - specifies initial values of
        elements % rest is assumed to be 0.0 % % NOTE: IMPLICIT DEFINES: %
        define A 0 % define C 1 % define G 2 % define T 3

        learn_a=[ [int32_t,int32_t]; [int32_t,int32_t]; [int32_t,int32_t];
        ........ [int32_t,int32_t]; [-1,-1]; ];

        learn_b=[ [int32_t,int32_t,int32_t,...,int32_t];
        [int32_t,int32_t,int32_t,...,int32_t];
        [int32_t,int32_t,int32_t,...,int32_t]; ........
        [int32_t,int32_t,int32_t,...,int32_t]; [-1,-1]; ];

        learn_p= [  int, ... ,  int, -1 ];

        learn_q= [  int, ... ,  int, -1 ];

        const_a=[ [int32_t,int32_t,float64_t]; [int32_t,int32_t,float64_t];
        [int32_t,int32_t,float64_t]; ........ [int32_t,int32_t,float64_t];
        [-1,-1,-1]; ];

        const_b=[ [int32_t,int32_t,int32_t,...,int32_t,float64_t];
        [int32_t,int32_t,int32_t,...,int32_t,float64_t];
        [int32_t,int32_t,int32_t,...,int32_t,<DOUBLE]; ........
        [int32_t,int32_t,int32_t,...,int32_t,float64_t]; [-1,-1,-1]; ];

        const_p[]=[ [int32_t, float], ... , [int32_t,float64_t], [-1,-1]
        ]; const_q[]=[ [int32_t, float], ... , [int32_t,float64_t],
        [-1,-1] ];

        Parameters:
        -----------

        file:  filehandle to definitions file

        verbose:  true for verbose messages

        initialize:  true to initialize to underlying HMM 
        """
        return _Distribution.HMM_load_definitions(*args)

    def load_model(*args):
        """
        load_model(self, file) -> bool

        read model from file. -format specs: model_file (model.hmm) % HMM -
        specification % N - number of states % M - number of
        observation_tokens % a is state_transition_matrix % size(a)= [N,N] % %
        b is observation_per_state_matrix % size(b)= [N,M] % % p is initial
        distribution % size(p)= [1, N]

        N=int32_t; M=int32_t;

        p=[float64_t,float64_t...float64_t];
        q=[float64_t,float64_t...float64_t];

        a=[ [float64_t,float64_t...float64_t];
        [float64_t,float64_t...float64_t]; [float64_t,float64_t...float64_t];
        [float64_t,float64_t...float64_t]; [float64_t,float64_t...float64_t];
        ];

        b=[ [float64_t,float64_t...float64_t];
        [float64_t,float64_t...float64_t]; [float64_t,float64_t...float64_t];
        [float64_t,float64_t...float64_t]; [float64_t,float64_t...float64_t];
        ];

        Parameters:
        -----------

        file:  filehandle to model file 
        """
        return _Distribution.HMM_load_model(*args)

    def save_model(*args):
        """
        save_model(self, file) -> bool

        save model to file.

        Parameters:
        -----------

        file:  filehandle to model file 
        """
        return _Distribution.HMM_save_model(*args)

    def save_model_derivatives(*args):
        """
        save_model_derivatives(self, file) -> bool

        save model derivatives to file in ascii format.

        Parameters:
        -----------

        file:  filehandle 
        """
        return _Distribution.HMM_save_model_derivatives(*args)

    def save_model_derivatives_bin(*args):
        """
        save_model_derivatives_bin(self, file) -> bool

        save model derivatives to file in binary format.

        Parameters:
        -----------

        file:  filehandle 
        """
        return _Distribution.HMM_save_model_derivatives_bin(*args)

    def save_model_bin(*args):
        """
        save_model_bin(self, file) -> bool

        save model in binary format.

        Parameters:
        -----------

        file:  filehandle 
        """
        return _Distribution.HMM_save_model_bin(*args)

    def check_model_derivatives(*args):
        """
        check_model_derivatives(self) -> bool

        numerically check whether derivates were calculated right 
        """
        return _Distribution.HMM_check_model_derivatives(*args)

    def check_model_derivatives_combined(*args):
        """check_model_derivatives_combined(self) -> bool"""
        return _Distribution.HMM_check_model_derivatives_combined(*args)

    def get_path(*args):
        """
        get_path(self, dim, prob) -> T_STATES

        get viterbi path and path probability

        Parameters:
        -----------

        dim:  dimension for which to obtain best path

        prob:  likelihood of path

        viterbi path 
        """
        return _Distribution.HMM_get_path(*args)

    def save_path(*args):
        """
        save_path(self, file) -> bool

        save viterbi path in ascii format

        Parameters:
        -----------

        file:  filehandle 
        """
        return _Distribution.HMM_save_path(*args)

    def save_path_derivatives(*args):
        """
        save_path_derivatives(self, file) -> bool

        save viterbi path in ascii format

        Parameters:
        -----------

        file:  filehandle 
        """
        return _Distribution.HMM_save_path_derivatives(*args)

    def save_path_derivatives_bin(*args):
        """
        save_path_derivatives_bin(self, file) -> bool

        save viterbi path in binary format

        Parameters:
        -----------

        file:  filehandle 
        """
        return _Distribution.HMM_save_path_derivatives_bin(*args)

    def check_path_derivatives(*args):
        """check_path_derivatives(self) -> bool"""
        return _Distribution.HMM_check_path_derivatives(*args)

    def save_likelihood_bin(*args):
        """
        save_likelihood_bin(self, file) -> bool

        save model probability in binary format

        Parameters:
        -----------

        file:  filehandle 
        """
        return _Distribution.HMM_save_likelihood_bin(*args)

    def save_likelihood(*args):
        """
        save_likelihood(self, file) -> bool

        save model probability in ascii format

        Parameters:
        -----------

        file:  filehandle 
        """
        return _Distribution.HMM_save_likelihood(*args)

    def get_N(*args):
        """
        get_N(self) -> T_STATES

        access function for number of states N 
        """
        return _Distribution.HMM_get_N(*args)

    def get_M(*args):
        """
        get_M(self) ->  int

        access function for number of observations M 
        """
        return _Distribution.HMM_get_M(*args)

    def set_q(*args):
        """
        set_q(self, offset, value)

        access function for probability of end states

        Parameters:
        -----------

        offset:  index 0...N-1

        value:  value to be set 
        """
        return _Distribution.HMM_set_q(*args)

    def set_p(*args):
        """
        set_p(self, offset, value)

        access function for probability of first state

        Parameters:
        -----------

        offset:  index 0...N-1

        value:  value to be set 
        """
        return _Distribution.HMM_set_p(*args)

    def set_A(*args):
        """
        set_A(self, line_, column, value)

        access function for matrix A

        Parameters:
        -----------

        line_:  row in matrix 0...N-1

        column:  column in matrix 0...N-1

        value:  value to be set 
        """
        return _Distribution.HMM_set_A(*args)

    def set_a(*args):
        """
        set_a(self, line_, column, value)

        access function for matrix a

        Parameters:
        -----------

        line_:  row in matrix 0...N-1

        column:  column in matrix 0...N-1

        value:  value to be set 
        """
        return _Distribution.HMM_set_a(*args)

    def set_B(*args):
        """
        set_B(self, line_, column, value)

        access function for matrix B

        Parameters:
        -----------

        line_:  row in matrix 0...N-1

        column:  column in matrix 0...M-1

        value:  value to be set 
        """
        return _Distribution.HMM_set_B(*args)

    def set_b(*args):
        """
        set_b(self, line_, column, value)

        access function for matrix b

        Parameters:
        -----------

        line_:  row in matrix 0...N-1

        column:  column in matrix 0...M-1

        value:  value to be set 
        """
        return _Distribution.HMM_set_b(*args)

    def set_psi(*args):
        """
        set_psi(self, time, state, value, dimension)

        access function for backtracking table psi

        Parameters:
        -----------

        time:  time 0...T-1

        state:  state 0...N-1

        value:  value to be set

        dimension:  dimension of observations 0...DIMENSION-1 
        """
        return _Distribution.HMM_set_psi(*args)

    def get_q(*args):
        """
        get_q(self, offset) -> float

        access function for probability of end states

        Parameters:
        -----------

        offset:  index 0...N-1

        value at offset 
        """
        return _Distribution.HMM_get_q(*args)

    def get_p(*args):
        """
        get_p(self, offset) -> float

        access function for probability of initial states

        Parameters:
        -----------

        offset:  index 0...N-1

        value at offset 
        """
        return _Distribution.HMM_get_p(*args)

    def get_A(*args):
        """
        get_A(self, line_, column) -> float

        access function for matrix A

        Parameters:
        -----------

        line_:  row in matrix 0...N-1

        column:  column in matrix 0...N-1

        value at position line colum 
        """
        return _Distribution.HMM_get_A(*args)

    def get_a(*args):
        """
        get_a(self, line_, column) -> float

        access function for matrix a

        Parameters:
        -----------

        line_:  row in matrix 0...N-1

        column:  column in matrix 0...N-1

        value at position line colum 
        """
        return _Distribution.HMM_get_a(*args)

    def get_B(*args):
        """
        get_B(self, line_, column) -> float

        access function for matrix B

        Parameters:
        -----------

        line_:  row in matrix 0...N-1

        column:  column in matrix 0...M-1

        value at position line colum 
        """
        return _Distribution.HMM_get_B(*args)

    def get_b(*args):
        """
        get_b(self, line_, column) -> float

        access function for matrix b

        Parameters:
        -----------

        line_:  row in matrix 0...N-1

        column:  column in matrix 0...M-1

        value at position line colum 
        """
        return _Distribution.HMM_get_b(*args)

    def get_psi(*args):
        """
        get_psi(self, time, state, dimension) -> T_STATES

        access function for backtracking table psi

        Parameters:
        -----------

        time:  time 0...T-1

        state:  state 0...N-1

        dimension:  dimension of observations 0...DIMENSION-1

        state at specified time and position 
        """
        return _Distribution.HMM_get_psi(*args)

    def state_probability(*args):
        """
        state_probability(self, time, state, dimension) -> float

        calculates probability of being in state i at time t for dimension 
        """
        return _Distribution.HMM_state_probability(*args)

    def transition_probability(*args):
        """
        transition_probability(self, time, state_i, state_j, dimension) -> float

        calculates probability of being in state i at time t and state j at
        time t+1 for dimension 
        """
        return _Distribution.HMM_transition_probability(*args)

    def linear_model_derivative(*args):
        """
        linear_model_derivative(self, i, j, dimension) -> float

        computes log dp(lambda)/d b_ij for linear model 
        """
        return _Distribution.HMM_linear_model_derivative(*args)

    def model_derivative_p(*args):
        """
        model_derivative_p(self, i, dimension) -> float

        computes log dp(lambda)/d p_i. backward path downto time 0 multiplied
        by observing first symbol in path at state i 
        """
        return _Distribution.HMM_model_derivative_p(*args)

    def model_derivative_q(*args):
        """
        model_derivative_q(self, i, dimension) -> float

        computes log dp(lambda)/d q_i. forward path upto time T-1 
        """
        return _Distribution.HMM_model_derivative_q(*args)

    def model_derivative_a(*args):
        """
        model_derivative_a(self, i, j, dimension) -> float

        computes log dp(lambda)/d a_ij. 
        """
        return _Distribution.HMM_model_derivative_a(*args)

    def model_derivative_b(*args):
        """
        model_derivative_b(self, i, j, dimension) -> float

        computes log dp(lambda)/d b_ij. 
        """
        return _Distribution.HMM_model_derivative_b(*args)

    def path_derivative_p(*args):
        """
        path_derivative_p(self, i, dimension) -> float

        computes d log p(lambda,best_path)/d p_i 
        """
        return _Distribution.HMM_path_derivative_p(*args)

    def path_derivative_q(*args):
        """
        path_derivative_q(self, i, dimension) -> float

        computes d log p(lambda,best_path)/d q_i 
        """
        return _Distribution.HMM_path_derivative_q(*args)

    def path_derivative_a(*args):
        """
        path_derivative_a(self, i, j, dimension) -> float

        computes d log p(lambda,best_path)/d a_ij 
        """
        return _Distribution.HMM_path_derivative_a(*args)

    def path_derivative_b(*args):
        """
        path_derivative_b(self, i, j, dimension) -> float

        computes d log p(lambda,best_path)/d b_ij 
        """
        return _Distribution.HMM_path_derivative_b(*args)

HMM_swigregister = _Distribution.HMM_swigregister
HMM_swigregister(HMM)

def HMM_bw_dim_prefetch(*args):
  """HMM_bw_dim_prefetch(params) -> void"""
  return _Distribution.HMM_bw_dim_prefetch(*args)

def HMM_bw_single_dim_prefetch(*args):
  """HMM_bw_single_dim_prefetch(params) -> void"""
  return _Distribution.HMM_bw_single_dim_prefetch(*args)

def HMM_vit_dim_prefetch(*args):
  """HMM_vit_dim_prefetch(params) -> void"""
  return _Distribution.HMM_vit_dim_prefetch(*args)

class GHMM(Distribution):
    """
    class GHMM - this class is non-functional and was meant to implement a
    Generalize Hidden Markov Model (aka Semi Hidden Markov HMM).

    C++ includes: GHMM.h 
    """
    __swig_setmethods__ = {}
    for _s in [Distribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GHMM, name, value)
    __swig_getmethods__ = {}
    for _s in [Distribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GHMM, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Distribution.delete_GHMM
    __del__ = lambda self : None;
    def train(*args):
        """
        train(self, data=None) -> bool
        train(self) -> bool

        learn distribution

        Parameters:
        -----------

        data:  training data (parameter can be avoided if distance or kernel-
        based classifiers are used and distance/kernels are initialized with
        train data)

        whether training was successful 
        """
        return _Distribution.GHMM_train(*args)

GHMM_swigregister = _Distribution.GHMM_swigregister
GHMM_swigregister(GHMM)

class LinearHMM(Distribution):
    """
    The class LinearHMM is for learning Higher Order Markov chains.

    While learning the parameters ${\\bf \\theta}$ in

    \\begin{eqnarray*} P({\\bf x}|{\\bf \\theta}^\\pm)&=&P(x_1,
    \\ldots, x_N|{\\bf \\theta}^\\pm)\\\\
    &=&P(x_1,\\ldots,x_{d}|{\\bf \\theta}^\\pm)\\prod_{i=d+1}^N
    P(x_i|x_{i-1},\\ldots,x_{i-d},{\\bf \\theta}^\\pm)
    \\end{eqnarray*}

    are determined.

    A more detailed description can be found in

    Durbin et.al, Biological Sequence Analysis -Probabilistic Models of
    Proteins and Nucleic Acids, 1998

    C++ includes: LinearHMM.h 
    """
    __swig_setmethods__ = {}
    for _s in [Distribution]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinearHMM, name, value)
    __swig_getmethods__ = {}
    for _s in [Distribution]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LinearHMM, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, f) -> LinearHMM
        __init__(self, p_num_features, p_num_symbols) -> LinearHMM

        constructor

        Parameters:
        -----------

        p_num_features:  number of features

        p_num_symbols:  number of symbols in features 
        """
        this = _Distribution.new_LinearHMM(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Distribution.delete_LinearHMM
    __del__ = lambda self : None;
    def train(*args):
        """
        train(self, data=None) -> bool
        train(self) -> bool
        train(self, indizes, num_indizes, pseudo_count) -> bool

        alternative train distribution

        Parameters:
        -----------

        indizes:  indices

        num_indizes:  number of indices

        pseudo_count:  pseudo count

        if training was successful 
        """
        return _Distribution.LinearHMM_train(*args)

    def get_likelihood_example(*args):
        """
        get_likelihood_example(self, vector, len) -> float

        get one example's likelihood

        Parameters:
        -----------

        vector:  the example

        len:  length of vector

        likelihood 
        """
        return _Distribution.LinearHMM_get_likelihood_example(*args)

    def get_log_likelihood_example(*args):
        """
        get_log_likelihood_example(self, vector, len) -> float
        get_log_likelihood_example(self, num_example) -> float

        get logarithm of one example's likelihood

        Parameters:
        -----------

        num_example:  which example

        logarithm of example's likelihood 
        """
        return _Distribution.LinearHMM_get_log_likelihood_example(*args)

    def get_log_derivative_obsolete(*args):
        """
        get_log_derivative_obsolete(self, obs, pos) -> float

        obsolete get logarithm of one example's derivative's likelihood

        Parameters:
        -----------

        obs:  observation

        pos:  position 
        """
        return _Distribution.LinearHMM_get_log_derivative_obsolete(*args)

    def get_derivative_obsolete(*args):
        """
        get_derivative_obsolete(self, vector, len, pos) -> float

        obsolete get one example's derivative

        Parameters:
        -----------

        vector:  vector

        len:  length

        pos:  position 
        """
        return _Distribution.LinearHMM_get_derivative_obsolete(*args)

    def get_sequence_length(*args):
        """
        get_sequence_length(self) ->  int

        get sequence length of each example

        sequence length of each example 
        """
        return _Distribution.LinearHMM_get_sequence_length(*args)

    def get_num_symbols(*args):
        """
        get_num_symbols(self) ->  int

        get number of symbols in examples

        number of symbols in examples 
        """
        return _Distribution.LinearHMM_get_num_symbols(*args)

    def get_positional_log_parameter(*args):
        """
        get_positional_log_parameter(self, obs, position) -> float

        get positional log parameter

        Parameters:
        -----------

        obs:  observation

        position:  position

        positional log parameter 
        """
        return _Distribution.LinearHMM_get_positional_log_parameter(*args)

    def get_log_transition_probs(*args):
        """
        get_log_transition_probs(self) -> numpy 1dim array of %float

        get logarithm of all transition probs

        Parameters:
        -----------

        dst:  where logarithm of transition probs will be stored

        num:  where number of logarithm of transition probs will be stored 
        """
        return _Distribution.LinearHMM_get_log_transition_probs(*args)

    def set_log_transition_probs(*args):
        """
        set_log_transition_probs(self, src) -> bool

        set logarithm of all transition probs

        Parameters:
        -----------

        src:  new logarithms of transition probs

        num:  number of logarithms of transition probs

        if setting was successful 
        """
        return _Distribution.LinearHMM_set_log_transition_probs(*args)

    def get_transition_probs(*args):
        """
        get_transition_probs(self) -> numpy 1dim array of %float

        get all transition probs

        Parameters:
        -----------

        dst:  where transition probs will be stored

        num:  where number of transition probs will be stored 
        """
        return _Distribution.LinearHMM_get_transition_probs(*args)

    def set_transition_probs(*args):
        """
        set_transition_probs(self, src) -> bool

        set all transition probs

        Parameters:
        -----------

        src:  new transition probs

        num:  number of transition probs

        if setting was successful 
        """
        return _Distribution.LinearHMM_set_transition_probs(*args)

LinearHMM_swigregister = _Distribution.LinearHMM_swigregister
LinearHMM_swigregister(LinearHMM)



