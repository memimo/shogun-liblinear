# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.
# This file is compatible with both classic and new-style classes.

"""
The `Evaluation` module is a collection of classes like PerformanceMeasures for the SHOGUN toolkit.
"""

import _Evaluation
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types


class ShogunException(_object):
    """Proxy of C++ ShogunException class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShogunException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ShogunException, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, str) -> ShogunException"""
        this = _Evaluation.new_ShogunException(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Evaluation.delete_ShogunException
    __del__ = lambda self : None;
    def get_exception_string(*args):
        """get_exception_string(self) -> str"""
        return _Evaluation.ShogunException_get_exception_string(*args)

ShogunException_swigregister = _Evaluation.ShogunException_swigregister
ShogunException_swigregister(ShogunException)

MSG_GCDEBUG = _Evaluation.MSG_GCDEBUG
MSG_DEBUG = _Evaluation.MSG_DEBUG
MSG_INFO = _Evaluation.MSG_INFO
MSG_NOTICE = _Evaluation.MSG_NOTICE
MSG_WARN = _Evaluation.MSG_WARN
MSG_ERROR = _Evaluation.MSG_ERROR
MSG_CRITICAL = _Evaluation.MSG_CRITICAL
MSG_ALERT = _Evaluation.MSG_ALERT
MSG_EMERGENCY = _Evaluation.MSG_EMERGENCY
MSG_MESSAGEONLY = _Evaluation.MSG_MESSAGEONLY
class IO(_object):
    """Proxy of C++ IO class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IO, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IO, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IO
        __init__(self, orig) -> IO
        """
        this = _Evaluation.new_IO(*args)
        try: self.this.append(this)
        except: self.this = this
    def set_loglevel(*args):
        """set_loglevel(self, level)"""
        return _Evaluation.IO_set_loglevel(*args)

    def get_loglevel(*args):
        """get_loglevel(self) -> EMessageType"""
        return _Evaluation.IO_get_loglevel(*args)

    def get_show_progress(*args):
        """get_show_progress(self) -> bool"""
        return _Evaluation.IO_get_show_progress(*args)

    def get_show_file_and_line(*args):
        """get_show_file_and_line(self) -> bool"""
        return _Evaluation.IO_get_show_file_and_line(*args)

    def message(*args):
        """message(self, prio, file, line, fmt, ?)"""
        return _Evaluation.IO_message(*args)

    def progress(*args):
        """
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1)
        progress(self, current_val, min_val=0.0, max_val=1.0)
        progress(self, current_val, min_val=0.0)
        progress(self, current_val)
        """
        return _Evaluation.IO_progress(*args)

    def absolute_progress(*args):
        """
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1)
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0)
        absolute_progress(self, current_val, val, min_val=0.0)
        absolute_progress(self, current_val, val)
        """
        return _Evaluation.IO_absolute_progress(*args)

    def done(*args):
        """done(self)"""
        return _Evaluation.IO_done(*args)

    def not_implemented(*args):
        """not_implemented(self, file, line)"""
        return _Evaluation.IO_not_implemented(*args)

    def deprecated(*args):
        """deprecated(self, file, line)"""
        return _Evaluation.IO_deprecated(*args)

    def buffered_message(*args):
        """buffered_message(self, prio, fmt, ?)"""
        return _Evaluation.IO_buffered_message(*args)

    def skip_spaces(*args):
        """skip_spaces(str) -> str"""
        return _Evaluation.IO_skip_spaces(*args)

    if _newclass:skip_spaces = staticmethod(skip_spaces)
    __swig_getmethods__["skip_spaces"] = lambda x: skip_spaces
    def skip_blanks(*args):
        """skip_blanks(str) -> str"""
        return _Evaluation.IO_skip_blanks(*args)

    if _newclass:skip_blanks = staticmethod(skip_blanks)
    __swig_getmethods__["skip_blanks"] = lambda x: skip_blanks
    def get_target(*args):
        """get_target(self) -> FILE"""
        return _Evaluation.IO_get_target(*args)

    def set_target(*args):
        """set_target(self, target)"""
        return _Evaluation.IO_set_target(*args)

    def set_target_to_stderr(*args):
        """set_target_to_stderr(self)"""
        return _Evaluation.IO_set_target_to_stderr(*args)

    def set_target_to_stdout(*args):
        """set_target_to_stdout(self)"""
        return _Evaluation.IO_set_target_to_stdout(*args)

    def enable_progress(*args):
        """enable_progress(self)"""
        return _Evaluation.IO_enable_progress(*args)

    def disable_progress(*args):
        """disable_progress(self)"""
        return _Evaluation.IO_disable_progress(*args)

    def enable_file_and_line(*args):
        """enable_file_and_line(self)"""
        return _Evaluation.IO_enable_file_and_line(*args)

    def disable_file_and_line(*args):
        """disable_file_and_line(self)"""
        return _Evaluation.IO_disable_file_and_line(*args)

    def set_dirname(*args):
        """set_dirname(dirname)"""
        return _Evaluation.IO_set_dirname(*args)

    if _newclass:set_dirname = staticmethod(set_dirname)
    __swig_getmethods__["set_dirname"] = lambda x: set_dirname
    def concat_filename(*args):
        """concat_filename(filename) -> str"""
        return _Evaluation.IO_concat_filename(*args)

    if _newclass:concat_filename = staticmethod(concat_filename)
    __swig_getmethods__["concat_filename"] = lambda x: concat_filename
    def filter(*args):
        """filter(d) -> int"""
        return _Evaluation.IO_filter(*args)

    if _newclass:filter = staticmethod(filter)
    __swig_getmethods__["filter"] = lambda x: filter
    def ref(*args):
        """ref(self) ->  int"""
        return _Evaluation.IO_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Evaluation.IO_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Evaluation.IO_unref(*args)

    def get_name(*args):
        """get_name(self) -> str"""
        return _Evaluation.IO_get_name(*args)

    __swig_destroy__ = _Evaluation.delete_IO
    __del__ = lambda self : None;
IO_swigregister = _Evaluation.IO_swigregister
IO_swigregister(IO)
cvar = _Evaluation.cvar

def IO_skip_spaces(*args):
  """IO_skip_spaces(str) -> str"""
  return _Evaluation.IO_skip_spaces(*args)

def IO_skip_blanks(*args):
  """IO_skip_blanks(str) -> str"""
  return _Evaluation.IO_skip_blanks(*args)

def IO_set_dirname(*args):
  """IO_set_dirname(dirname)"""
  return _Evaluation.IO_set_dirname(*args)

def IO_concat_filename(*args):
  """IO_concat_filename(filename) -> str"""
  return _Evaluation.IO_concat_filename(*args)

def IO_filter(*args):
  """IO_filter(d) -> int"""
  return _Evaluation.IO_filter(*args)

class SGObject(_object):
    """Proxy of C++ SGObject class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SGObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SGObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Evaluation.delete_SGObject
    __del__ = lambda self : None;
    def ref(*args):
        """ref(self) ->  int"""
        return _Evaluation.SGObject_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Evaluation.SGObject_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Evaluation.SGObject_unref(*args)

    def get_name(*args):
        """get_name(self) -> str"""
        return _Evaluation.SGObject_get_name(*args)

    __swig_setmethods__["io"] = _Evaluation.SGObject_io_set
    __swig_getmethods__["io"] = _Evaluation.SGObject_io_get
    if _newclass:io = _swig_property(_Evaluation.SGObject_io_get, _Evaluation.SGObject_io_set)
    __swig_setmethods__["parallel"] = _Evaluation.SGObject_parallel_set
    __swig_getmethods__["parallel"] = _Evaluation.SGObject_parallel_get
    if _newclass:parallel = _swig_property(_Evaluation.SGObject_parallel_get, _Evaluation.SGObject_parallel_set)
    __swig_setmethods__["version"] = _Evaluation.SGObject_version_set
    __swig_getmethods__["version"] = _Evaluation.SGObject_version_get
    if _newclass:version = _swig_property(_Evaluation.SGObject_version_get, _Evaluation.SGObject_version_set)
SGObject_swigregister = _Evaluation.SGObject_swigregister
SGObject_swigregister(SGObject)

class Version(_object):
    """Proxy of C++ Version class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Version, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Version, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self) -> Version"""
        this = _Evaluation.new_Version(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Evaluation.delete_Version
    __del__ = lambda self : None;
    def print_version(*args):
        """print_version()"""
        return _Evaluation.Version_print_version(*args)

    if _newclass:print_version = staticmethod(print_version)
    __swig_getmethods__["print_version"] = lambda x: print_version
    def get_version_extra(*args):
        """get_version_extra() -> str"""
        return _Evaluation.Version_get_version_extra(*args)

    if _newclass:get_version_extra = staticmethod(get_version_extra)
    __swig_getmethods__["get_version_extra"] = lambda x: get_version_extra
    def get_version_release(*args):
        """get_version_release() -> str"""
        return _Evaluation.Version_get_version_release(*args)

    if _newclass:get_version_release = staticmethod(get_version_release)
    __swig_getmethods__["get_version_release"] = lambda x: get_version_release
    def get_version_revision(*args):
        """get_version_revision() ->  int"""
        return _Evaluation.Version_get_version_revision(*args)

    if _newclass:get_version_revision = staticmethod(get_version_revision)
    __swig_getmethods__["get_version_revision"] = lambda x: get_version_revision
    def get_version_year(*args):
        """get_version_year() ->  int"""
        return _Evaluation.Version_get_version_year(*args)

    if _newclass:get_version_year = staticmethod(get_version_year)
    __swig_getmethods__["get_version_year"] = lambda x: get_version_year
    def get_version_month(*args):
        """get_version_month() ->  int"""
        return _Evaluation.Version_get_version_month(*args)

    if _newclass:get_version_month = staticmethod(get_version_month)
    __swig_getmethods__["get_version_month"] = lambda x: get_version_month
    def get_version_day(*args):
        """get_version_day() ->  int"""
        return _Evaluation.Version_get_version_day(*args)

    if _newclass:get_version_day = staticmethod(get_version_day)
    __swig_getmethods__["get_version_day"] = lambda x: get_version_day
    def get_version_hour(*args):
        """get_version_hour() ->  int"""
        return _Evaluation.Version_get_version_hour(*args)

    if _newclass:get_version_hour = staticmethod(get_version_hour)
    __swig_getmethods__["get_version_hour"] = lambda x: get_version_hour
    def get_version_minute(*args):
        """get_version_minute() ->  int"""
        return _Evaluation.Version_get_version_minute(*args)

    if _newclass:get_version_minute = staticmethod(get_version_minute)
    __swig_getmethods__["get_version_minute"] = lambda x: get_version_minute
    def get_version_in_minutes(*args):
        """get_version_in_minutes() -> int"""
        return _Evaluation.Version_get_version_in_minutes(*args)

    if _newclass:get_version_in_minutes = staticmethod(get_version_in_minutes)
    __swig_getmethods__["get_version_in_minutes"] = lambda x: get_version_in_minutes
    def ref(*args):
        """ref(self) ->  int"""
        return _Evaluation.Version_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Evaluation.Version_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Evaluation.Version_unref(*args)

Version_swigregister = _Evaluation.Version_swigregister
Version_swigregister(Version)

def Version_print_version(*args):
  """Version_print_version()"""
  return _Evaluation.Version_print_version(*args)

def Version_get_version_extra(*args):
  """Version_get_version_extra() -> str"""
  return _Evaluation.Version_get_version_extra(*args)

def Version_get_version_release(*args):
  """Version_get_version_release() -> str"""
  return _Evaluation.Version_get_version_release(*args)

def Version_get_version_revision(*args):
  """Version_get_version_revision() ->  int"""
  return _Evaluation.Version_get_version_revision(*args)

def Version_get_version_year(*args):
  """Version_get_version_year() ->  int"""
  return _Evaluation.Version_get_version_year(*args)

def Version_get_version_month(*args):
  """Version_get_version_month() ->  int"""
  return _Evaluation.Version_get_version_month(*args)

def Version_get_version_day(*args):
  """Version_get_version_day() ->  int"""
  return _Evaluation.Version_get_version_day(*args)

def Version_get_version_hour(*args):
  """Version_get_version_hour() ->  int"""
  return _Evaluation.Version_get_version_hour(*args)

def Version_get_version_minute(*args):
  """Version_get_version_minute() ->  int"""
  return _Evaluation.Version_get_version_minute(*args)

def Version_get_version_in_minutes(*args):
  """Version_get_version_in_minutes() -> int"""
  return _Evaluation.Version_get_version_in_minutes(*args)

class Parallel(_object):
    """Proxy of C++ Parallel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parallel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Parallel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Parallel
        __init__(self, orig) -> Parallel
        """
        this = _Evaluation.new_Parallel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Evaluation.delete_Parallel
    __del__ = lambda self : None;
    def get_num_cpus(*args):
        """get_num_cpus(self) ->  int"""
        return _Evaluation.Parallel_get_num_cpus(*args)

    def set_num_threads(*args):
        """set_num_threads(self, n)"""
        return _Evaluation.Parallel_set_num_threads(*args)

    def get_num_threads(*args):
        """get_num_threads(self) ->  int"""
        return _Evaluation.Parallel_get_num_threads(*args)

    def ref(*args):
        """ref(self) ->  int"""
        return _Evaluation.Parallel_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Evaluation.Parallel_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Evaluation.Parallel_unref(*args)

Parallel_swigregister = _Evaluation.Parallel_swigregister
Parallel_swigregister(Parallel)

class PySwigIterator(_object):
    """Proxy of C++ PySwigIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Evaluation.delete_PySwigIterator
    __del__ = lambda self : None;
    def value(*args):
        """value(self) -> PyObject"""
        return _Evaluation.PySwigIterator_value(*args)

    def incr(*args):
        """
        incr(self, n=1) -> PySwigIterator
        incr(self) -> PySwigIterator
        """
        return _Evaluation.PySwigIterator_incr(*args)

    def decr(*args):
        """
        decr(self, n=1) -> PySwigIterator
        decr(self) -> PySwigIterator
        """
        return _Evaluation.PySwigIterator_decr(*args)

    def distance(*args):
        """distance(self, x) -> ptrdiff_t"""
        return _Evaluation.PySwigIterator_distance(*args)

    def equal(*args):
        """equal(self, x) -> bool"""
        return _Evaluation.PySwigIterator_equal(*args)

    def copy(*args):
        """copy(self) -> PySwigIterator"""
        return _Evaluation.PySwigIterator_copy(*args)

    def next(*args):
        """next(self) -> PyObject"""
        return _Evaluation.PySwigIterator_next(*args)

    def previous(*args):
        """previous(self) -> PyObject"""
        return _Evaluation.PySwigIterator_previous(*args)

    def advance(*args):
        """advance(self, n) -> PySwigIterator"""
        return _Evaluation.PySwigIterator_advance(*args)

    def __eq__(*args):
        """__eq__(self, x) -> bool"""
        return _Evaluation.PySwigIterator___eq__(*args)

    def __ne__(*args):
        """__ne__(self, x) -> bool"""
        return _Evaluation.PySwigIterator___ne__(*args)

    def __iadd__(*args):
        """__iadd__(self, n) -> PySwigIterator"""
        return _Evaluation.PySwigIterator___iadd__(*args)

    def __isub__(*args):
        """__isub__(self, n) -> PySwigIterator"""
        return _Evaluation.PySwigIterator___isub__(*args)

    def __add__(*args):
        """__add__(self, n) -> PySwigIterator"""
        return _Evaluation.PySwigIterator___add__(*args)

    def __sub__(*args):
        """
        __sub__(self, n) -> PySwigIterator
        __sub__(self, x) -> ptrdiff_t
        """
        return _Evaluation.PySwigIterator___sub__(*args)

    def __iter__(self): return self
PySwigIterator_swigregister = _Evaluation.PySwigIterator_swigregister
PySwigIterator_swigregister(PySwigIterator)

class IntVector(_object):
    """Proxy of C++ IntVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _Evaluation.IntVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _Evaluation.IntVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(int)>::size_type"""
        return _Evaluation.IntVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(int)>::value_type"""
        return _Evaluation.IntVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> IntVector"""
        return _Evaluation.IntVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _Evaluation.IntVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _Evaluation.IntVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _Evaluation.IntVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(int)>::value_type"""
        return _Evaluation.IntVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _Evaluation.IntVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _Evaluation.IntVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _Evaluation.IntVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(int)>::size_type"""
        return _Evaluation.IntVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _Evaluation.IntVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _Evaluation.IntVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(int)>::allocator_type"""
        return _Evaluation.IntVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(int)>::const_iterator"""
        return _Evaluation.IntVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(int)>::const_iterator"""
        return _Evaluation.IntVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _Evaluation.IntVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _Evaluation.IntVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _Evaluation.IntVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(int)>::iterator
        erase(self, first, last) -> std::vector<(int)>::iterator
        """
        return _Evaluation.IntVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> IntVector
        __init__(self, ?) -> IntVector
        __init__(self, size) -> IntVector
        __init__(self, size, value) -> IntVector
        """
        this = _Evaluation.new_IntVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _Evaluation.IntVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(int)>::value_type"""
        return _Evaluation.IntVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(int)>::value_type"""
        return _Evaluation.IntVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _Evaluation.IntVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _Evaluation.IntVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(int)>::iterator
        insert(self, pos, n, x)
        """
        return _Evaluation.IntVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _Evaluation.IntVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(int)>::size_type"""
        return _Evaluation.IntVector_capacity(*args)

    __swig_destroy__ = _Evaluation.delete_IntVector
    __del__ = lambda self : None;
IntVector_swigregister = _Evaluation.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(_object):
    """Proxy of C++ DoubleVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _Evaluation.DoubleVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _Evaluation.DoubleVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(double)>::size_type"""
        return _Evaluation.DoubleVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(double)>::value_type"""
        return _Evaluation.DoubleVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> DoubleVector"""
        return _Evaluation.DoubleVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _Evaluation.DoubleVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _Evaluation.DoubleVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _Evaluation.DoubleVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(double)>::value_type"""
        return _Evaluation.DoubleVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _Evaluation.DoubleVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _Evaluation.DoubleVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _Evaluation.DoubleVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(double)>::size_type"""
        return _Evaluation.DoubleVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _Evaluation.DoubleVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _Evaluation.DoubleVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(double)>::allocator_type"""
        return _Evaluation.DoubleVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(double)>::const_iterator"""
        return _Evaluation.DoubleVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(double)>::const_iterator"""
        return _Evaluation.DoubleVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _Evaluation.DoubleVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _Evaluation.DoubleVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _Evaluation.DoubleVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(double)>::iterator
        erase(self, first, last) -> std::vector<(double)>::iterator
        """
        return _Evaluation.DoubleVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> DoubleVector
        __init__(self, ?) -> DoubleVector
        __init__(self, size) -> DoubleVector
        __init__(self, size, value) -> DoubleVector
        """
        this = _Evaluation.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _Evaluation.DoubleVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(double)>::value_type"""
        return _Evaluation.DoubleVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(double)>::value_type"""
        return _Evaluation.DoubleVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _Evaluation.DoubleVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _Evaluation.DoubleVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(double)>::iterator
        insert(self, pos, n, x)
        """
        return _Evaluation.DoubleVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _Evaluation.DoubleVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(double)>::size_type"""
        return _Evaluation.DoubleVector_capacity(*args)

    __swig_destroy__ = _Evaluation.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _Evaluation.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class PerformanceMeasures(SGObject):
    """
    Class to implement various performance measures.

    Receiver Operating Curve (ROC)

    Area under the ROC curve (auROC)

    Area over the ROC curve (aoROC)

    Precision Recall Curve (PRC)

    Area under the PRC (auPRC)

    Area over the PRC (aoPRC)

    Detection Error Tradeoff (DET)

    Area under the DET (auDET)

    Area over the DET (aoDET)

    Cross Correlation coefficient (CC)

    Weighted Relative Accuracy (WRAcc)

    Balanced Error (BAL)

    F-Measure

    Accuracy

    Error

    based on: Fawcett, T: March 2004, ROC Graphs: Notes and Practical
    Considerations for Researchers and input from Sonnenburg, S: Feburary
    2008, various discussions

    C++ includes: PerformanceMeasures.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PerformanceMeasures, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PerformanceMeasures, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> PerformanceMeasures
        __init__(self, true_labels, output) -> PerformanceMeasures

        constructor

        Parameters:
        -----------

        true_labels:  true labels as seen in real world

        output:  output labels/hypothesis from a classifier 
        """
        this = _Evaluation.new_PerformanceMeasures(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Evaluation.delete_PerformanceMeasures
    __del__ = lambda self : None;
    def init(*args):
        """
        init(self, true_labels, output)

        initialise performance measures

        Parameters:
        -----------

        true_labels:  true labels as seen in real world

        output:  output labels/hypothesis from a classifier 
        """
        return _Evaluation.PerformanceMeasures_init(*args)

    def set_true_labels(*args):
        """
        set_true_labels(self, true_labels) -> bool

        set true labels as seen in real world

        Parameters:
        -----------

        true_labels:  true labels

        if setting was successful 
        """
        return _Evaluation.PerformanceMeasures_set_true_labels(*args)

    def get_true_labels(*args):
        """
        get_true_labels(self) -> CLabels

        get true labels as seen in real world

        true labels as seen in real world 
        """
        return _Evaluation.PerformanceMeasures_get_true_labels(*args)

    def set_output(*args):
        """
        set_output(self, output) -> bool

        set output labels/hypothesis from a classifier

        Parameters:
        -----------

        output:  output labels

        if setting was successful 
        """
        return _Evaluation.PerformanceMeasures_set_output(*args)

    def get_output(*args):
        """
        get_output(self) -> CLabels

        get classifier's output labels/hypothesis

        output labels 
        """
        return _Evaluation.PerformanceMeasures_get_output(*args)

    def get_num_labels(*args):
        """
        get_num_labels(self) ->  int

        get number of labels in output/true labels

        number of labels in output/true labels 
        """
        return _Evaluation.PerformanceMeasures_get_num_labels(*args)

    def get_ROC(*args):
        """
        get_ROC(self) -> numpy array of Receiver Operating Curve points (2 floats)

        get Receiver Operating Curve for previously given labels (swig
        compatible)

        ROC point = false positives / all false labels, true positives / all
        true labels

        caller has to free

        Parameters:
        -----------

        result:  where computed ROC values will be stored

        num:  number of labels/examples

        dim:  dimensions == 2 (false positive rate, true positive rate) 
        """
        return _Evaluation.PerformanceMeasures_get_ROC(*args)

    def get_auROC(*args):
        """
        get_auROC(self) -> float

        return area under Receiver Operating Curve

        calculated by adding trapezoids

        area under ROC 
        """
        return _Evaluation.PerformanceMeasures_get_auROC(*args)

    def get_aoROC(*args):
        """
        get_aoROC(self) -> float

        return area over Reveiver Operating Curve

        value is 1 - auROC

        area over ROC 
        """
        return _Evaluation.PerformanceMeasures_get_aoROC(*args)

    def get_PRC(*args):
        """
        get_PRC(self) -> numpy array of Precision Recall Curve points (2 floats)

        get Precision Recall Curve for previously given labels (swig
        compatible)

        PRC point = true positives / all true labels, true positives / (true
        positives + false positives)

        caller has to free

        Parameters:
        -----------

        result:  where computed ROC values will be stored

        num:  number of labels/examples

        dim:  dimension == 2 (recall, precision) 
        """
        return _Evaluation.PerformanceMeasures_get_PRC(*args)

    def get_auPRC(*args):
        """
        get_auPRC(self) -> float

        return area under Precision Recall Curve

        calculated by adding trapezoids

        area under PRC 
        """
        return _Evaluation.PerformanceMeasures_get_auPRC(*args)

    def get_aoPRC(*args):
        """
        get_aoPRC(self) -> float

        return area over Precision Recall Curve

        value is 1 - auPRC

        area over PRC 
        """
        return _Evaluation.PerformanceMeasures_get_aoPRC(*args)

    def get_DET(*args):
        """
        get_DET(self) -> numpy array of Detection Error Tradeoff points (2 floats)

        get Detection Error Tradeoff curve for previously given labels (swig
        compatible)

        DET point = false positives / all false labels, false negatives / all
        false labels

        caller has to free

        Parameters:
        -----------

        result:  where computed DET values will be stored

        num:  number of labels/examples

        dim:  dimension == 2 (false positive rate, false negative rate) 
        """
        return _Evaluation.PerformanceMeasures_get_DET(*args)

    def get_auDET(*args):
        """
        get_auDET(self) -> float

        return area under Detection Error Tradeoff curve

        calculated by adding trapezoids

        area under DET curve 
        """
        return _Evaluation.PerformanceMeasures_get_auDET(*args)

    def get_aoDET(*args):
        """
        get_aoDET(self) -> float

        return area over Detection Error Tradeoff curve

        value is 1 - auDET

        area over DET curve 
        """
        return _Evaluation.PerformanceMeasures_get_aoDET(*args)

    def get_all_accuracy(*args):
        """
        get_all_accuracy(self, result)

        get classifier's accuracies (swig compatible)

        accuracy = (true positives + true negatives) / all labels

        caller has to free

        Parameters:
        -----------

        result:  storage of accuracies in 2 dim array: (output, accuracy),
        sorted by output

        num:  number of accuracy points

        dim:  dimension == 2 (output, accuracy) 
        """
        return _Evaluation.PerformanceMeasures_get_all_accuracy(*args)

    def get_accuracy(*args):
        """
        get_accuracy(self, threshold=0) -> float
        get_accuracy(self) -> float

        get classifier's accuracy at given threshold

        Parameters:
        -----------

        threshold:  all values below are considered negative examples (default
        0)

        classifer's accuracy at threshold 
        """
        return _Evaluation.PerformanceMeasures_get_accuracy(*args)

    def get_all_error(*args):
        """
        get_all_error(self, result)

        get classifier's error rates (swig compatible)

        value is 1 - accuracy

        caller has to free

        Parameters:
        -----------

        result:  storage of errors in 2 dim array: (output, error), sorted by
        output

        num:  number of accuracy points

        dim:  dimension == 2 (output, error) 
        """
        return _Evaluation.PerformanceMeasures_get_all_error(*args)

    def get_error(*args):
        """
        get_error(self, threshold=0) -> float
        get_error(self) -> float

        get classifier's error at threshold

        value is 1 - accuracy0

        Parameters:
        -----------

        threshold:  all values below are considered negative examples (default
        0)

        classifer's error at threshold 
        """
        return _Evaluation.PerformanceMeasures_get_error(*args)

    def get_all_fmeasure(*args):
        """
        get_all_fmeasure(self, result)

        get classifier's F-measure (swig compatible)

        F-measure = 2 / (1 / precision + 1 / recall)

        caller has to free

        Parameters:
        -----------

        result:  storage of F-measure in 2 dim array (output, fmeasure),
        sorted by output

        num:  number of accuracy points

        dim:  dimension == 2 (output, fmeasure) 
        """
        return _Evaluation.PerformanceMeasures_get_all_fmeasure(*args)

    def get_fmeasure(*args):
        """
        get_fmeasure(self, threshold=0) -> float
        get_fmeasure(self) -> float

        get classifier's F-measure at threshold 0

        classifer's F-measure at threshold 0 
        """
        return _Evaluation.PerformanceMeasures_get_fmeasure(*args)

    def get_all_CC(*args):
        """
        get_all_CC(self) -> numpy array of Cross Correlation coefficients (2 floats)

        get classifier's Cross Correlation coefficients (swig compatible)

        CC = ( true positives * true negatives false positives * false
        negatives ) / sqrt( (true positives + false positives) * (true
        positives + false negatives) * (true negatives + false positives) *
        (true negatives + false negatives) )

        also checkhttp://en.wikipedia.org/wiki/Correlation

        caller has to free

        Parameters:
        -----------

        result:  storage of CCs in 2 dim array: (output, CC), sorted by output

        num:  number of CC points

        dim:  dimension == 2 (output, CC) 
        """
        return _Evaluation.PerformanceMeasures_get_all_CC(*args)

    def get_CC(*args):
        """
        get_CC(self, threshold=0) -> float
        get_CC(self) -> float

        get classifier's Cross Correlation coefficient at threshold

        classifer's CC at threshold 
        """
        return _Evaluation.PerformanceMeasures_get_CC(*args)

    def get_all_WRAcc(*args):
        """
        get_all_WRAcc(self) -> numpy array of Weighted Relative Accuracy values (2 floats)

        get classifier's Weighted Relative Accuracy (swig compatible)

        WRAcc = ( true positives / (true positives + false negatives) ) (
        false positives / (false positives + true negatives) )

        caller has to free

        Parameters:
        -----------

        result:  storage of WRAccs in 2 dim array: (output, WRAcc), sorted by
        output

        num:  number of WRAcc points

        dim:  dimension == 2 (output, WRAcc) 
        """
        return _Evaluation.PerformanceMeasures_get_all_WRAcc(*args)

    def get_WRAcc(*args):
        """
        get_WRAcc(self, threshold=0) -> float
        get_WRAcc(self) -> float

        get classifier's Weighted Relative Accuracy at threshold 0

        classifer's WRAcc at threshold 0 
        """
        return _Evaluation.PerformanceMeasures_get_WRAcc(*args)

    def get_all_BAL(*args):
        """
        get_all_BAL(self, result)

        get classifier's Balanced Error (swig compatible)

        BAL = 0.5 * ( true positives / all true labels + true negatives / all
        false labels )

        caller has to free

        Parameters:
        -----------

        result:  storage of BAL in 2 dim array: (output, BAL), sorted by
        output

        num:  number of BAL points

        dim:  dimension == 2 (output, BAL) 
        """
        return _Evaluation.PerformanceMeasures_get_all_BAL(*args)

    def get_BAL(*args):
        """
        get_all_BAL(self) -> numpy array of Balanced Error values (2 floats)
        get_all_BAL(self) -> numpy array of Balanced Error values (2 floats)

        get classifier's Balanced Error at threshold 0

        classifer's BAL at threshold 0 
        """
        return _Evaluation.PerformanceMeasures_get_BAL(*args)

PerformanceMeasures_swigregister = _Evaluation.PerformanceMeasures_swigregister
PerformanceMeasures_swigregister(PerformanceMeasures)



