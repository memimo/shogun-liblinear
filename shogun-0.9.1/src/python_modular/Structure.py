# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.
# This file is compatible with both classic and new-style classes.

"""
The `Structure` module gathers all structure related learners available in the SHOGUN toolkit.
"""

import _Structure
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types


class ShogunException(_object):
    """Proxy of C++ ShogunException class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShogunException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ShogunException, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, str) -> ShogunException"""
        this = _Structure.new_ShogunException(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Structure.delete_ShogunException
    __del__ = lambda self : None;
    def get_exception_string(*args):
        """get_exception_string(self) -> str"""
        return _Structure.ShogunException_get_exception_string(*args)

ShogunException_swigregister = _Structure.ShogunException_swigregister
ShogunException_swigregister(ShogunException)

MSG_GCDEBUG = _Structure.MSG_GCDEBUG
MSG_DEBUG = _Structure.MSG_DEBUG
MSG_INFO = _Structure.MSG_INFO
MSG_NOTICE = _Structure.MSG_NOTICE
MSG_WARN = _Structure.MSG_WARN
MSG_ERROR = _Structure.MSG_ERROR
MSG_CRITICAL = _Structure.MSG_CRITICAL
MSG_ALERT = _Structure.MSG_ALERT
MSG_EMERGENCY = _Structure.MSG_EMERGENCY
MSG_MESSAGEONLY = _Structure.MSG_MESSAGEONLY
class IO(_object):
    """Proxy of C++ IO class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IO, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IO, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IO
        __init__(self, orig) -> IO
        """
        this = _Structure.new_IO(*args)
        try: self.this.append(this)
        except: self.this = this
    def set_loglevel(*args):
        """set_loglevel(self, level)"""
        return _Structure.IO_set_loglevel(*args)

    def get_loglevel(*args):
        """get_loglevel(self) -> EMessageType"""
        return _Structure.IO_get_loglevel(*args)

    def get_show_progress(*args):
        """get_show_progress(self) -> bool"""
        return _Structure.IO_get_show_progress(*args)

    def get_show_file_and_line(*args):
        """get_show_file_and_line(self) -> bool"""
        return _Structure.IO_get_show_file_and_line(*args)

    def message(*args):
        """message(self, prio, file, line, fmt, ?)"""
        return _Structure.IO_message(*args)

    def progress(*args):
        """
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1)
        progress(self, current_val, min_val=0.0, max_val=1.0)
        progress(self, current_val, min_val=0.0)
        progress(self, current_val)
        """
        return _Structure.IO_progress(*args)

    def absolute_progress(*args):
        """
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1)
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0)
        absolute_progress(self, current_val, val, min_val=0.0)
        absolute_progress(self, current_val, val)
        """
        return _Structure.IO_absolute_progress(*args)

    def done(*args):
        """done(self)"""
        return _Structure.IO_done(*args)

    def not_implemented(*args):
        """not_implemented(self, file, line)"""
        return _Structure.IO_not_implemented(*args)

    def deprecated(*args):
        """deprecated(self, file, line)"""
        return _Structure.IO_deprecated(*args)

    def buffered_message(*args):
        """buffered_message(self, prio, fmt, ?)"""
        return _Structure.IO_buffered_message(*args)

    def skip_spaces(*args):
        """skip_spaces(str) -> str"""
        return _Structure.IO_skip_spaces(*args)

    if _newclass:skip_spaces = staticmethod(skip_spaces)
    __swig_getmethods__["skip_spaces"] = lambda x: skip_spaces
    def skip_blanks(*args):
        """skip_blanks(str) -> str"""
        return _Structure.IO_skip_blanks(*args)

    if _newclass:skip_blanks = staticmethod(skip_blanks)
    __swig_getmethods__["skip_blanks"] = lambda x: skip_blanks
    def get_target(*args):
        """get_target(self) -> FILE"""
        return _Structure.IO_get_target(*args)

    def set_target(*args):
        """set_target(self, target)"""
        return _Structure.IO_set_target(*args)

    def set_target_to_stderr(*args):
        """set_target_to_stderr(self)"""
        return _Structure.IO_set_target_to_stderr(*args)

    def set_target_to_stdout(*args):
        """set_target_to_stdout(self)"""
        return _Structure.IO_set_target_to_stdout(*args)

    def enable_progress(*args):
        """enable_progress(self)"""
        return _Structure.IO_enable_progress(*args)

    def disable_progress(*args):
        """disable_progress(self)"""
        return _Structure.IO_disable_progress(*args)

    def enable_file_and_line(*args):
        """enable_file_and_line(self)"""
        return _Structure.IO_enable_file_and_line(*args)

    def disable_file_and_line(*args):
        """disable_file_and_line(self)"""
        return _Structure.IO_disable_file_and_line(*args)

    def set_dirname(*args):
        """set_dirname(dirname)"""
        return _Structure.IO_set_dirname(*args)

    if _newclass:set_dirname = staticmethod(set_dirname)
    __swig_getmethods__["set_dirname"] = lambda x: set_dirname
    def concat_filename(*args):
        """concat_filename(filename) -> str"""
        return _Structure.IO_concat_filename(*args)

    if _newclass:concat_filename = staticmethod(concat_filename)
    __swig_getmethods__["concat_filename"] = lambda x: concat_filename
    def filter(*args):
        """filter(d) -> int"""
        return _Structure.IO_filter(*args)

    if _newclass:filter = staticmethod(filter)
    __swig_getmethods__["filter"] = lambda x: filter
    def ref(*args):
        """ref(self) ->  int"""
        return _Structure.IO_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Structure.IO_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Structure.IO_unref(*args)

    def get_name(*args):
        """get_name(self) -> str"""
        return _Structure.IO_get_name(*args)

    __swig_destroy__ = _Structure.delete_IO
    __del__ = lambda self : None;
IO_swigregister = _Structure.IO_swigregister
IO_swigregister(IO)
cvar = _Structure.cvar

def IO_skip_spaces(*args):
  """IO_skip_spaces(str) -> str"""
  return _Structure.IO_skip_spaces(*args)

def IO_skip_blanks(*args):
  """IO_skip_blanks(str) -> str"""
  return _Structure.IO_skip_blanks(*args)

def IO_set_dirname(*args):
  """IO_set_dirname(dirname)"""
  return _Structure.IO_set_dirname(*args)

def IO_concat_filename(*args):
  """IO_concat_filename(filename) -> str"""
  return _Structure.IO_concat_filename(*args)

def IO_filter(*args):
  """IO_filter(d) -> int"""
  return _Structure.IO_filter(*args)

class SGObject(_object):
    """Proxy of C++ SGObject class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SGObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SGObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Structure.delete_SGObject
    __del__ = lambda self : None;
    def ref(*args):
        """ref(self) ->  int"""
        return _Structure.SGObject_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Structure.SGObject_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Structure.SGObject_unref(*args)

    def get_name(*args):
        """get_name(self) -> str"""
        return _Structure.SGObject_get_name(*args)

    __swig_setmethods__["io"] = _Structure.SGObject_io_set
    __swig_getmethods__["io"] = _Structure.SGObject_io_get
    if _newclass:io = _swig_property(_Structure.SGObject_io_get, _Structure.SGObject_io_set)
    __swig_setmethods__["parallel"] = _Structure.SGObject_parallel_set
    __swig_getmethods__["parallel"] = _Structure.SGObject_parallel_get
    if _newclass:parallel = _swig_property(_Structure.SGObject_parallel_get, _Structure.SGObject_parallel_set)
    __swig_setmethods__["version"] = _Structure.SGObject_version_set
    __swig_getmethods__["version"] = _Structure.SGObject_version_get
    if _newclass:version = _swig_property(_Structure.SGObject_version_get, _Structure.SGObject_version_set)
SGObject_swigregister = _Structure.SGObject_swigregister
SGObject_swigregister(SGObject)

class Version(_object):
    """Proxy of C++ Version class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Version, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Version, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self) -> Version"""
        this = _Structure.new_Version(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Structure.delete_Version
    __del__ = lambda self : None;
    def print_version(*args):
        """print_version()"""
        return _Structure.Version_print_version(*args)

    if _newclass:print_version = staticmethod(print_version)
    __swig_getmethods__["print_version"] = lambda x: print_version
    def get_version_extra(*args):
        """get_version_extra() -> str"""
        return _Structure.Version_get_version_extra(*args)

    if _newclass:get_version_extra = staticmethod(get_version_extra)
    __swig_getmethods__["get_version_extra"] = lambda x: get_version_extra
    def get_version_release(*args):
        """get_version_release() -> str"""
        return _Structure.Version_get_version_release(*args)

    if _newclass:get_version_release = staticmethod(get_version_release)
    __swig_getmethods__["get_version_release"] = lambda x: get_version_release
    def get_version_revision(*args):
        """get_version_revision() ->  int"""
        return _Structure.Version_get_version_revision(*args)

    if _newclass:get_version_revision = staticmethod(get_version_revision)
    __swig_getmethods__["get_version_revision"] = lambda x: get_version_revision
    def get_version_year(*args):
        """get_version_year() ->  int"""
        return _Structure.Version_get_version_year(*args)

    if _newclass:get_version_year = staticmethod(get_version_year)
    __swig_getmethods__["get_version_year"] = lambda x: get_version_year
    def get_version_month(*args):
        """get_version_month() ->  int"""
        return _Structure.Version_get_version_month(*args)

    if _newclass:get_version_month = staticmethod(get_version_month)
    __swig_getmethods__["get_version_month"] = lambda x: get_version_month
    def get_version_day(*args):
        """get_version_day() ->  int"""
        return _Structure.Version_get_version_day(*args)

    if _newclass:get_version_day = staticmethod(get_version_day)
    __swig_getmethods__["get_version_day"] = lambda x: get_version_day
    def get_version_hour(*args):
        """get_version_hour() ->  int"""
        return _Structure.Version_get_version_hour(*args)

    if _newclass:get_version_hour = staticmethod(get_version_hour)
    __swig_getmethods__["get_version_hour"] = lambda x: get_version_hour
    def get_version_minute(*args):
        """get_version_minute() ->  int"""
        return _Structure.Version_get_version_minute(*args)

    if _newclass:get_version_minute = staticmethod(get_version_minute)
    __swig_getmethods__["get_version_minute"] = lambda x: get_version_minute
    def get_version_in_minutes(*args):
        """get_version_in_minutes() -> int"""
        return _Structure.Version_get_version_in_minutes(*args)

    if _newclass:get_version_in_minutes = staticmethod(get_version_in_minutes)
    __swig_getmethods__["get_version_in_minutes"] = lambda x: get_version_in_minutes
    def ref(*args):
        """ref(self) ->  int"""
        return _Structure.Version_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Structure.Version_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Structure.Version_unref(*args)

Version_swigregister = _Structure.Version_swigregister
Version_swigregister(Version)

def Version_print_version(*args):
  """Version_print_version()"""
  return _Structure.Version_print_version(*args)

def Version_get_version_extra(*args):
  """Version_get_version_extra() -> str"""
  return _Structure.Version_get_version_extra(*args)

def Version_get_version_release(*args):
  """Version_get_version_release() -> str"""
  return _Structure.Version_get_version_release(*args)

def Version_get_version_revision(*args):
  """Version_get_version_revision() ->  int"""
  return _Structure.Version_get_version_revision(*args)

def Version_get_version_year(*args):
  """Version_get_version_year() ->  int"""
  return _Structure.Version_get_version_year(*args)

def Version_get_version_month(*args):
  """Version_get_version_month() ->  int"""
  return _Structure.Version_get_version_month(*args)

def Version_get_version_day(*args):
  """Version_get_version_day() ->  int"""
  return _Structure.Version_get_version_day(*args)

def Version_get_version_hour(*args):
  """Version_get_version_hour() ->  int"""
  return _Structure.Version_get_version_hour(*args)

def Version_get_version_minute(*args):
  """Version_get_version_minute() ->  int"""
  return _Structure.Version_get_version_minute(*args)

def Version_get_version_in_minutes(*args):
  """Version_get_version_in_minutes() -> int"""
  return _Structure.Version_get_version_in_minutes(*args)

class Parallel(_object):
    """Proxy of C++ Parallel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parallel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Parallel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Parallel
        __init__(self, orig) -> Parallel
        """
        this = _Structure.new_Parallel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Structure.delete_Parallel
    __del__ = lambda self : None;
    def get_num_cpus(*args):
        """get_num_cpus(self) ->  int"""
        return _Structure.Parallel_get_num_cpus(*args)

    def set_num_threads(*args):
        """set_num_threads(self, n)"""
        return _Structure.Parallel_set_num_threads(*args)

    def get_num_threads(*args):
        """get_num_threads(self) ->  int"""
        return _Structure.Parallel_get_num_threads(*args)

    def ref(*args):
        """ref(self) ->  int"""
        return _Structure.Parallel_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Structure.Parallel_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Structure.Parallel_unref(*args)

Parallel_swigregister = _Structure.Parallel_swigregister
Parallel_swigregister(Parallel)

class PySwigIterator(_object):
    """Proxy of C++ PySwigIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Structure.delete_PySwigIterator
    __del__ = lambda self : None;
    def value(*args):
        """value(self) -> PyObject"""
        return _Structure.PySwigIterator_value(*args)

    def incr(*args):
        """
        incr(self, n=1) -> PySwigIterator
        incr(self) -> PySwigIterator
        """
        return _Structure.PySwigIterator_incr(*args)

    def decr(*args):
        """
        decr(self, n=1) -> PySwigIterator
        decr(self) -> PySwigIterator
        """
        return _Structure.PySwigIterator_decr(*args)

    def distance(*args):
        """distance(self, x) -> ptrdiff_t"""
        return _Structure.PySwigIterator_distance(*args)

    def equal(*args):
        """equal(self, x) -> bool"""
        return _Structure.PySwigIterator_equal(*args)

    def copy(*args):
        """copy(self) -> PySwigIterator"""
        return _Structure.PySwigIterator_copy(*args)

    def next(*args):
        """next(self) -> PyObject"""
        return _Structure.PySwigIterator_next(*args)

    def previous(*args):
        """previous(self) -> PyObject"""
        return _Structure.PySwigIterator_previous(*args)

    def advance(*args):
        """advance(self, n) -> PySwigIterator"""
        return _Structure.PySwigIterator_advance(*args)

    def __eq__(*args):
        """__eq__(self, x) -> bool"""
        return _Structure.PySwigIterator___eq__(*args)

    def __ne__(*args):
        """__ne__(self, x) -> bool"""
        return _Structure.PySwigIterator___ne__(*args)

    def __iadd__(*args):
        """__iadd__(self, n) -> PySwigIterator"""
        return _Structure.PySwigIterator___iadd__(*args)

    def __isub__(*args):
        """__isub__(self, n) -> PySwigIterator"""
        return _Structure.PySwigIterator___isub__(*args)

    def __add__(*args):
        """__add__(self, n) -> PySwigIterator"""
        return _Structure.PySwigIterator___add__(*args)

    def __sub__(*args):
        """
        __sub__(self, n) -> PySwigIterator
        __sub__(self, x) -> ptrdiff_t
        """
        return _Structure.PySwigIterator___sub__(*args)

    def __iter__(self): return self
PySwigIterator_swigregister = _Structure.PySwigIterator_swigregister
PySwigIterator_swigregister(PySwigIterator)

class IntVector(_object):
    """Proxy of C++ IntVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _Structure.IntVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _Structure.IntVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(int)>::size_type"""
        return _Structure.IntVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(int)>::value_type"""
        return _Structure.IntVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> IntVector"""
        return _Structure.IntVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _Structure.IntVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _Structure.IntVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _Structure.IntVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(int)>::value_type"""
        return _Structure.IntVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _Structure.IntVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _Structure.IntVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _Structure.IntVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(int)>::size_type"""
        return _Structure.IntVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _Structure.IntVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _Structure.IntVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(int)>::allocator_type"""
        return _Structure.IntVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(int)>::const_iterator"""
        return _Structure.IntVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(int)>::const_iterator"""
        return _Structure.IntVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _Structure.IntVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _Structure.IntVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _Structure.IntVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(int)>::iterator
        erase(self, first, last) -> std::vector<(int)>::iterator
        """
        return _Structure.IntVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> IntVector
        __init__(self, ?) -> IntVector
        __init__(self, size) -> IntVector
        __init__(self, size, value) -> IntVector
        """
        this = _Structure.new_IntVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _Structure.IntVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(int)>::value_type"""
        return _Structure.IntVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(int)>::value_type"""
        return _Structure.IntVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _Structure.IntVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _Structure.IntVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(int)>::iterator
        insert(self, pos, n, x)
        """
        return _Structure.IntVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _Structure.IntVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(int)>::size_type"""
        return _Structure.IntVector_capacity(*args)

    __swig_destroy__ = _Structure.delete_IntVector
    __del__ = lambda self : None;
IntVector_swigregister = _Structure.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(_object):
    """Proxy of C++ DoubleVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _Structure.DoubleVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _Structure.DoubleVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(double)>::size_type"""
        return _Structure.DoubleVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(double)>::value_type"""
        return _Structure.DoubleVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> DoubleVector"""
        return _Structure.DoubleVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _Structure.DoubleVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _Structure.DoubleVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _Structure.DoubleVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(double)>::value_type"""
        return _Structure.DoubleVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _Structure.DoubleVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _Structure.DoubleVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _Structure.DoubleVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(double)>::size_type"""
        return _Structure.DoubleVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _Structure.DoubleVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _Structure.DoubleVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(double)>::allocator_type"""
        return _Structure.DoubleVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(double)>::const_iterator"""
        return _Structure.DoubleVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(double)>::const_iterator"""
        return _Structure.DoubleVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _Structure.DoubleVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _Structure.DoubleVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _Structure.DoubleVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(double)>::iterator
        erase(self, first, last) -> std::vector<(double)>::iterator
        """
        return _Structure.DoubleVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> DoubleVector
        __init__(self, ?) -> DoubleVector
        __init__(self, size) -> DoubleVector
        __init__(self, size, value) -> DoubleVector
        """
        this = _Structure.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _Structure.DoubleVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(double)>::value_type"""
        return _Structure.DoubleVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(double)>::value_type"""
        return _Structure.DoubleVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _Structure.DoubleVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _Structure.DoubleVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(double)>::iterator
        insert(self, pos, n, x)
        """
        return _Structure.DoubleVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _Structure.DoubleVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(double)>::size_type"""
        return _Structure.DoubleVector_capacity(*args)

    __swig_destroy__ = _Structure.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _Structure.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

class PlifBase(SGObject):
    """
    class PlifBase

    C++ includes: PlifBase.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PlifBase, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PlifBase, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Structure.delete_PlifBase
    __del__ = lambda self : None;
    def lookup_penalty(*args):
        """
        lookup_penalty(self, p_value, svm_values) -> float
        lookup_penalty(self, p_value, svm_values) -> float

        lookup penalty  int

        abstract base method

        Parameters:
        -----------

        p_value:  value

        svm_values:  SVM values

        penalty 
        """
        return _Structure.PlifBase_lookup_penalty(*args)

    def penalty_clear_derivative(*args):
        """
        penalty_clear_derivative(self)

        penalty clear derivative

        abstrace base method 
        """
        return _Structure.PlifBase_penalty_clear_derivative(*args)

    def penalty_add_derivative(*args):
        """
        penalty_add_derivative(self, p_value, svm_values, factor)

        penalty add derivative

        abstract base method

        Parameters:
        -----------

        p_value:  value

        svm_values:  SVM values

        factor:  factor weighting the added value 
        """
        return _Structure.PlifBase_penalty_add_derivative(*args)

    def get_max_value(*args):
        """
        get_max_value(self) -> float

        get maximum value

        abstract base method

        maximum value 
        """
        return _Structure.PlifBase_get_max_value(*args)

    def get_min_value(*args):
        """
        get_min_value(self) -> float

        get minimum value

        abstract base method

        minimum value 
        """
        return _Structure.PlifBase_get_min_value(*args)

    def get_used_svms(*args):
        """
        get_used_svms(self, num_svms, svm_ids)

        get SVM_ids and number of SVMs used

        abstract base method 
        """
        return _Structure.PlifBase_get_used_svms(*args)

    def uses_svm_values(*args):
        """
        uses_svm_values(self) -> bool

        if plif uses SVM values

        abstract base method

        if plif uses SVM values 
        """
        return _Structure.PlifBase_uses_svm_values(*args)

    def get_max_id(*args):
        """
        get_max_id(self) ->  int

        get maximum ID

        abstract base method

        maximum ID 
        """
        return _Structure.PlifBase_get_max_id(*args)

    def list_plif(*args):
        """
        list_plif(self)

        print PLIF

        abstract base method 
        """
        return _Structure.PlifBase_list_plif(*args)

PlifBase_swigregister = _Structure.PlifBase_swigregister
PlifBase_swigregister(PlifBase)

T_LINEAR = _Structure.T_LINEAR
T_LOG = _Structure.T_LOG
T_LOG_PLUS1 = _Structure.T_LOG_PLUS1
T_LOG_PLUS3 = _Structure.T_LOG_PLUS3
T_LINEAR_PLUS3 = _Structure.T_LINEAR_PLUS3
class Plif(PlifBase):
    """
    class Plif

    C++ includes: Plif.h 
    """
    __swig_setmethods__ = {}
    for _s in [PlifBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Plif, name, value)
    __swig_getmethods__ = {}
    for _s in [PlifBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Plif, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, len=0) -> Plif
        __init__(self) -> Plif

        constructor

        Parameters:
        -----------

        len:  len 
        """
        this = _Structure.new_Plif(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Structure.delete_Plif
    __del__ = lambda self : None;
    def init_penalty_struct_cache(*args):
        """
        init_penalty_struct_cache(self)

        init penalty struct cache 
        """
        return _Structure.Plif_init_penalty_struct_cache(*args)

    def lookup_penalty_svm(*args):
        """
        lookup_penalty_svm(self, p_value, d_values) -> float

        lookup penalty SVM

        Parameters:
        -----------

        p_value:  value

        d_values:  d values

        the penalty 
        """
        return _Structure.Plif_lookup_penalty_svm(*args)

    def lookup_penalty(*args):
        """
        lookup_penalty(self, p_value, svm_values) -> float
        lookup_penalty(self, p_value, svm_values) -> float

        lookup penalty  int

        Parameters:
        -----------

        p_value:  value

        svm_values:  SVM values

        the penalty 
        """
        return _Structure.Plif_lookup_penalty(*args)

    def lookup(*args):
        """
        lookup(self, p_value) -> float

        lookup

        Parameters:
        -----------

        p_value:  value

        a penalty 
        """
        return _Structure.Plif_lookup(*args)

    def penalty_add_derivative_svm(*args):
        """
        penalty_add_derivative_svm(self, p_value, svm_values, factor)

        penalty add derivative SVM

        Parameters:
        -----------

        p_value:  value

        svm_values:  SVM values

        factor:  factor weighting the added value 
        """
        return _Structure.Plif_penalty_add_derivative_svm(*args)

    def get_cum_derivative(*args):
        """
        get_cum_derivative(self, p_len) -> float

        get cum derivative

        Parameters:
        -----------

        p_len:  len

        cum derivative 
        """
        return _Structure.Plif_get_cum_derivative(*args)

    def set_transform_type(*args):
        """
        set_transform_type(self, type_str) -> bool

        set transform type

        Parameters:
        -----------

        type_str:  type (string)

        if setting was successful 
        """
        return _Structure.Plif_set_transform_type(*args)

    def get_transform_type(*args):
        """
        get_transform_type(self) -> str

        get transform type

        type_str type (string) 
        """
        return _Structure.Plif_get_transform_type(*args)

    def set_id(*args):
        """
        set_id(self, p_id)

        set ID

        Parameters:
        -----------

        p_id:  the id to set 
        """
        return _Structure.Plif_set_id(*args)

    def get_id(*args):
        """
        get_id(self) ->  int

        get ID

        the ID 
        """
        return _Structure.Plif_get_id(*args)

    def set_use_svm(*args):
        """
        set_use_svm(self, p_use_svm)

        set use SVM

        Parameters:
        -----------

        p_use_svm:  if SVM shall be used 
        """
        return _Structure.Plif_set_use_svm(*args)

    def get_use_svm(*args):
        """
        get_use_svm(self) ->  int

        get use SVM

        if SVM is used 
        """
        return _Structure.Plif_get_use_svm(*args)

    def set_use_cache(*args):
        """
        set_use_cache(self, p_use_cache)

        set use cache

        Parameters:
        -----------

        p_use_cache:  if cache shall be used 
        """
        return _Structure.Plif_set_use_cache(*args)

    def invalidate_cache(*args):
        """
        invalidate_cache(self)

        invalidate the cache 
        """
        return _Structure.Plif_invalidate_cache(*args)

    def get_use_cache(*args):
        """
        get_use_cache(self) ->  int

        get use cache

        if cache is used 
        """
        return _Structure.Plif_get_use_cache(*args)

    def set_plif(*args):
        """
        set_plif(self, p_len, p_limits, p_penalties)

        set plif

        Parameters:
        -----------

        p_len:  len

        p_limits:  limit

        p_penalties:  penalties 
        """
        return _Structure.Plif_set_plif(*args)

    def set_plif_limits(*args):
        """
        set_plif_limits(self, p_limits)

        set plif_limits

        Parameters:
        -----------

        p_limits:  limit

        p_len:  len 
        """
        return _Structure.Plif_set_plif_limits(*args)

    def set_plif_penalty(*args):
        """
        set_plif_penalty(self, p_penalties)

        set plif penalty

        Parameters:
        -----------

        p_penalties:  penalties

        p_len:  len 
        """
        return _Structure.Plif_set_plif_penalty(*args)

    def set_plif_length(*args):
        """
        set_plif_length(self, p_len)

        set plif length

        Parameters:
        -----------

        p_len:  len 
        """
        return _Structure.Plif_set_plif_length(*args)

    def get_plif_limits(*args):
        """
        get_plif_limits(self) -> float

        get Plif limits

        limits 
        """
        return _Structure.Plif_get_plif_limits(*args)

    def get_plif_penalties(*args):
        """
        get_plif_penalties(self) -> float

        get plif penalty

        plif penalty 
        """
        return _Structure.Plif_get_plif_penalties(*args)

    def set_max_value(*args):
        """
        set_max_value(self, p_max_value)

        set maximum value

        Parameters:
        -----------

        p_max_value:  maximum value 
        """
        return _Structure.Plif_set_max_value(*args)

    def set_min_value(*args):
        """
        set_min_value(self, p_min_value)

        set minimum value

        Parameters:
        -----------

        p_min_value:  minimum value 
        """
        return _Structure.Plif_set_min_value(*args)

    def set_plif_name(*args):
        """
        set_plif_name(self, p_name)

        set name

        Parameters:
        -----------

        p_name:  name 
        """
        return _Structure.Plif_set_plif_name(*args)

    def get_plif_name(*args):
        """
        get_plif_name(self) -> str

        get name

        name 
        """
        return _Structure.Plif_get_plif_name(*args)

    def get_do_calc(*args):
        """
        get_do_calc(self) -> bool

        get do calc

        if calc shall be done 
        """
        return _Structure.Plif_get_do_calc(*args)

    def set_do_calc(*args):
        """
        set_do_calc(self, b)

        set do calc

        Parameters:
        -----------

        b:  if calc shall be done 
        """
        return _Structure.Plif_set_do_calc(*args)

    def get_plif_len(*args):
        """
        get_plif_len(self) ->  int

        get plif len

        plif len 
        """
        return _Structure.Plif_get_plif_len(*args)

    def delete_penalty_struct(*args):
        """delete_penalty_struct(PEN, P)"""
        return _Structure.Plif_delete_penalty_struct(*args)

    if _newclass:delete_penalty_struct = staticmethod(delete_penalty_struct)
    __swig_getmethods__["delete_penalty_struct"] = lambda x: delete_penalty_struct
Plif_swigregister = _Structure.Plif_swigregister
Plif_swigregister(Plif)

def Plif_delete_penalty_struct(*args):
  """Plif_delete_penalty_struct(PEN, P)"""
  return _Structure.Plif_delete_penalty_struct(*args)

class PlifArray(PlifBase):
    """
    class PlifArray

    C++ includes: PlifArray.h 
    """
    __swig_setmethods__ = {}
    for _s in [PlifBase]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PlifArray, name, value)
    __swig_getmethods__ = {}
    for _s in [PlifBase]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PlifArray, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> PlifArray

        default constructor 
        """
        this = _Structure.new_PlifArray(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Structure.delete_PlifArray
    __del__ = lambda self : None;
    def add_plif(*args):
        """
        add_plif(self, new_plif)

        add plif

        Parameters:
        -----------

        new_plif:  the new plif to be added 
        """
        return _Structure.PlifArray_add_plif(*args)

    def clear(*args):
        """
        clear(self)

        clear 
        """
        return _Structure.PlifArray_clear(*args)

    def get_num_plifs(*args):
        """
        get_num_plifs(self) ->  int

        get number of plifs

        number of plifs 
        """
        return _Structure.PlifArray_get_num_plifs(*args)

    def lookup_penalty(*args):
        """
        lookup_penalty(self, p_value, svm_values) -> float
        lookup_penalty(self, p_value, svm_values) -> float

        lookup penalty  int

        Parameters:
        -----------

        p_value:  value

        svm_values:  SVM values 
        """
        return _Structure.PlifArray_lookup_penalty(*args)

PlifArray_swigregister = _Structure.PlifArray_swigregister
PlifArray_swigregister(PlifArray)

class DynProg(SGObject):
    """
    Dynamic Programming Class.

    Structure and Function collection. This Class implements a Dynamic
    Programming functions.

    C++ includes: DynProg.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynProg, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DynProg, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, p_num_svms=8) -> DynProg
        __init__(self) -> DynProg

        constructor

        Parameters:
        -----------

        p_num_svms:  number of SVMs 
        """
        this = _Structure.new_DynProg(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Structure.delete_DynProg
    __del__ = lambda self : None;
    def best_path_no_b(*args):
        """
        best_path_no_b(self, max_iter, best_iter, my_path) -> float

        best path no b

        Parameters:
        -----------

        max_iter:  max iter

        best_iter:  best iter

        my_path:  my path

        best path no b 
        """
        return _Structure.DynProg_best_path_no_b(*args)

    def best_path_no_b_trans(*args):
        """
        best_path_no_b_trans(self, max_iter, max_best_iter, nbest, prob_nbest, my_paths)

        best path no b transition

        Parameters:
        -----------

        max_iter:  max iter

        max_best_iter:  max best iter

        nbest:  nbest

        prob_nbest:  prob_nbest

        my_paths:  my paths 
        """
        return _Structure.DynProg_best_path_no_b_trans(*args)

    def set_num_states(*args):
        """
        set_num_states(self, N)

        set number of states use this to set N first

        Parameters:
        -----------

        N:  new N 
        """
        return _Structure.DynProg_set_num_states(*args)

    def get_num_states(*args):
        """
        get_num_states(self) ->  int

        get num states 
        """
        return _Structure.DynProg_get_num_states(*args)

    def get_num_svms(*args):
        """
        get_num_svms(self) ->  int

        get num svms 
        """
        return _Structure.DynProg_get_num_svms(*args)

    def init_content_svm_value_array(*args):
        """
        init_content_svm_value_array(self, p_num_svms)

        init CArray for precomputed content svm values with size seq_len x
        num_svms

        Parameters:
        -----------

        p_num_svms:  ::  number of svm weight vectors for content prediction

        """
        return _Structure.DynProg_init_content_svm_value_array(*args)

    def init_tiling_data(*args):
        """
        init_tiling_data(self, probe_pos, intensities, num_probes)

        init CArray for precomputed tiling intensitie-plif-values with size
        seq_len x num_svms

        Parameters:
        -----------

        probe_pos:  local positions of probes

        intensities:  intensities of probes

        num_probes:  number of probes 
        """
        return _Structure.DynProg_init_tiling_data(*args)

    def precompute_tiling_plifs(*args):
        """
        precompute_tiling_plifs(self, PEN, tiling_plif_ids, num_tiling_plifs)

        precompute tiling Plifs

        Parameters:
        -----------

        PEN:  Plif PEN

        tiling_plif_ids:  tiling plif id's

        num_tiling_plifs:  number of tiling plifs 
        """
        return _Structure.DynProg_precompute_tiling_plifs(*args)

    def resize_lin_feat(*args):
        """
        resize_lin_feat(self, num_new_feat)

        append rows to linear features array

        Parameters:
        -----------

        num_new_feat:  number of new rows to add 
        """
        return _Structure.DynProg_resize_lin_feat(*args)

    def set_p_vector(*args):
        """
        set_p_vector(self, p)

        set vector p

        Parameters:
        -----------

        p:  new vector p

        N:  size of vector p 
        """
        return _Structure.DynProg_set_p_vector(*args)

    def set_q_vector(*args):
        """
        set_q_vector(self, q)

        set vector q

        Parameters:
        -----------

        q:  new vector q

        N:  size of vector q 
        """
        return _Structure.DynProg_set_q_vector(*args)

    def set_a_id(*args):
        """
        set_a_id(self, a, M, N)

        set a id

        Parameters:
        -----------

        a:  new a id (identity?)

        M:  dimension M of matrix a

        N:  dimension N of matrix a 
        """
        return _Structure.DynProg_set_a_id(*args)

    def set_a_trans_matrix(*args):
        """
        set_a_trans_matrix(self, a_trans)

        set a transition matrix

        Parameters:
        -----------

        a_trans:  transition matrix a

        num_trans:  number of transitions

        N:  dimension N of matrix a 
        """
        return _Structure.DynProg_set_a_trans_matrix(*args)

    def init_mod_words_array(*args):
        """
        init_mod_words_array(self, p_mod_words_array)

        init mod words array

        Parameters:
        -----------

        p_mod_words_array:  new mod words array

        num_elem:  number of array elements

        num_columns:  number of columns 
        """
        return _Structure.DynProg_init_mod_words_array(*args)

    def check_svm_arrays(*args):
        """
        check_svm_arrays(self) -> bool

        check SVM arrays call this function to check consistency

        whether arrays are ok 
        """
        return _Structure.DynProg_check_svm_arrays(*args)

    def set_observation_matrix(*args):
        """
        set_observation_matrix(self, seq)

        set best path seq

        Parameters:
        -----------

        seq:  signal features

        dims:  dimensions

        ndims:  number of dimensions 
        """
        return _Structure.DynProg_set_observation_matrix(*args)

    def get_num_positions(*args):
        """
        get_num_positions(self) ->  int

        get number of positions; the dynamic program is sparse encoded and
        this function gives the number of positions that can actually be part
        of a predicted path

        number of positions 
        """
        return _Structure.DynProg_get_num_positions(*args)

    def set_content_type_array(*args):
        """
        set_content_type_array(self, seg_path)

        set an array of length #(candidate positions) which specifies the
        content type of each pos and a mask that determines to which extend
        the loss should be applied to this position; this is a way to encode
        label confidence via weights between zero and one

        Parameters:
        -----------

        seg_path:  seg path

        rows:  rows

        cols:  cols 
        """
        return _Structure.DynProg_set_content_type_array(*args)

    def set_pos(*args):
        """
        set_pos(self, pos)

        set best path pos

        Parameters:
        -----------

        pos:  the position

        seq_len:  length of sequence 
        """
        return _Structure.DynProg_set_pos(*args)

    def set_orf_info(*args):
        """
        set_orf_info(self, orf_info)

        set best path orf info only for compute_nbest_paths

        Parameters:
        -----------

        orf_info:  the orf info

        m:  dimension m

        n:  dimension n 
        """
        return _Structure.DynProg_set_orf_info(*args)

    def set_gene_string(*args):
        """
        set_gene_string(self, genestr)

        set best path genesstr

        Parameters:
        -----------

        genestr:  gene string

        genestr_len:  length of gene string 
        """
        return _Structure.DynProg_set_gene_string(*args)

    def set_dict_weights(*args):
        """
        set_dict_weights(self, dictionary_weights)

        set best path dict weights

        Parameters:
        -----------

        dictionary_weights:  dictionary weights

        dict_len:  length of dictionary weights

        n:  dimension n 
        """
        return _Structure.DynProg_set_dict_weights(*args)

    def best_path_set_segment_loss(*args):
        """
        best_path_set_segment_loss(self, segment_loss)

        set best path segment loss

        Parameters:
        -----------

        segment_loss:  segment loss

        num_segment_id1:  number of segment id1

        num_segment_id2:  number of segment id2 
        """
        return _Structure.DynProg_best_path_set_segment_loss(*args)

    def best_path_set_segment_ids_mask(*args):
        """
        best_path_set_segment_ids_mask(self, segment_ids, segment_mask, m)

        set best path segmend ids mask

        Parameters:
        -----------

        segment_ids:  segment ids

        segment_mask:  segment mask

        m:  dimension m 
        """
        return _Structure.DynProg_best_path_set_segment_ids_mask(*args)

    def set_sparse_features(*args):
        """
        set_sparse_features(self, seq_sparse1, seq_sparse2)

        set sparse feature matrices 
        """
        return _Structure.DynProg_set_sparse_features(*args)

    def set_plif_matrices(*args):
        """
        set_plif_matrices(self, pm)

        set plif matrices

        Parameters:
        -----------

        pm:  plif matrix object 
        """
        return _Structure.DynProg_set_plif_matrices(*args)

    def get_scores(*args):
        """
        get_scores(self, scores)

        best path get scores

        Parameters:
        -----------

        scores:  scores

        n:  dimension n 
        """
        return _Structure.DynProg_get_scores(*args)

    def get_states(*args):
        """
        get_states(self, states)

        best path get states

        Parameters:
        -----------

        states:  states

        m:  dimension m

        n:  dimension n 
        """
        return _Structure.DynProg_get_states(*args)

    def get_positions(*args):
        """
        get_positions(self, positions)

        best path get positions

        Parameters:
        -----------

        positions:  positions

        m:  dimension m

        n:  dimension n 
        """
        return _Structure.DynProg_get_positions(*args)

    def compute_nbest_paths(*args):
        """
        compute_nbest_paths(self, max_num_signals, use_orf, nbest, with_loss, with_multiple_sequences)

        run the viterbi algorithm to compute the n best viterbi paths

        Parameters:
        -----------

        max_num_signals:  maximal number of signals for a single state

        use_orf:  whether orf shall be used

        nbest:  number of best paths (n)

        with_loss:  use loss

        with_multiple_sequences:  !!!not functional set to false!!! 
        """
        return _Structure.DynProg_compute_nbest_paths(*args)

    def best_path_trans_deriv(*args):
        """
        best_path_trans_deriv(self, my_state_seq, my_pos_seq, my_seq_len, seq_array, max_num_signals)

        given a path though the state model and the corresponding positions
        compute the features. This can be seen as the derivative of the score
        (output of dynamic program) with respect to the parameters

        Parameters:
        -----------

        my_state_seq:  state sequence of the path

        my_pos_seq:  sequence of positions

        my_seq_len:  length of state and position sequences

        seq_array:  array of features

        max_num_signals:  maximal number of signals 
        """
        return _Structure.DynProg_best_path_trans_deriv(*args)

    def set_my_state_seq(*args):
        """
        set_my_state_seq(self, my_state_seq)

        set best path my state sequence

        Parameters:
        -----------

        my_state_seq:  my state sequence 
        """
        return _Structure.DynProg_set_my_state_seq(*args)

    def set_my_pos_seq(*args):
        """
        set_my_pos_seq(self, my_pos_seq)

        set best path my position sequence

        Parameters:
        -----------

        my_pos_seq:  my position sequence 
        """
        return _Structure.DynProg_set_my_pos_seq(*args)

    def get_path_scores(*args):
        """
        get_path_scores(self, my_scores, seq_len)

        get path scores

        best_path_trans_deriv result retrieval functions

        Parameters:
        -----------

        my_scores:  scores

        seq_len:  length of sequence 
        """
        return _Structure.DynProg_get_path_scores(*args)

    def get_path_losses(*args):
        """
        get_path_losses(self, my_losses)

        get path losses

        best_path_trans_deriv result retrieval functions

        Parameters:
        -----------

        my_losses:  my losses

        seq_len:  length of sequence 
        """
        return _Structure.DynProg_get_path_losses(*args)

    def get_N(*args):
        """
        get_N(self) -> T_STATES

        access function for number of states N 
        """
        return _Structure.DynProg_get_N(*args)

    def set_q(*args):
        """
        set_q(self, offset, value)

        access function for probability of end states

        Parameters:
        -----------

        offset:  index 0...N-1

        value:  value to be set 
        """
        return _Structure.DynProg_set_q(*args)

    def set_p(*args):
        """
        set_p(self, offset, value)

        access function for probability of first state

        Parameters:
        -----------

        offset:  index 0...N-1

        value:  value to be set 
        """
        return _Structure.DynProg_set_p(*args)

    def set_a(*args):
        """
        set_a(self, a)
        set_a(self, line_, column, value)

        access function for matrix a

        Parameters:
        -----------

        line_:  row in matrix 0...N-1

        column:  column in matrix 0...N-1

        value:  value to be set 
        """
        return _Structure.DynProg_set_a(*args)

    def get_q(*args):
        """
        get_q(self, offset) -> float

        access function for probability of end states

        Parameters:
        -----------

        offset:  index 0...N-1

        value at offset 
        """
        return _Structure.DynProg_get_q(*args)

    def get_q_deriv(*args):
        """
        get_q_deriv(self, offset) -> float

        access function for derivated probability of end states

        Parameters:
        -----------

        offset:  index 0...N-1

        value at offset 
        """
        return _Structure.DynProg_get_q_deriv(*args)

    def get_p(*args):
        """
        get_p(self, offset) -> float

        access function for probability of initial states

        Parameters:
        -----------

        offset:  index 0...N-1

        value at offset 
        """
        return _Structure.DynProg_get_p(*args)

    def get_p_deriv(*args):
        """
        get_p_deriv(self, offset) -> float

        access function for derivated probability of initial states

        Parameters:
        -----------

        offset:  index 0...N-1

        value at offset 
        """
        return _Structure.DynProg_get_p_deriv(*args)

    def precompute_content_values(*args):
        """
        precompute_content_values(self)

        create array of precomputed content svm values 
        """
        return _Structure.DynProg_precompute_content_values(*args)

    def get_lin_feat(*args):
        """
        get_lin_feat(self, dim1, dim2) -> float

        return array of precomputed linear features like content predictions
        and PLiFed tiling array data Jonas

        lin_feat_array 
        """
        return _Structure.DynProg_get_lin_feat(*args)

    def set_lin_feat(*args):
        """
        set_lin_feat(self, p_lin_feat, p_num_svms, p_seq_len)

        set your own array of precomputed linear features like content
        predictions and PLiFed tiling array data Jonas

        Parameters:
        -----------

        p_lin_feat:  array of features

        p_num_svms:  number of tracks

        p_seq_len:  number of candidate positions 
        """
        return _Structure.DynProg_set_lin_feat(*args)

    def create_word_string(*args):
        """
        create_word_string(self)

        create word string from str* Jonas 
        """
        return _Structure.DynProg_create_word_string(*args)

    def precompute_stop_codons(*args):
        """
        precompute_stop_codons(self)

        precompute stop codons 
        """
        return _Structure.DynProg_precompute_stop_codons(*args)

    def get_a(*args):
        """
        get_a(self, line_, column) -> float

        access function for matrix a

        Parameters:
        -----------

        line_:  row in matrix 0...N-1

        column:  column in matrix 0...N-1

        value at position line colum 
        """
        return _Structure.DynProg_get_a(*args)

    def get_a_deriv(*args):
        """
        get_a_deriv(self, line_, column) -> float

        access function for matrix a derivated

        Parameters:
        -----------

        line_:  row in matrix 0...N-1

        column:  column in matrix 0...N-1

        value at position line colum 
        """
        return _Structure.DynProg_get_a_deriv(*args)

    def set_intron_list(*args):
        """
        set_intron_list(self, intron_list, num_plifs)

        set intron list

        Parameters:
        -----------

        intron_list:

        num_plifs:  number of intron plifs 
        """
        return _Structure.DynProg_set_intron_list(*args)

    def get_segment_loss_object(*args):
        """
        get_segment_loss_object(self) -> SegmentLoss

        get the segment loss object 
        """
        return _Structure.DynProg_get_segment_loss_object(*args)

    def long_transition_settings(*args):
        """
        long_transition_settings(self, use_long_transitions, threshold, max_len)

        settings for long transition handling

        Parameters:
        -----------

        use_long_transitions:  use the long transition approximation

        threshold:  use long transition for segments larger than

        max_len:  allow transitions up to 
        """
        return _Structure.DynProg_long_transition_settings(*args)

DynProg_swigregister = _Structure.DynProg_swigregister
DynProg_swigregister(DynProg)

class PlifMatrix(SGObject):
    """
    store plif arrays for all transitions in the model

    C++ includes: PlifMatrix.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PlifMatrix, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PlifMatrix, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> PlifMatrix

        constructor 
        """
        this = _Structure.new_PlifMatrix(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Structure.delete_PlifMatrix
    __del__ = lambda self : None;
    def get_PEN(*args):
        """
        get_PEN(self) -> Plif

        get array of all plifs

        plif array 
        """
        return _Structure.PlifMatrix_get_PEN(*args)

    def get_plif_matrix(*args):
        """
        get_plif_matrix(self) -> PlifBase

        get plif matrix

        matrix of plifs 
        """
        return _Structure.PlifMatrix_get_plif_matrix(*args)

    def get_state_signals(*args):
        """
        get_state_signals(self) -> PlifBase

        get plifs defining the mapping of signals to states

        plifs 
        """
        return _Structure.PlifMatrix_get_state_signals(*args)

    def get_num_plifs(*args):
        """
        get_num_plifs(self) ->  int

        get number of plifs

        number of plifs 
        """
        return _Structure.PlifMatrix_get_num_plifs(*args)

    def get_num_limits(*args):
        """
        get_num_limits(self) ->  int

        get number of support points for picewise linear transformations
        (PLiFs)

        number of support points 
        """
        return _Structure.PlifMatrix_get_num_limits(*args)

    def create_plifs(*args):
        """
        create_plifs(self, num_plifs, num_limits)

        create an empty plif matrix of size num_plifs * num_limits

        Parameters:
        -----------

        num_plifs:  number of plifs

        num_limits:  number of plif limits 
        """
        return _Structure.PlifMatrix_create_plifs(*args)

    def set_plif_ids(*args):
        """
        set_plif_ids(self, ids)

        set plif ids

        Parameters:
        -----------

        ids:  plif ids

        num_ids:  number of ids 
        """
        return _Structure.PlifMatrix_set_plif_ids(*args)

    def set_plif_min_values(*args):
        """
        set_plif_min_values(self, min_values)

        set array of min values for all plifs

        Parameters:
        -----------

        min_values:  array of min values

        num_values:  length of array 
        """
        return _Structure.PlifMatrix_set_plif_min_values(*args)

    def set_plif_max_values(*args):
        """
        set_plif_max_values(self, max_values)

        set array of max values for all plifs

        Parameters:
        -----------

        max_values:  array of max values

        num_values:  length of array 
        """
        return _Structure.PlifMatrix_set_plif_max_values(*args)

    def set_plif_use_cache(*args):
        """
        set_plif_use_cache(self, use_cache)

        set plif use cache

        Parameters:
        -----------

        use_cache:  set array of bool values

        num_values:  length of array 
        """
        return _Structure.PlifMatrix_set_plif_use_cache(*args)

    def set_plif_use_svm(*args):
        """
        set_plif_use_svm(self, use_svm)

        set plif use svm

        Parameters:
        -----------

        use_svm:  use svm

        num_values:  length of array 
        """
        return _Structure.PlifMatrix_set_plif_use_svm(*args)

    def set_plif_limits(*args):
        """
        set_plif_limits(self, limits)

        set all abscissa values of the support points for the for the pice
        wise linear transformations (PLiFs)

        Parameters:
        -----------

        limits:  array of length num_plifs*num_limits

        num_plifs:  number of plifs

        num_limits:  number of support vectors 
        """
        return _Structure.PlifMatrix_set_plif_limits(*args)

    def set_plif_penalties(*args):
        """
        set_plif_penalties(self, penalties)

        set all ordinate values of the support points for the for the pice
        wise linear transformations (PLiFs)

        Parameters:
        -----------

        penalties:  plif values: array of length num_plifs*num_limits

        num_plifs:  number of plifs

        num_limits:  number of support vectors 
        """
        return _Structure.PlifMatrix_set_plif_penalties(*args)

    def set_plif_names(*args):
        """
        set_plif_names(self, names, num_values, maxlen=0)
        set_plif_names(self, names, num_values)

        set names for the PLiFs

        Parameters:
        -----------

        names:  names

        num_values:  number of names

        maxlen:  maximal string len of the names 
        """
        return _Structure.PlifMatrix_set_plif_names(*args)

    def set_plif_transform_type(*args):
        """
        set_plif_transform_type(self, transform_type, num_values, maxlen=0)
        set_plif_transform_type(self, transform_type, num_values)

        set plif transform type; for some features the plifs live in log space
        therefore the input values have to be transformed to log space before
        the transformation can be applied; the transform type is string coded

        Parameters:
        -----------

        transform_type:  transform type (e.g. LOG(x), LOG(x+1), ...)

        num_values:  number of transform strings

        maxlen:  of transform strings 
        """
        return _Structure.PlifMatrix_set_plif_transform_type(*args)

    def get_plif_id(*args):
        """
        get_plif_id(self, idx) ->  int

        return plif id for idx

        Parameters:
        -----------

        idx:  idx of plif

        id of plif 
        """
        return _Structure.PlifMatrix_get_plif_id(*args)

    def compute_plif_matrix(*args):
        """
        compute_plif_matrix(self, penalties_array) -> bool

        parse an 3D array of plif ids and compute the corresponding 2D plif
        matrix by subsuming the third dim into one PlifArray; Note: the class
        PlifArray is derived from PlifBase. It computes all individual plifs
        and sums them up.

        Parameters:
        -----------

        penalties_array:  3D array of plif ids (nofstates x nofstates x
        nof(features for each transition))

        Dim:  array of dimensions

        numDims:  number of dimensions

        success 
        """
        return _Structure.PlifMatrix_compute_plif_matrix(*args)

    def compute_signal_plifs(*args):
        """
        compute_signal_plifs(self, state_signals) -> bool

        parse an 3D array of plif ids and compute the corresponding 3D plif
        array;

        Parameters:
        -----------

        state_signals:  mapping of features to states

        feat_dim3:  maximal number of features to be considered in one state

        num_states:  number of states

        success 
        """
        return _Structure.PlifMatrix_compute_signal_plifs(*args)

    def set_plif_state_signal_matrix(*args):
        """
        set_plif_state_signal_matrix(self, plif_id_matrix)

        set best path plif state signal matrix

        Parameters:
        -----------

        plif_id_matrix:  plif id matrix

        m:  dimension m of matrix

        n:  dimension n of matrix 
        """
        return _Structure.PlifMatrix_set_plif_state_signal_matrix(*args)

PlifMatrix_swigregister = _Structure.PlifMatrix_swigregister
PlifMatrix_swigregister(PlifMatrix)

class IntronList(SGObject):
    """
    class IntronList

    C++ includes: IntronList.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntronList, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntronList, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IntronList

        constructor 
        """
        this = _Structure.new_IntronList(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Structure.delete_IntronList
    __del__ = lambda self : None;
    def init_list(*args):
        """
        init_list(self, all_pos, len)

        initialize all arrays with the number of candidate positions

        Parameters:
        -----------

        all_pos:  list of candidate positions

        len:  number of candidate positions 
        """
        return _Structure.IntronList_init_list(*args)

    def read_introns(*args):
        """
        read_introns(self, start_pos, end_pos, quality, len)

        read introns

        Parameters:
        -----------

        start_pos:  array of start positions

        end_pos:  array of end positions

        quality:  quality scores for introns in list

        len:  number of items in all three previous arguments 
        """
        return _Structure.IntronList_read_introns(*args)

    def get_intron_support(*args):
        """
        get_intron_support(self, values, from_pos, to_pos)

        get coverage and quality score

        Parameters:
        -----------

        values:  values[0]: coverage of that intron; values[1]: associated
        quality score

        from_pos:  start position of intron

        to_pos:  end position of intron 
        """
        return _Structure.IntronList_get_intron_support(*args)

IntronList_swigregister = _Structure.IntronList_swigregister
IntronList_swigregister(IntronList)

class SegmentLoss(SGObject):
    """
    class IntronList

    C++ includes: SegmentLoss.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SegmentLoss, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SegmentLoss, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> SegmentLoss

        constructor 
        """
        this = _Structure.new_SegmentLoss(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Structure.delete_SegmentLoss
    __del__ = lambda self : None;
    def get_segment_loss(*args):
        """
        get_segment_loss(self, from_pos, to_pos, segment_id) -> float

        get segment loss for a given range

        Parameters:
        -----------

        from_pos:  start position

        to_pos:  end position

        segment_id:  type of the segment 
        """
        return _Structure.SegmentLoss_get_segment_loss(*args)

    def get_segment_loss_extend(*args):
        """
        get_segment_loss_extend(self, from_pos, to_pos, segment_id) -> float

        get segment loss for a given range

        Parameters:
        -----------

        from_pos:  start position

        to_pos:  end position

        segment_id:  type of the segment 
        """
        return _Structure.SegmentLoss_get_segment_loss_extend(*args)

    def set_segment_loss(*args):
        """
        set_segment_loss(self, segment_loss, m, n)

        set best path segment loss

        Parameters:
        -----------

        segment_loss:  segment loss

        m:  number of segment id1

        n:  number of segment id2 
        """
        return _Structure.SegmentLoss_set_segment_loss(*args)

    def set_segment_ids(*args):
        """
        set_segment_ids(self, segment_ids)

        set best path segmend ids

        Parameters:
        -----------

        segment_ids:  segment ids 
        """
        return _Structure.SegmentLoss_set_segment_ids(*args)

    def set_segment_mask(*args):
        """
        set_segment_mask(self, segment_mask)

        mask parts of the sequence such that there is no loss incured there;
        this is used if there is uncertainty in the label

        Parameters:
        -----------

        segment_mask:  mask 
        """
        return _Structure.SegmentLoss_set_segment_mask(*args)

    def set_num_segment_types(*args):
        """
        set_num_segment_types(self, num_segment_types)

        set num segment types

        Parameters:
        -----------

        num_segment_types:  num segment types 
        """
        return _Structure.SegmentLoss_set_num_segment_types(*args)

    def compute_loss(*args):
        """
        compute_loss(self, all_pos, len)

        compute loss

        Parameters:
        -----------

        all_pos:  all candidate positions

        len:  number of positions 
        """
        return _Structure.SegmentLoss_compute_loss(*args)

SegmentLoss_swigregister = _Structure.SegmentLoss_swigregister
SegmentLoss_swigregister(SegmentLoss)



