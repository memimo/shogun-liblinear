# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.
# This file is compatible with both classic and new-style classes.

"""
The `Clustering` module gathers all clustering methods available in the SHOGUN toolkit.
"""

import _Clustering
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types


class ShogunException(_object):
    """Proxy of C++ ShogunException class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShogunException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ShogunException, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, str) -> ShogunException"""
        this = _Clustering.new_ShogunException(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Clustering.delete_ShogunException
    __del__ = lambda self : None;
    def get_exception_string(*args):
        """get_exception_string(self) -> str"""
        return _Clustering.ShogunException_get_exception_string(*args)

ShogunException_swigregister = _Clustering.ShogunException_swigregister
ShogunException_swigregister(ShogunException)

MSG_GCDEBUG = _Clustering.MSG_GCDEBUG
MSG_DEBUG = _Clustering.MSG_DEBUG
MSG_INFO = _Clustering.MSG_INFO
MSG_NOTICE = _Clustering.MSG_NOTICE
MSG_WARN = _Clustering.MSG_WARN
MSG_ERROR = _Clustering.MSG_ERROR
MSG_CRITICAL = _Clustering.MSG_CRITICAL
MSG_ALERT = _Clustering.MSG_ALERT
MSG_EMERGENCY = _Clustering.MSG_EMERGENCY
MSG_MESSAGEONLY = _Clustering.MSG_MESSAGEONLY
class IO(_object):
    """Proxy of C++ IO class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IO, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IO, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IO
        __init__(self, orig) -> IO
        """
        this = _Clustering.new_IO(*args)
        try: self.this.append(this)
        except: self.this = this
    def set_loglevel(*args):
        """set_loglevel(self, level)"""
        return _Clustering.IO_set_loglevel(*args)

    def get_loglevel(*args):
        """get_loglevel(self) -> EMessageType"""
        return _Clustering.IO_get_loglevel(*args)

    def get_show_progress(*args):
        """get_show_progress(self) -> bool"""
        return _Clustering.IO_get_show_progress(*args)

    def get_show_file_and_line(*args):
        """get_show_file_and_line(self) -> bool"""
        return _Clustering.IO_get_show_file_and_line(*args)

    def message(*args):
        """message(self, prio, file, line, fmt, ?)"""
        return _Clustering.IO_message(*args)

    def progress(*args):
        """
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1)
        progress(self, current_val, min_val=0.0, max_val=1.0)
        progress(self, current_val, min_val=0.0)
        progress(self, current_val)
        """
        return _Clustering.IO_progress(*args)

    def absolute_progress(*args):
        """
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1)
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0)
        absolute_progress(self, current_val, val, min_val=0.0)
        absolute_progress(self, current_val, val)
        """
        return _Clustering.IO_absolute_progress(*args)

    def done(*args):
        """done(self)"""
        return _Clustering.IO_done(*args)

    def not_implemented(*args):
        """not_implemented(self, file, line)"""
        return _Clustering.IO_not_implemented(*args)

    def deprecated(*args):
        """deprecated(self, file, line)"""
        return _Clustering.IO_deprecated(*args)

    def buffered_message(*args):
        """buffered_message(self, prio, fmt, ?)"""
        return _Clustering.IO_buffered_message(*args)

    def skip_spaces(*args):
        """skip_spaces(str) -> str"""
        return _Clustering.IO_skip_spaces(*args)

    if _newclass:skip_spaces = staticmethod(skip_spaces)
    __swig_getmethods__["skip_spaces"] = lambda x: skip_spaces
    def skip_blanks(*args):
        """skip_blanks(str) -> str"""
        return _Clustering.IO_skip_blanks(*args)

    if _newclass:skip_blanks = staticmethod(skip_blanks)
    __swig_getmethods__["skip_blanks"] = lambda x: skip_blanks
    def get_target(*args):
        """get_target(self) -> FILE"""
        return _Clustering.IO_get_target(*args)

    def set_target(*args):
        """set_target(self, target)"""
        return _Clustering.IO_set_target(*args)

    def set_target_to_stderr(*args):
        """set_target_to_stderr(self)"""
        return _Clustering.IO_set_target_to_stderr(*args)

    def set_target_to_stdout(*args):
        """set_target_to_stdout(self)"""
        return _Clustering.IO_set_target_to_stdout(*args)

    def enable_progress(*args):
        """enable_progress(self)"""
        return _Clustering.IO_enable_progress(*args)

    def disable_progress(*args):
        """disable_progress(self)"""
        return _Clustering.IO_disable_progress(*args)

    def enable_file_and_line(*args):
        """enable_file_and_line(self)"""
        return _Clustering.IO_enable_file_and_line(*args)

    def disable_file_and_line(*args):
        """disable_file_and_line(self)"""
        return _Clustering.IO_disable_file_and_line(*args)

    def set_dirname(*args):
        """set_dirname(dirname)"""
        return _Clustering.IO_set_dirname(*args)

    if _newclass:set_dirname = staticmethod(set_dirname)
    __swig_getmethods__["set_dirname"] = lambda x: set_dirname
    def concat_filename(*args):
        """concat_filename(filename) -> str"""
        return _Clustering.IO_concat_filename(*args)

    if _newclass:concat_filename = staticmethod(concat_filename)
    __swig_getmethods__["concat_filename"] = lambda x: concat_filename
    def filter(*args):
        """filter(d) -> int"""
        return _Clustering.IO_filter(*args)

    if _newclass:filter = staticmethod(filter)
    __swig_getmethods__["filter"] = lambda x: filter
    def ref(*args):
        """ref(self) ->  int"""
        return _Clustering.IO_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Clustering.IO_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Clustering.IO_unref(*args)

    def get_name(*args):
        """get_name(self) -> str"""
        return _Clustering.IO_get_name(*args)

    __swig_destroy__ = _Clustering.delete_IO
    __del__ = lambda self : None;
IO_swigregister = _Clustering.IO_swigregister
IO_swigregister(IO)
cvar = _Clustering.cvar

def IO_skip_spaces(*args):
  """IO_skip_spaces(str) -> str"""
  return _Clustering.IO_skip_spaces(*args)

def IO_skip_blanks(*args):
  """IO_skip_blanks(str) -> str"""
  return _Clustering.IO_skip_blanks(*args)

def IO_set_dirname(*args):
  """IO_set_dirname(dirname)"""
  return _Clustering.IO_set_dirname(*args)

def IO_concat_filename(*args):
  """IO_concat_filename(filename) -> str"""
  return _Clustering.IO_concat_filename(*args)

def IO_filter(*args):
  """IO_filter(d) -> int"""
  return _Clustering.IO_filter(*args)

class SGObject(_object):
    """Proxy of C++ SGObject class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SGObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SGObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Clustering.delete_SGObject
    __del__ = lambda self : None;
    def ref(*args):
        """ref(self) ->  int"""
        return _Clustering.SGObject_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Clustering.SGObject_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Clustering.SGObject_unref(*args)

    def get_name(*args):
        """get_name(self) -> str"""
        return _Clustering.SGObject_get_name(*args)

    __swig_setmethods__["io"] = _Clustering.SGObject_io_set
    __swig_getmethods__["io"] = _Clustering.SGObject_io_get
    if _newclass:io = _swig_property(_Clustering.SGObject_io_get, _Clustering.SGObject_io_set)
    __swig_setmethods__["parallel"] = _Clustering.SGObject_parallel_set
    __swig_getmethods__["parallel"] = _Clustering.SGObject_parallel_get
    if _newclass:parallel = _swig_property(_Clustering.SGObject_parallel_get, _Clustering.SGObject_parallel_set)
    __swig_setmethods__["version"] = _Clustering.SGObject_version_set
    __swig_getmethods__["version"] = _Clustering.SGObject_version_get
    if _newclass:version = _swig_property(_Clustering.SGObject_version_get, _Clustering.SGObject_version_set)
SGObject_swigregister = _Clustering.SGObject_swigregister
SGObject_swigregister(SGObject)

class Version(_object):
    """Proxy of C++ Version class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Version, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Version, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self) -> Version"""
        this = _Clustering.new_Version(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Clustering.delete_Version
    __del__ = lambda self : None;
    def print_version(*args):
        """print_version()"""
        return _Clustering.Version_print_version(*args)

    if _newclass:print_version = staticmethod(print_version)
    __swig_getmethods__["print_version"] = lambda x: print_version
    def get_version_extra(*args):
        """get_version_extra() -> str"""
        return _Clustering.Version_get_version_extra(*args)

    if _newclass:get_version_extra = staticmethod(get_version_extra)
    __swig_getmethods__["get_version_extra"] = lambda x: get_version_extra
    def get_version_release(*args):
        """get_version_release() -> str"""
        return _Clustering.Version_get_version_release(*args)

    if _newclass:get_version_release = staticmethod(get_version_release)
    __swig_getmethods__["get_version_release"] = lambda x: get_version_release
    def get_version_revision(*args):
        """get_version_revision() ->  int"""
        return _Clustering.Version_get_version_revision(*args)

    if _newclass:get_version_revision = staticmethod(get_version_revision)
    __swig_getmethods__["get_version_revision"] = lambda x: get_version_revision
    def get_version_year(*args):
        """get_version_year() ->  int"""
        return _Clustering.Version_get_version_year(*args)

    if _newclass:get_version_year = staticmethod(get_version_year)
    __swig_getmethods__["get_version_year"] = lambda x: get_version_year
    def get_version_month(*args):
        """get_version_month() ->  int"""
        return _Clustering.Version_get_version_month(*args)

    if _newclass:get_version_month = staticmethod(get_version_month)
    __swig_getmethods__["get_version_month"] = lambda x: get_version_month
    def get_version_day(*args):
        """get_version_day() ->  int"""
        return _Clustering.Version_get_version_day(*args)

    if _newclass:get_version_day = staticmethod(get_version_day)
    __swig_getmethods__["get_version_day"] = lambda x: get_version_day
    def get_version_hour(*args):
        """get_version_hour() ->  int"""
        return _Clustering.Version_get_version_hour(*args)

    if _newclass:get_version_hour = staticmethod(get_version_hour)
    __swig_getmethods__["get_version_hour"] = lambda x: get_version_hour
    def get_version_minute(*args):
        """get_version_minute() ->  int"""
        return _Clustering.Version_get_version_minute(*args)

    if _newclass:get_version_minute = staticmethod(get_version_minute)
    __swig_getmethods__["get_version_minute"] = lambda x: get_version_minute
    def get_version_in_minutes(*args):
        """get_version_in_minutes() -> int"""
        return _Clustering.Version_get_version_in_minutes(*args)

    if _newclass:get_version_in_minutes = staticmethod(get_version_in_minutes)
    __swig_getmethods__["get_version_in_minutes"] = lambda x: get_version_in_minutes
    def ref(*args):
        """ref(self) ->  int"""
        return _Clustering.Version_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Clustering.Version_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Clustering.Version_unref(*args)

Version_swigregister = _Clustering.Version_swigregister
Version_swigregister(Version)

def Version_print_version(*args):
  """Version_print_version()"""
  return _Clustering.Version_print_version(*args)

def Version_get_version_extra(*args):
  """Version_get_version_extra() -> str"""
  return _Clustering.Version_get_version_extra(*args)

def Version_get_version_release(*args):
  """Version_get_version_release() -> str"""
  return _Clustering.Version_get_version_release(*args)

def Version_get_version_revision(*args):
  """Version_get_version_revision() ->  int"""
  return _Clustering.Version_get_version_revision(*args)

def Version_get_version_year(*args):
  """Version_get_version_year() ->  int"""
  return _Clustering.Version_get_version_year(*args)

def Version_get_version_month(*args):
  """Version_get_version_month() ->  int"""
  return _Clustering.Version_get_version_month(*args)

def Version_get_version_day(*args):
  """Version_get_version_day() ->  int"""
  return _Clustering.Version_get_version_day(*args)

def Version_get_version_hour(*args):
  """Version_get_version_hour() ->  int"""
  return _Clustering.Version_get_version_hour(*args)

def Version_get_version_minute(*args):
  """Version_get_version_minute() ->  int"""
  return _Clustering.Version_get_version_minute(*args)

def Version_get_version_in_minutes(*args):
  """Version_get_version_in_minutes() -> int"""
  return _Clustering.Version_get_version_in_minutes(*args)

class Parallel(_object):
    """Proxy of C++ Parallel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parallel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Parallel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Parallel
        __init__(self, orig) -> Parallel
        """
        this = _Clustering.new_Parallel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Clustering.delete_Parallel
    __del__ = lambda self : None;
    def get_num_cpus(*args):
        """get_num_cpus(self) ->  int"""
        return _Clustering.Parallel_get_num_cpus(*args)

    def set_num_threads(*args):
        """set_num_threads(self, n)"""
        return _Clustering.Parallel_set_num_threads(*args)

    def get_num_threads(*args):
        """get_num_threads(self) ->  int"""
        return _Clustering.Parallel_get_num_threads(*args)

    def ref(*args):
        """ref(self) ->  int"""
        return _Clustering.Parallel_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Clustering.Parallel_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Clustering.Parallel_unref(*args)

Parallel_swigregister = _Clustering.Parallel_swigregister
Parallel_swigregister(Parallel)

class PySwigIterator(_object):
    """Proxy of C++ PySwigIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Clustering.delete_PySwigIterator
    __del__ = lambda self : None;
    def value(*args):
        """value(self) -> PyObject"""
        return _Clustering.PySwigIterator_value(*args)

    def incr(*args):
        """
        incr(self, n=1) -> PySwigIterator
        incr(self) -> PySwigIterator
        """
        return _Clustering.PySwigIterator_incr(*args)

    def decr(*args):
        """
        decr(self, n=1) -> PySwigIterator
        decr(self) -> PySwigIterator
        """
        return _Clustering.PySwigIterator_decr(*args)

    def distance(*args):
        """distance(self, x) -> ptrdiff_t"""
        return _Clustering.PySwigIterator_distance(*args)

    def equal(*args):
        """equal(self, x) -> bool"""
        return _Clustering.PySwigIterator_equal(*args)

    def copy(*args):
        """copy(self) -> PySwigIterator"""
        return _Clustering.PySwigIterator_copy(*args)

    def next(*args):
        """next(self) -> PyObject"""
        return _Clustering.PySwigIterator_next(*args)

    def previous(*args):
        """previous(self) -> PyObject"""
        return _Clustering.PySwigIterator_previous(*args)

    def advance(*args):
        """advance(self, n) -> PySwigIterator"""
        return _Clustering.PySwigIterator_advance(*args)

    def __eq__(*args):
        """__eq__(self, x) -> bool"""
        return _Clustering.PySwigIterator___eq__(*args)

    def __ne__(*args):
        """__ne__(self, x) -> bool"""
        return _Clustering.PySwigIterator___ne__(*args)

    def __iadd__(*args):
        """__iadd__(self, n) -> PySwigIterator"""
        return _Clustering.PySwigIterator___iadd__(*args)

    def __isub__(*args):
        """__isub__(self, n) -> PySwigIterator"""
        return _Clustering.PySwigIterator___isub__(*args)

    def __add__(*args):
        """__add__(self, n) -> PySwigIterator"""
        return _Clustering.PySwigIterator___add__(*args)

    def __sub__(*args):
        """
        __sub__(self, n) -> PySwigIterator
        __sub__(self, x) -> ptrdiff_t
        """
        return _Clustering.PySwigIterator___sub__(*args)

    def __iter__(self): return self
PySwigIterator_swigregister = _Clustering.PySwigIterator_swigregister
PySwigIterator_swigregister(PySwigIterator)

class IntVector(_object):
    """Proxy of C++ IntVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _Clustering.IntVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _Clustering.IntVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(int)>::size_type"""
        return _Clustering.IntVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(int)>::value_type"""
        return _Clustering.IntVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> IntVector"""
        return _Clustering.IntVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _Clustering.IntVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _Clustering.IntVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _Clustering.IntVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(int)>::value_type"""
        return _Clustering.IntVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _Clustering.IntVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _Clustering.IntVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _Clustering.IntVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(int)>::size_type"""
        return _Clustering.IntVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _Clustering.IntVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _Clustering.IntVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(int)>::allocator_type"""
        return _Clustering.IntVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(int)>::const_iterator"""
        return _Clustering.IntVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(int)>::const_iterator"""
        return _Clustering.IntVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _Clustering.IntVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _Clustering.IntVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _Clustering.IntVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(int)>::iterator
        erase(self, first, last) -> std::vector<(int)>::iterator
        """
        return _Clustering.IntVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> IntVector
        __init__(self, ?) -> IntVector
        __init__(self, size) -> IntVector
        __init__(self, size, value) -> IntVector
        """
        this = _Clustering.new_IntVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _Clustering.IntVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(int)>::value_type"""
        return _Clustering.IntVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(int)>::value_type"""
        return _Clustering.IntVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _Clustering.IntVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _Clustering.IntVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(int)>::iterator
        insert(self, pos, n, x)
        """
        return _Clustering.IntVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _Clustering.IntVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(int)>::size_type"""
        return _Clustering.IntVector_capacity(*args)

    __swig_destroy__ = _Clustering.delete_IntVector
    __del__ = lambda self : None;
IntVector_swigregister = _Clustering.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(_object):
    """Proxy of C++ DoubleVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _Clustering.DoubleVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _Clustering.DoubleVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(double)>::size_type"""
        return _Clustering.DoubleVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(double)>::value_type"""
        return _Clustering.DoubleVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> DoubleVector"""
        return _Clustering.DoubleVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _Clustering.DoubleVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _Clustering.DoubleVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _Clustering.DoubleVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(double)>::value_type"""
        return _Clustering.DoubleVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _Clustering.DoubleVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _Clustering.DoubleVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _Clustering.DoubleVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(double)>::size_type"""
        return _Clustering.DoubleVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _Clustering.DoubleVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _Clustering.DoubleVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(double)>::allocator_type"""
        return _Clustering.DoubleVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(double)>::const_iterator"""
        return _Clustering.DoubleVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(double)>::const_iterator"""
        return _Clustering.DoubleVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _Clustering.DoubleVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _Clustering.DoubleVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _Clustering.DoubleVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(double)>::iterator
        erase(self, first, last) -> std::vector<(double)>::iterator
        """
        return _Clustering.DoubleVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> DoubleVector
        __init__(self, ?) -> DoubleVector
        __init__(self, size) -> DoubleVector
        __init__(self, size, value) -> DoubleVector
        """
        this = _Clustering.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _Clustering.DoubleVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(double)>::value_type"""
        return _Clustering.DoubleVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(double)>::value_type"""
        return _Clustering.DoubleVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _Clustering.DoubleVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _Clustering.DoubleVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(double)>::iterator
        insert(self, pos, n, x)
        """
        return _Clustering.DoubleVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _Clustering.DoubleVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(double)>::size_type"""
        return _Clustering.DoubleVector_capacity(*args)

    __swig_destroy__ = _Clustering.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _Clustering.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

CT_NONE = _Clustering.CT_NONE
CT_LIGHT = _Clustering.CT_LIGHT
CT_LIBSVM = _Clustering.CT_LIBSVM
CT_LIBSVMONECLASS = _Clustering.CT_LIBSVMONECLASS
CT_LIBSVMMULTICLASS = _Clustering.CT_LIBSVMMULTICLASS
CT_MPD = _Clustering.CT_MPD
CT_GPBT = _Clustering.CT_GPBT
CT_CPLEXSVM = _Clustering.CT_CPLEXSVM
CT_PERCEPTRON = _Clustering.CT_PERCEPTRON
CT_KERNELPERCEPTRON = _Clustering.CT_KERNELPERCEPTRON
CT_LDA = _Clustering.CT_LDA
CT_LPM = _Clustering.CT_LPM
CT_LPBOOST = _Clustering.CT_LPBOOST
CT_KNN = _Clustering.CT_KNN
CT_SVMLIN = _Clustering.CT_SVMLIN
CT_KRR = _Clustering.CT_KRR
CT_GNPPSVM = _Clustering.CT_GNPPSVM
CT_GMNPSVM = _Clustering.CT_GMNPSVM
CT_SUBGRADIENTSVM = _Clustering.CT_SUBGRADIENTSVM
CT_SUBGRADIENTLPM = _Clustering.CT_SUBGRADIENTLPM
CT_SVMPERF = _Clustering.CT_SVMPERF
CT_LIBSVR = _Clustering.CT_LIBSVR
CT_SVRLIGHT = _Clustering.CT_SVRLIGHT
CT_LIBLINEAR = _Clustering.CT_LIBLINEAR
CT_KMEANS = _Clustering.CT_KMEANS
CT_HIERARCHICAL = _Clustering.CT_HIERARCHICAL
CT_SVMOCAS = _Clustering.CT_SVMOCAS
CT_WDSVMOCAS = _Clustering.CT_WDSVMOCAS
CT_SVMSGD = _Clustering.CT_SVMSGD
CT_MKLMULTICLASS = _Clustering.CT_MKLMULTICLASS
CT_MKLCLASSIFICATION = _Clustering.CT_MKLCLASSIFICATION
CT_MKLONECLASS = _Clustering.CT_MKLONECLASS
CT_MKLREGRESSION = _Clustering.CT_MKLREGRESSION
CT_SCATTERSVM = _Clustering.CT_SCATTERSVM
CT_DASVM = _Clustering.CT_DASVM
CT_LARANK = _Clustering.CT_LARANK
ST_AUTO = _Clustering.ST_AUTO
ST_CPLEX = _Clustering.ST_CPLEX
ST_GLPK = _Clustering.ST_GLPK
ST_NEWTON = _Clustering.ST_NEWTON
ST_DIRECT = _Clustering.ST_DIRECT
class CClassifier(SGObject):
    """Proxy of C++ CClassifier class"""
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CClassifier, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CClassifier, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Clustering.delete_CClassifier
    __del__ = lambda self : None;
    def train(*args):
        """
        train(self, data=None) -> bool
        train(self) -> bool
        """
        return _Clustering.CClassifier_train(*args)

    def classify(*args):
        """
        classify(self) -> CLabels
        classify(self, data) -> CLabels
        """
        return _Clustering.CClassifier_classify(*args)

    def classify_example(*args):
        """classify_example(self, num) -> float"""
        return _Clustering.CClassifier_classify_example(*args)

    def load(*args):
        """load(self, srcfile) -> bool"""
        return _Clustering.CClassifier_load(*args)

    def save(*args):
        """save(self, dstfile) -> bool"""
        return _Clustering.CClassifier_save(*args)

    def set_labels(*args):
        """set_labels(self, lab)"""
        return _Clustering.CClassifier_set_labels(*args)

    def get_labels(*args):
        """get_labels(self) -> CLabels"""
        return _Clustering.CClassifier_get_labels(*args)

    def get_label(*args):
        """get_label(self, i) -> float"""
        return _Clustering.CClassifier_get_label(*args)

    def set_max_train_time(*args):
        """set_max_train_time(self, t)"""
        return _Clustering.CClassifier_set_max_train_time(*args)

    def get_max_train_time(*args):
        """get_max_train_time(self) -> float"""
        return _Clustering.CClassifier_get_max_train_time(*args)

    def get_classifier_type(*args):
        """get_classifier_type(self) -> EClassifierType"""
        return _Clustering.CClassifier_get_classifier_type(*args)

    def set_solver_type(*args):
        """set_solver_type(self, st)"""
        return _Clustering.CClassifier_set_solver_type(*args)

    def get_solver_type(*args):
        """get_solver_type(self) -> ESolverType"""
        return _Clustering.CClassifier_get_solver_type(*args)

CClassifier_swigregister = _Clustering.CClassifier_swigregister
CClassifier_swigregister(CClassifier)

class DistanceMachine(CClassifier):
    """Proxy of C++ DistanceMachine class"""
    __swig_setmethods__ = {}
    for _s in [CClassifier]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistanceMachine, name, value)
    __swig_getmethods__ = {}
    for _s in [CClassifier]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DistanceMachine, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Clustering.delete_DistanceMachine
    __del__ = lambda self : None;
    def set_distance(*args):
        """set_distance(self, d)"""
        return _Clustering.DistanceMachine_set_distance(*args)

    def get_distance(*args):
        """get_distance(self) -> CDistance"""
        return _Clustering.DistanceMachine_get_distance(*args)

    def distances_lhs(*args):
        """distances_lhs(self, result, idx_a1, idx_a2, idx_b)"""
        return _Clustering.DistanceMachine_distances_lhs(*args)

    def distances_rhs(*args):
        """distances_rhs(self, result, idx_b1, idx_b2, idx_a)"""
        return _Clustering.DistanceMachine_distances_rhs(*args)

DistanceMachine_swigregister = _Clustering.DistanceMachine_swigregister
DistanceMachine_swigregister(DistanceMachine)

class KMeans(DistanceMachine):
    """
    KMeans clustering, partitions the data into k (a-priori specified)
    clusters.

    It minimizes \\[ \\sum_{i=1}^k\\sum_{x_j\\in S_i}
    (x_j-\\mu_i)^2 \\]

    where $\\mu_i$ are the cluster centers and $S_i,\\;i=1,\\dots,k$
    are the index sets of the clusters.

    Beware that this algorithm obtains only a local optimum.

    cf.http://en.wikipedia.org/wiki/K-means_algorithm

    C++ includes: KMeans.h 
    """
    __swig_setmethods__ = {}
    for _s in [DistanceMachine]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KMeans, name, value)
    __swig_getmethods__ = {}
    for _s in [DistanceMachine]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, KMeans, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> KMeans
        __init__(self, k, d) -> KMeans

        constructor

        Parameters:
        -----------

        k:  parameter k

        d:  distance 
        """
        this = _Clustering.new_KMeans(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Clustering.delete_KMeans
    __del__ = lambda self : None;
    def train(*args):
        """
        train(self, data=None) -> bool
        train(self) -> bool

        train k-means

        Parameters:
        -----------

        data:  training data (parameter can be avoided if distance or kernel-
        based classifiers are used and distance/kernels are initialized with
        train data)

        whether training was successful 
        """
        return _Clustering.KMeans_train(*args)

    def set_k(*args):
        """
        set_k(self, p_k)

        set k

        Parameters:
        -----------

        p_k:  new k 
        """
        return _Clustering.KMeans_set_k(*args)

    def get_k(*args):
        """
        get_k(self) ->  int

        get k

        the parameter k 
        """
        return _Clustering.KMeans_get_k(*args)

    def set_max_iter(*args):
        """
        set_max_iter(self, iter)

        set maximum number of iterations

        Parameters:
        -----------

        iter:  the new maximum 
        """
        return _Clustering.KMeans_set_max_iter(*args)

    def get_max_iter(*args):
        """
        get_max_iter(self) -> float

        get maximum number of iterations

        maximum number of iterations 
        """
        return _Clustering.KMeans_get_max_iter(*args)

    def get_radi(*args):
        """
        get_radi(self) -> numpy 1dim array of float

        get radi

        Parameters:
        -----------

        radi:  current radi are stored in here

        num:  number of radi is stored in here 
        """
        return _Clustering.KMeans_get_radi(*args)

    def get_centers(*args):
        """
        get_centers(self) -> numpy 2dim array of float

        get centers

        Parameters:
        -----------

        centers:  current centers are stored in here

        dim:  dimensions are stored in here

        num:  number of centers is stored in here 
        """
        return _Clustering.KMeans_get_centers(*args)

    def get_radiuses(*args):
        """
        get_radiuses(self, radii)

        get radiuses (swig compatible)

        Parameters:
        -----------

        radii:  current radiuses are stored in here

        num:  number of radiuses is stored in here 
        """
        return _Clustering.KMeans_get_radiuses(*args)

    def get_cluster_centers(*args):
        """
        get_cluster_centers(self, centers)

        get cluster centers (swig compatible)

        Parameters:
        -----------

        centers:  current cluster centers are stored in here

        dim:  dimensions are stored in here

        num:  number of centers is stored in here 
        """
        return _Clustering.KMeans_get_cluster_centers(*args)

    def get_dimensions(*args):
        """
        get_dimensions(self) ->  int

        get dimensions

        number of dimensions 
        """
        return _Clustering.KMeans_get_dimensions(*args)

KMeans_swigregister = _Clustering.KMeans_swigregister
KMeans_swigregister(KMeans)

class Hierarchical(DistanceMachine):
    """
    Agglomerative hierarchical single linkage clustering.

    Starting with each object being assigned to its own cluster clusters
    are iteratively merged. Here the clusters are merged whose elements
    have minimum distance, i.e. the clusters A and B that obtain

    \\[ \\min\\{d({\\bf x},{\\bf x'}): {\\bf x}\\in {\\cal
    A},{\\bf x'}\\in {\\cal B}\\} \\]

    are merged.

    cf e.g.http://en.wikipedia.org/wiki/Data_clustering

    C++ includes: Hierarchical.h 
    """
    __swig_setmethods__ = {}
    for _s in [DistanceMachine]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Hierarchical, name, value)
    __swig_getmethods__ = {}
    for _s in [DistanceMachine]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Hierarchical, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Hierarchical
        __init__(self, merges, d) -> Hierarchical

        constructor

        Parameters:
        -----------

        merges:  the merges

        d:  distance 
        """
        this = _Clustering.new_Hierarchical(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Clustering.delete_Hierarchical
    __del__ = lambda self : None;
    def train(*args):
        """
        train(self, data=None) -> bool
        train(self) -> bool

        estimate hierarchical clustering

        Parameters:
        -----------

        data:  training data (parameter can be avoided if distance or kernel-
        based classifiers are used and distance/kernels are initialized with
        train data)

        whether training was successful 
        """
        return _Clustering.Hierarchical_train(*args)

    def set_merges(*args):
        """
        set_merges(self, m)

        set merges

        Parameters:
        -----------

        m:  new merges 
        """
        return _Clustering.Hierarchical_set_merges(*args)

    def get_merges(*args):
        """
        get_merges(self) ->  int

        get merges

        merges 
        """
        return _Clustering.Hierarchical_get_merges(*args)

    def get_assignment(*args):
        """
        get_assignment(self, assign, num)

        get assignment

        Parameters:
        -----------

        assign:  current assignment is stored in here

        num:  number of assignments is stored in here 
        """
        return _Clustering.Hierarchical_get_assignment(*args)

    def get_merge_distance(*args):
        """
        get_merge_distance(self) -> [] of float

        get merge distance

        Parameters:
        -----------

        dist:  current merge distance is stored in here

        num:  number of merge distances is stored in here 
        """
        return _Clustering.Hierarchical_get_merge_distance(*args)

    def get_merge_distances(*args):
        """
        get_merge_distances(self, dist)

        get merge distances (swig compatible)

        Parameters:
        -----------

        dist:  current merge distances are stored in here

        num:  number of merge distances are stored in here 
        """
        return _Clustering.Hierarchical_get_merge_distances(*args)

    def get_pairs(*args):
        """
        get_pairs(self) -> [] of float

        get pairs

        Parameters:
        -----------

        tuples:  current pairs are stored in here

        rows:  number of rows is stored in here

        num:  number of pairs is stored in here 
        """
        return _Clustering.Hierarchical_get_pairs(*args)

    def get_cluster_pairs(*args):
        """
        get_cluster_pairs(self, tuples)

        get cluster pairs (swig compatible)

        Parameters:
        -----------

        tuples:  current pairs are stored in here

        rows:  number of rows is stored in here

        num:  number of pairs is stored in here 
        """
        return _Clustering.Hierarchical_get_cluster_pairs(*args)

    def classify(*args):
        """
        classify(self) -> CLabels
        classify(self, data) -> CLabels

        classify objects

        Parameters:
        -----------

        data:  (test)data to be classified

        classified labels 
        """
        return _Clustering.Hierarchical_classify(*args)

Hierarchical_swigregister = _Clustering.Hierarchical_swigregister
Hierarchical_swigregister(Hierarchical)



