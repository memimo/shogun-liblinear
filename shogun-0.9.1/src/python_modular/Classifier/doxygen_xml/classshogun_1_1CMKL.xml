<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.6.1">
  <compounddef id="classshogun_1_1CMKL" kind="class" prot="public">
    <compoundname>shogun::CMKL</compoundname>
    <basecompoundref refid="classshogun_1_1CSVM" prot="public" virt="non-virtual">shogun::CSVM</basecompoundref>
    <derivedcompoundref refid="classshogun_1_1CMKLClassification" prot="public" virt="non-virtual">shogun::CMKLClassification</derivedcompoundref>
    <derivedcompoundref refid="classshogun_1_1CMKLOneClass" prot="public" virt="non-virtual">shogun::CMKLOneClass</derivedcompoundref>
    <includes local="no">MKL.h</includes>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classshogun_1_1CMKL_1a01c377423a211060040afabc91a1789b" prot="protected" static="no" mutable="no">
        <type><ref refid="classshogun_1_1CSVM" kindref="compound">CSVM</ref> *</type>
        <definition>CSVM* shogun::CMKL::svm</definition>
        <argsstring></argsstring>
        <name>svm</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>wrapper SVM </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="382" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="382" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classshogun_1_1CMKL_1a53f653a3c9f87453c2500cc80f38df21" prot="protected" static="no" mutable="no">
        <type>float64_t</type>
        <definition>float64_t shogun::CMKL::C_mkl</definition>
        <argsstring></argsstring>
        <name>C_mkl</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>C_mkl </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="384" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="384" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classshogun_1_1CMKL_1a90dce2495aa6de1456bf0d13d9c617c6" prot="protected" static="no" mutable="no">
        <type>float64_t</type>
        <definition>float64_t shogun::CMKL::mkl_norm</definition>
        <argsstring></argsstring>
        <name>mkl_norm</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>norm used in mkl must be &gt; 0 </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="386" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="386" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classshogun_1_1CMKL_1af18297125c8800179bc8c8b29be65175" prot="protected" static="no" mutable="no">
        <type>int32_t</type>
        <definition>int32_t shogun::CMKL::mkl_iterations</definition>
        <argsstring></argsstring>
        <name>mkl_iterations</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>number of mkl steps </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="388" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="388" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classshogun_1_1CMKL_1aeab6ca49ab478af35bf267a038b8f43f" prot="protected" static="no" mutable="no">
        <type>float64_t</type>
        <definition>float64_t shogun::CMKL::mkl_epsilon</definition>
        <argsstring></argsstring>
        <name>mkl_epsilon</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>mkl_epsilon for multiple kernel learning </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="390" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="390" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classshogun_1_1CMKL_1a82eb45ca35ab6d9db34356732cee0208" prot="protected" static="no" mutable="no">
        <type>bool</type>
        <definition>bool shogun::CMKL::interleaved_optimization</definition>
        <argsstring></argsstring>
        <name>interleaved_optimization</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>whether to use mkl wrapper or interleaved opt. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="392" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="392" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classshogun_1_1CMKL_1ac6746bda1ee0bf765fd3217546f6391d" prot="protected" static="no" mutable="no">
        <type>float64_t *</type>
        <definition>float64_t* shogun::CMKL::W</definition>
        <argsstring></argsstring>
        <name>W</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>partial objectives (one per kernel) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="395" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="395" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classshogun_1_1CMKL_1aa1e0044b4b9145a33f786d5cc37abaef" prot="protected" static="no" mutable="no">
        <type>float64_t</type>
        <definition>float64_t shogun::CMKL::w_gap</definition>
        <argsstring></argsstring>
        <name>w_gap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>gap between iterations </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="398" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="398" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classshogun_1_1CMKL_1a8c0914c4ab24878458682bea1de00a5c" prot="protected" static="no" mutable="no">
        <type>float64_t</type>
        <definition>float64_t shogun::CMKL::rho</definition>
        <argsstring></argsstring>
        <name>rho</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>objective after mkl iterations </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="400" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="400" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classshogun_1_1CMKL_1a96257f68ec9ec1d6e95cd275e95d19ae" prot="protected" static="no" mutable="no">
        <type>bool</type>
        <definition>bool shogun::CMKL::lp_initialized</definition>
        <argsstring></argsstring>
        <name>lp_initialized</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>if lp is initialized </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="414" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="414" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classshogun_1_1CMKL_1a76215d7dd0175846cee5bc9f774d9dee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>shogun::CMKL::CMKL</definition>
        <argsstring>(CSVM *s=NULL)</argsstring>
        <name>CMKL</name>
        <param>
          <type><ref refid="classshogun_1_1CSVM" kindref="compound">CSVM</ref> *</type>
          <declname>s</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Constructor</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>SVM to use as constraint generator in MKL SIP </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="90"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1a4cf1e4d5cd34bcbf5672ddedbb7a77c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type></type>
        <definition>virtual shogun::CMKL::~CMKL</definition>
        <argsstring>()</argsstring>
        <name>~CMKL</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Destructor </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="94"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1a7f00ad77a34c500edc2e379618a3af6c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void shogun::CMKL::set_constraint_generator</definition>
        <argsstring>(CSVM *s)</argsstring>
        <name>set_constraint_generator</name>
        <param>
          <type><ref refid="classshogun_1_1CSVM" kindref="compound">CSVM</ref> *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>SVM to use as constraint generator in MKL SIP</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>svm </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="101" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="100" bodyend="103"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1a43c2a403cf426ca47ddf1836c086f259" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void shogun::CMKL::set_svm</definition>
        <argsstring>(CSVM *s)</argsstring>
        <name>set_svm</name>
        <param>
          <type><ref refid="classshogun_1_1CSVM" kindref="compound">CSVM</ref> *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>SVM to use as constraint generator in MKL SIP</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>svm </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="110" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="109" bodyend="114"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1a5e1128495509231d0d44c1119b52af6e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classshogun_1_1CSVM" kindref="compound">CSVM</ref> *</type>
        <definition>CSVM* shogun::CMKL::get_svm</definition>
        <argsstring>()</argsstring>
        <name>get_svm</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>get SVM that is used as constraint generator in MKL SIP</para><para><simplesect kind="return"><para>svm </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="121" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="120" bodyend="124"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1a81e15c891b0ca00c378cd6dfe5b8b7f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>virtual bool shogun::CMKL::train</definition>
        <argsstring>(CFeatures *data=NULL)</argsstring>
        <name>train</name>
        <reimplements refid="classshogun_1_1CClassifier_1a9904cc0a8d7ec077cc1fede8d64ebb22">train</reimplements>
        <param>
          <type>CFeatures *</type>
          <declname>data</declname>
          <defval>NULL</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>train MKL classifier</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername><ref refid="structshogun_1_1data" kindref="compound">data</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>training <ref refid="structshogun_1_1data" kindref="compound">data</ref> (parameter can be avoided if distance or kernel-based classifiers are used and distance/kernels are initialized with train <ref refid="structshogun_1_1data" kindref="compound">data</ref>)</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>whether training was successful </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="135"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1accf64f1c3983a54882782852f5a6875d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void shogun::CMKL::set_C_mkl</definition>
        <argsstring>(float64_t C)</argsstring>
        <name>set_C_mkl</name>
        <param>
          <type>float64_t</type>
          <declname>C</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>set C mkl</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>new C_mkl </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="141" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="141" bodyend="141"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1aae9cf6c48e13ead57da32f42fc12d844" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void shogun::CMKL::set_mkl_norm</definition>
        <argsstring>(float64_t norm)</argsstring>
        <name>set_mkl_norm</name>
        <param>
          <type>float64_t</type>
          <declname>norm</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>set mkl norm</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>norm</parametername>
</parameternamelist>
<parameterdescription>
<para>new mkl norm (must be greater equal 1) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="148" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="147" bodyend="152"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1aa761562aa28d4801f271fd5a264d6599" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void shogun::CMKL::set_interleaved_optimization_enabled</definition>
        <argsstring>(bool enable)</argsstring>
        <name>set_interleaved_optimization_enabled</name>
        <param>
          <type>bool</type>
          <declname>enable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>set state of optimization (interleaved or wrapper)</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>enable</parametername>
</parameternamelist>
<parameterdescription>
<para>if true interleaved optimization is used; wrapper otherwise </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="160" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="159" bodyend="162"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1ae2e8bb59252ff789312b10d46c8dc387" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool shogun::CMKL::get_interleaved_optimization_enabled</definition>
        <argsstring>()</argsstring>
        <name>get_interleaved_optimization_enabled</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>get state of optimization (interleaved or wrapper)</para><para><simplesect kind="return"><para>true if interleaved optimization is used; wrapper otherwise </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="169" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="168" bodyend="171"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1a64db92316ae517cbaf88293ef06df475" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float64_t</type>
        <definition>float64_t shogun::CMKL::compute_mkl_primal_objective</definition>
        <argsstring>()</argsstring>
        <name>compute_mkl_primal_objective</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>compute mkl primal objective</para><para><simplesect kind="return"><para>computed mkl primal objective </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="178" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="177" bodyend="180"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1a73d4af07d5878e700cd08ff659e928b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>float64_t</type>
        <definition>virtual float64_t shogun::CMKL::compute_mkl_dual_objective</definition>
        <argsstring>()</argsstring>
        <name>compute_mkl_dual_objective</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>compute mkl dual objective</para><para><simplesect kind="return"><para>computed dual objective </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="186"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1add6fc2f09354065ebb0ae46d58c4ae9b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void shogun::CMKL::set_mkl_epsilon</definition>
        <argsstring>(float64_t eps)</argsstring>
        <name>set_mkl_epsilon</name>
        <param>
          <type>float64_t</type>
          <declname>eps</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>set mkl epsilon (optimization accuracy for kernel weights)</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>eps</parametername>
</parameternamelist>
<parameterdescription>
<para>new weight_epsilon </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="192" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="192" bodyend="192"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1a5c6545a86351390d3ff09518c3b86acc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float64_t</type>
        <definition>float64_t shogun::CMKL::get_mkl_epsilon</definition>
        <argsstring>()</argsstring>
        <name>get_mkl_epsilon</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>get mkl epsilon for weights (optimization accuracy for kernel weights)</para><para><simplesect kind="return"><para>epsilon for weights </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="198" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="198" bodyend="198"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1a0a892fc3ea060af8c0e3119ecab0ae5f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int32_t</type>
        <definition>int32_t shogun::CMKL::get_mkl_iterations</definition>
        <argsstring>()</argsstring>
        <name>get_mkl_iterations</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>get number of MKL iterations</para><para><simplesect kind="return"><para>mkl_iterations </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="204" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="204" bodyend="204"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1abb840747ae20fbeb88093a6d61e0d2c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>virtual bool shogun::CMKL::perform_mkl_step</definition>
        <argsstring>(const float64_t *sumw, float64_t suma)</argsstring>
        <name>perform_mkl_step</name>
        <param>
          <type>const float64_t *</type>
          <declname>sumw</declname>
        </param>
        <param>
          <type>float64_t</type>
          <declname>suma</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>perform single mkl iteration</para><para>given sum of alphas, objectives for current alphas for each kernel and current kernel weighting compute the corresponding optimal kernel weighting (all via get/set_subkernel_weights in CCombinedKernel)</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sumw</parametername>
</parameternamelist>
<parameterdescription>
<para>vector of 1/2*alpha&apos;*K_j*alpha for each kernel j </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>suma</parametername>
</parameternamelist>
<parameterdescription>
<para>scalar sum_i alpha_i etc. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="216"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1afc6ed67c16a32315c56965e1ed8dfbe2" prot="public" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>float64_t</type>
        <definition>virtual float64_t shogun::CMKL::compute_sum_alpha</definition>
        <argsstring>()=0</argsstring>
        <name>compute_sum_alpha</name>
        <reimplementedby refid="classshogun_1_1CMKLOneClass_1ad5dd436e425e412dcf47ec7c67e44fe2">compute_sum_alpha</reimplementedby>
        <reimplementedby refid="classshogun_1_1CMKLClassification_1af55f61450855bd4e40f95ec0e649f686">compute_sum_alpha</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>compute beta independent term from objective, e.g., in 2-class MKL sum_i alpha_i etc </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="234"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1a6140a61fe8ebc149c9b1143cc950b2a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>void</type>
        <definition>virtual void shogun::CMKL::compute_sum_beta</definition>
        <argsstring>(float64_t *sumw)</argsstring>
        <name>compute_sum_beta</name>
        <param>
          <type>float64_t *</type>
          <declname>sumw</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>compute 1/2*alpha&apos;*K_j*alpha for each kernel j (beta dependent term from objective)</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sumw</parametername>
</parameternamelist>
<parameterdescription>
<para>vector of size num_kernels to hold the result </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="240"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classshogun_1_1CMKL_1af7ee654de550c6d682dc78c37f84278c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>static bool shogun::CMKL::perform_mkl_step_helper</definition>
        <argsstring>(CMKL *mkl, const float64_t *sumw, const float64_t suma)</argsstring>
        <name>perform_mkl_step_helper</name>
        <param>
          <type><ref refid="classshogun_1_1CMKL" kindref="compound">CMKL</ref> *</type>
          <declname>mkl</declname>
        </param>
        <param>
          <type>const float64_t *</type>
          <declname>sumw</declname>
        </param>
        <param>
          <type>const float64_t</type>
          <declname>suma</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>callback helper function calling perform_mkl_step</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mkl</parametername>
</parameternamelist>
<parameterdescription>
<para>MKL object </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sumw</parametername>
</parameternamelist>
<parameterdescription>
<para>vector of 1/2*alpha&apos;*K_j*alpha for each kernel j </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>suma</parametername>
</parameternamelist>
<parameterdescription>
<para>scalar sum_i alpha_i etc. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="226" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="224" bodyend="228"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-func">
      <memberdef kind="function" id="classshogun_1_1CMKL_1a3d50bcedd22efd0c162831c336b23558" prot="protected" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>void</type>
        <definition>virtual void shogun::CMKL::init_training</definition>
        <argsstring>()=0</argsstring>
        <name>init_training</name>
        <reimplementedby refid="classshogun_1_1CMKLOneClass_1ad36098066cc5144f16dd93312e3a4c86">init_training</reimplementedby>
        <reimplementedby refid="classshogun_1_1CMKLClassification_1ad0eaa160b3e772ec7928e5cedf72c4fd">init_training</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>check run before starting training (to e.g. check if labeling is two-class labeling in classification case </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="246"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1a5d960353089b92ff019afc32224a7083" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void shogun::CMKL::perform_mkl_step</definition>
        <argsstring>(float64_t *beta, float64_t *old_beta, int num_kernels, int32_t *label, int32_t *active2dnum, float64_t *a, float64_t *lin, float64_t *sumw, int32_t &amp;inner_iters)</argsstring>
        <name>perform_mkl_step</name>
        <param>
          <type>float64_t *</type>
          <declname>beta</declname>
        </param>
        <param>
          <type>float64_t *</type>
          <declname>old_beta</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_kernels</declname>
        </param>
        <param>
          <type>int32_t *</type>
          <declname>label</declname>
        </param>
        <param>
          <type>int32_t *</type>
          <declname>active2dnum</declname>
        </param>
        <param>
          <type>float64_t *</type>
          <declname>a</declname>
        </param>
        <param>
          <type>float64_t *</type>
          <declname>lin</declname>
        </param>
        <param>
          <type>float64_t *</type>
          <declname>sumw</declname>
        </param>
        <param>
          <type>int32_t &amp;</type>
          <declname>inner_iters</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>perform single mkl iteration</para><para>given the alphas, compute the corresponding optimal betas</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beta</parametername>
</parameternamelist>
<parameterdescription>
<para>new betas (kernel weights) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>old_beta</parametername>
</parameternamelist>
<parameterdescription>
<para>old betas (previous kernel weights) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_kernels</parametername>
</parameternamelist>
<parameterdescription>
<para>number of kernels </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>label</parametername>
</parameternamelist>
<parameterdescription>
<para>(from svmlight label) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>active2dnum</parametername>
</parameternamelist>
<parameterdescription>
<para>(from svmlight active2dnum) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>(from svmlight alphas) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lin</parametername>
</parameternamelist>
<parameterdescription>
<para>(from svmlight linear components) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sumw</parametername>
</parameternamelist>
<parameterdescription>
<para>1/2*alpha&apos;*K_j*alpha for each kernel j </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inner_iters</parametername>
</parameternamelist>
<parameterdescription>
<para>number of required internal iterations </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="265"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1a4d9781041e0ea649e22a6babf233a48f" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float64_t</type>
        <definition>float64_t shogun::CMKL::compute_optimal_betas_via_cplex</definition>
        <argsstring>(float64_t *beta, const float64_t *old_beta, int32_t num_kernels, const float64_t *sumw, float64_t suma, int32_t &amp;inner_iters)</argsstring>
        <name>compute_optimal_betas_via_cplex</name>
        <param>
          <type>float64_t *</type>
          <declname>beta</declname>
        </param>
        <param>
          <type>const float64_t *</type>
          <declname>old_beta</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>num_kernels</declname>
        </param>
        <param>
          <type>const float64_t *</type>
          <declname>sumw</declname>
        </param>
        <param>
          <type>float64_t</type>
          <declname>suma</declname>
        </param>
        <param>
          <type>int32_t &amp;</type>
          <declname>inner_iters</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>given the alphas, compute the corresponding optimal betas using a lp for 1-norm mkl, a qcqp for 2-norm mkl and an iterated qcqp for general q-norm mkl.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beta</parametername>
</parameternamelist>
<parameterdescription>
<para>new betas (kernel weights) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>old_beta</parametername>
</parameternamelist>
<parameterdescription>
<para>old betas (previous kernel weights) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_kernels</parametername>
</parameternamelist>
<parameterdescription>
<para>number of kernels </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sumw</parametername>
</parameternamelist>
<parameterdescription>
<para>1/2*alpha&apos;*K_j*alpha for each kernel j </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>suma</parametername>
</parameternamelist>
<parameterdescription>
<para>(sum over alphas) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inner_iters</parametername>
</parameternamelist>
<parameterdescription>
<para>number of internal iterations (for statistics)</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>new objective value </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="282"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1afdb656acf405309c907ae5df21832ca5" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float64_t</type>
        <definition>float64_t shogun::CMKL::compute_optimal_betas_via_glpk</definition>
        <argsstring>(float64_t *beta, const float64_t *old_beta, int num_kernels, const float64_t *sumw, float64_t suma, int32_t &amp;inner_iters)</argsstring>
        <name>compute_optimal_betas_via_glpk</name>
        <param>
          <type>float64_t *</type>
          <declname>beta</declname>
        </param>
        <param>
          <type>const float64_t *</type>
          <declname>old_beta</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_kernels</declname>
        </param>
        <param>
          <type>const float64_t *</type>
          <declname>sumw</declname>
        </param>
        <param>
          <type>float64_t</type>
          <declname>suma</declname>
        </param>
        <param>
          <type>int32_t &amp;</type>
          <declname>inner_iters</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>given the alphas, compute the corresponding optimal betas using a lp for 1-norm mkl</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beta</parametername>
</parameternamelist>
<parameterdescription>
<para>new betas (kernel weights) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>old_beta</parametername>
</parameternamelist>
<parameterdescription>
<para>old betas (previous kernel weights) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_kernels</parametername>
</parameternamelist>
<parameterdescription>
<para>number of kernels </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sumw</parametername>
</parameternamelist>
<parameterdescription>
<para>1/2*alpha&apos;*K_j*alpha for each kernel j </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>suma</parametername>
</parameternamelist>
<parameterdescription>
<para>(sum over alphas) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inner_iters</parametername>
</parameternamelist>
<parameterdescription>
<para>number of internal iterations (for statistics)</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>new objective value </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="297"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1a885177fda0dd634fe97e8f47a5b84978" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float64_t</type>
        <definition>float64_t shogun::CMKL::compute_optimal_betas_directly</definition>
        <argsstring>(float64_t *beta, const float64_t *old_beta, const int32_t num_kernels, const float64_t *sumw, const float64_t suma, const float64_t mkl_objective)</argsstring>
        <name>compute_optimal_betas_directly</name>
        <param>
          <type>float64_t *</type>
          <declname>beta</declname>
        </param>
        <param>
          <type>const float64_t *</type>
          <declname>old_beta</declname>
        </param>
        <param>
          <type>const int32_t</type>
          <declname>num_kernels</declname>
        </param>
        <param>
          <type>const float64_t *</type>
          <declname>sumw</declname>
        </param>
        <param>
          <type>const float64_t</type>
          <declname>suma</declname>
        </param>
        <param>
          <type>const float64_t</type>
          <declname>mkl_objective</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>given the alphas, compute the corresponding optimal betas</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beta</parametername>
</parameternamelist>
<parameterdescription>
<para>new betas (kernel weights) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>old_beta</parametername>
</parameternamelist>
<parameterdescription>
<para>old betas (previous kernel weights) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_kernels</parametername>
</parameternamelist>
<parameterdescription>
<para>number of kernels </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sumw</parametername>
</parameternamelist>
<parameterdescription>
<para>1/2*alpha&apos;*K_j*alpha for each kernel j </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>suma</parametername>
</parameternamelist>
<parameterdescription>
<para>(sum over alphas) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mkl_objective</parametername>
</parameternamelist>
<parameterdescription>
<para>the current mkl objective</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>new objective value </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="312"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1a8053da2e31ee3d4e692973f98469ae17" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>float64_t</type>
        <definition>float64_t shogun::CMKL::compute_optimal_betas_newton</definition>
        <argsstring>(float64_t *beta, const float64_t *old_beta, int32_t num_kernels, const float64_t *sumw, float64_t suma, float64_t mkl_objective)</argsstring>
        <name>compute_optimal_betas_newton</name>
        <param>
          <type>float64_t *</type>
          <declname>beta</declname>
        </param>
        <param>
          <type>const float64_t *</type>
          <declname>old_beta</declname>
        </param>
        <param>
          <type>int32_t</type>
          <declname>num_kernels</declname>
        </param>
        <param>
          <type>const float64_t *</type>
          <declname>sumw</declname>
        </param>
        <param>
          <type>float64_t</type>
          <declname>suma</declname>
        </param>
        <param>
          <type>float64_t</type>
          <declname>mkl_objective</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>given the alphas, compute the corresponding optimal betas</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beta</parametername>
</parameternamelist>
<parameterdescription>
<para>new betas (kernel weights) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>old_beta</parametername>
</parameternamelist>
<parameterdescription>
<para>old betas (previous kernel weights) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_kernels</parametername>
</parameternamelist>
<parameterdescription>
<para>number of kernels </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sumw</parametername>
</parameternamelist>
<parameterdescription>
<para>1/2*alpha&apos;*K_j*alpha for each kernel j </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>suma</parametername>
</parameternamelist>
<parameterdescription>
<para>(sum over alphas) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mkl_objective</parametername>
</parameternamelist>
<parameterdescription>
<para>the current mkl objective</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>new objective value </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="326"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1ad48c0ca007d641b7bdebfbefb48d209a" prot="protected" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type>bool</type>
        <definition>virtual bool shogun::CMKL::converged</definition>
        <argsstring>()</argsstring>
        <name>converged</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>check if mkl converged, i.e. &apos;gap&apos; is below epsilon</para><para><simplesect kind="return"><para>whether mkl converged </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="333" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="332" bodyend="335"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1a0831b704f4280f41dfabfb520a93010e" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void shogun::CMKL::init_solver</definition>
        <argsstring>()</argsstring>
        <name>init_solver</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>initialize solver such as glpk or cplex </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="338"/>
      </memberdef>
      <memberdef kind="function" id="classshogun_1_1CMKL_1aaa98be05bc9d5ff0c489c30343d28914" prot="protected" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type>const char *</type>
        <definition>virtual const char* shogun::CMKL::get_name</definition>
        <argsstring>() const </argsstring>
        <name>get_name</name>
        <reimplements refid="classshogun_1_1CSVM_1a78b2baa898294c079e52cedc5c6102a0">get_name</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>object name </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="378" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="378" bodyend="378"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Multiple Kernel Learning. </para>    </briefdescription>
    <detaileddescription>
<para>A support vector machine based method for use with multiple kernels. In Multiple Kernel Learning (MKL) in addition to the SVM <formula id="9">$\bf\alpha$</formula> and bias term <formula id="4">$b$</formula> the kernel weights <formula id="10">$\bf\beta$</formula> are estimated in training. The resulting kernel method can be stated as</para><para><formula id="11">\[ f({\bf x})=\sum_{i=0}^{N-1} \alpha_i \sum_{j=0}^M \beta_j k_j({\bf x}, {\bf x_i})+b . \]</formula></para><para>where <formula id="1">$N$</formula> is the number of training examples <formula id="2">$\alpha_i$</formula> are the weights assigned to each training example <formula id="12">$\beta_j$</formula> are the weights assigned to each sub-kernel <formula id="13">$k_j(x,x&apos;)$</formula> are sub-kernels and <formula id="4">$b$</formula> the bias.</para><para>Kernels have to be chosen a-priori. In MKL <formula id="14">$\alpha_i,\;\beta$</formula> and bias are determined by solving the following optimization program</para><para><formula id="15">\begin{eqnarray*} \mbox{min} &amp;&amp; \gamma-\sum_{i=1}^N\alpha_i\\ \mbox{w.r.t.} &amp;&amp; \gamma\in R, \alpha\in R^N \nonumber\\ \mbox{s.t.} &amp;&amp; {\bf 0}\leq\alpha\leq{\bf 1}C,\;\;\sum_{i=1}^N \alpha_i y_i=0 \nonumber\\ &amp;&amp; \frac{1}{2}\sum_{i,j=1}^N \alpha_i \alpha_j y_i y_j k_k({\bf x}_i,{\bf x}_j)\leq \gamma,\;\; \forall k=1,\ldots,K\nonumber\\ \end{eqnarray*}</formula> here C is a pre-specified regularization parameter.</para><para>Within shogun this optimization problem is solved using semi-infinite programming. For 1-norm MKL using one of the two approaches described in</para><para>Soeren Sonnenburg, Gunnar Raetsch, Christin Schaefer, and Bernhard Schoelkopf. Large Scale Multiple Kernel Learning. Journal of Machine Learning Research, 7:1531-1565, July 2006.</para><para>The first approach (also called the wrapper algorithm) wrapps around a single kernel SVMs, alternatingly solving for <formula id="16">$\alpha$</formula> and <formula id="17">$\beta$</formula>. It is using a traditional SVM to generate new violated constraings and thus requires a single kernel SVM and any of the SVMs contained in shogun can be used. In the MKL step either a linear program is solved via glpk or cplex or analytically or a newton (for norms&gt;1) step is performed.</para><para>The second much faster but also more memory demanding approach performing interleaved optimization, is integrated into the chunking-based SVMlight.</para><para>In addition sparsity of MKL can be controlled by the choice of the <formula id="18">$L_p$</formula>-norm regularizing <formula id="17">$\beta$</formula> as described in</para><para>Marius Kloft, Ulf Brefeld, Soeren Sonnenburg, and Alexander Zien. Efficient and accurate lp-norm multiple kernel learning. In Advances in Neural Information Processing Systems 21. MIT Press, Cambridge, MA, 2009. </para>    </detaileddescription>
    <inheritancegraph>
      <node id="175">
        <label>shogun::CMKLOneClass</label>
        <link refid="classshogun_1_1CMKLOneClass"/>
        <childnode refid="170" relation="public-inheritance">
        </childnode>
      </node>
      <node id="172">
        <label>shogun::CKernelMachine</label>
        <link refid="classshogun_1_1CKernelMachine"/>
        <childnode refid="173" relation="public-inheritance">
        </childnode>
      </node>
      <node id="170">
        <label>shogun::CMKL</label>
        <link refid="classshogun_1_1CMKL"/>
        <childnode refid="171" relation="public-inheritance">
        </childnode>
      </node>
      <node id="173">
        <label>shogun::CClassifier</label>
        <link refid="classshogun_1_1CClassifier"/>
      </node>
      <node id="171">
        <label>shogun::CSVM</label>
        <link refid="classshogun_1_1CSVM"/>
        <childnode refid="172" relation="public-inheritance">
        </childnode>
      </node>
      <node id="174">
        <label>shogun::CMKLClassification</label>
        <link refid="classshogun_1_1CMKLClassification"/>
        <childnode refid="170" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="178">
        <label>shogun::CKernelMachine</label>
        <link refid="classshogun_1_1CKernelMachine"/>
        <childnode refid="179" relation="public-inheritance">
        </childnode>
      </node>
      <node id="176">
        <label>shogun::CMKL</label>
        <link refid="classshogun_1_1CMKL"/>
        <childnode refid="177" relation="public-inheritance">
        </childnode>
        <childnode refid="177" relation="usage">
          <edgelabel>svm</edgelabel>
        </childnode>
      </node>
      <node id="179">
        <label>shogun::CClassifier</label>
        <link refid="classshogun_1_1CClassifier"/>
      </node>
      <node id="177">
        <label>shogun::CSVM</label>
        <link refid="classshogun_1_1CSVM"/>
        <childnode refid="178" relation="public-inheritance">
        </childnode>
        <childnode refid="176" relation="usage">
          <edgelabel>mkl</edgelabel>
        </childnode>
      </node>
    </collaborationgraph>
    <location file="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" line="84" bodyfile="/home/thor/Projects/shogun-liblinear/shogun-0.9.1/src/shogun/classifier/mkl/MKL.h" bodystart="83" bodyend="415"/>
    <listofallmembers>
      <member refid="classshogun_1_1CSVM_1abbb1e87fd73520b279ed68913e7d3952" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>C1</name></member>
      <member refid="classshogun_1_1CSVM_1adc7f13258df96749be0c0af03d73b1a3" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>C2</name></member>
      <member refid="classshogun_1_1CMKL_1a53f653a3c9f87453c2500cc80f38df21" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>C_mkl</name></member>
      <member refid="classshogun_1_1CSVM_1aede8a7c6c1c29ef037648e55f79ea582" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>callback</name></member>
      <member refid="classshogun_1_1CClassifier_1a37259b3ffbe96af1eda8dd2d9428221c" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>CClassifier</name></member>
      <member refid="classshogun_1_1CKernelMachine_1af2d719c7dd34401eb1544a6124e88046" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>CKernelMachine</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a38ead2ce9c9b727eb20a463c42c9ce53" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>classify</name></member>
      <member refid="classshogun_1_1CKernelMachine_1ad9cf8044ff5e5dadb06f74903cf248a8" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>classify</name></member>
      <member refid="classshogun_1_1CKernelMachine_1ab081d4a3c5762b75e9b786b8d1025402" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>classify_example</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a842c2010c3c0716616facc0592e39191" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>classify_example_helper</name></member>
      <member refid="classshogun_1_1CMKL_1a76215d7dd0175846cee5bc9f774d9dee" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>CMKL</name></member>
      <member refid="classshogun_1_1CMKL_1a73d4af07d5878e700cd08ff659e928b6" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>compute_mkl_dual_objective</name></member>
      <member refid="classshogun_1_1CMKL_1a64db92316ae517cbaf88293ef06df475" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>compute_mkl_primal_objective</name></member>
      <member refid="classshogun_1_1CMKL_1a885177fda0dd634fe97e8f47a5b84978" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>compute_optimal_betas_directly</name></member>
      <member refid="classshogun_1_1CMKL_1a8053da2e31ee3d4e692973f98469ae17" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>compute_optimal_betas_newton</name></member>
      <member refid="classshogun_1_1CMKL_1a4d9781041e0ea649e22a6babf233a48f" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>compute_optimal_betas_via_cplex</name></member>
      <member refid="classshogun_1_1CMKL_1afdb656acf405309c907ae5df21832ca5" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>compute_optimal_betas_via_glpk</name></member>
      <member refid="classshogun_1_1CMKL_1afc6ed67c16a32315c56965e1ed8dfbe2" prot="public" virt="pure-virtual"><scope>shogun::CMKL</scope><name>compute_sum_alpha</name></member>
      <member refid="classshogun_1_1CMKL_1a6140a61fe8ebc149c9b1143cc950b2a1" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>compute_sum_beta</name></member>
      <member refid="classshogun_1_1CSVM_1a799f48e17928a04f8a59e8e11450d87d" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>compute_svm_dual_objective</name></member>
      <member refid="classshogun_1_1CSVM_1ac7a7ccc604d92c07745f0d20e3cd681f" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>compute_svm_primal_objective</name></member>
      <member refid="classshogun_1_1CMKL_1ad48c0ca007d641b7bdebfbefb48d209a" prot="protected" virt="virtual"><scope>shogun::CMKL</scope><name>converged</name></member>
      <member refid="classshogun_1_1CKernelMachine_1aadb3dcfa41bcdb3cedb4bb590c421f99" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>create_new_model</name></member>
      <member refid="classshogun_1_1CSVM_1a9ed20fde9ba51b6f4a174e6bcdee9bb2" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>CSVM</name></member>
      <member refid="classshogun_1_1CSVM_1ac921019d10ab940c9b9eb430cb0af50d" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>CSVM</name></member>
      <member refid="classshogun_1_1CSVM_1a79f6290f97bdc9178917f6f37f883007" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>epsilon</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a52348988d896bcda6a005c9af0424655" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_alpha</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a34137de1f460aaa60bb888bc42cd8987" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_alphas</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a21f1f26eab5e1177fbb0a5b361020ac2" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_batch_computation_enabled</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a3221b3acb94edfe8cdefa2fc659c6fc8" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_bias</name></member>
      <member refid="classshogun_1_1CKernelMachine_1af7b87d7a2438e8e74e8fb689e609c83b" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_bias_enabled</name></member>
      <member refid="classshogun_1_1CSVM_1aa925c40d161f332b21f5f6c1d5a9e30b" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_C1</name></member>
      <member refid="classshogun_1_1CSVM_1a282a427d35615fe4ce9582d3efc6b766" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_C2</name></member>
      <member refid="classshogun_1_1CClassifier_1a52d05215c6b6a252650c41a0b29d8cc5" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>get_classifier_type</name></member>
      <member refid="classshogun_1_1CSVM_1abf4c3abcdc8f5f5ce5dca52abc631e63" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_epsilon</name></member>
      <member refid="classshogun_1_1CMKL_1ae2e8bb59252ff789312b10d46c8dc387" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_interleaved_optimization_enabled</name></member>
      <member refid="classshogun_1_1CKernelMachine_1aa065ba2b4863e152beb95c03aa6add24" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_kernel</name></member>
      <member refid="classshogun_1_1CClassifier_1a787dcde8fe53a734fcb77f988d821408" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>get_label</name></member>
      <member refid="classshogun_1_1CClassifier_1a5f1f62d263b6201e1624990deadba5a8" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>get_labels</name></member>
      <member refid="classshogun_1_1CKernelMachine_1acc42836c7731c0f029ebd77f045e25cf" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_linadd_enabled</name></member>
      <member refid="classshogun_1_1CSVM_1a97b1aa0697b753cc3898dbb8790bdcfc" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>get_linear_term</name></member>
      <member refid="classshogun_1_1CSVM_1a8dda3a8c4315f988dd1d1dd791bd8152" prot="protected" virt="virtual"><scope>shogun::CMKL</scope><name>get_linear_term_array</name></member>
      <member refid="classshogun_1_1CClassifier_1a6e48967294c55850d95235d487ce2c02" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_max_train_time</name></member>
      <member refid="classshogun_1_1CMKL_1a5c6545a86351390d3ff09518c3b86acc" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_mkl_epsilon</name></member>
      <member refid="classshogun_1_1CMKL_1a0a892fc3ea060af8c0e3119ecab0ae5f" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_mkl_iterations</name></member>
      <member refid="classshogun_1_1CMKL_1aaa98be05bc9d5ff0c489c30343d28914" prot="protected" virt="virtual"><scope>shogun::CMKL</scope><name>get_name</name></member>
      <member refid="classshogun_1_1CSVM_1aa7899e8953ff5bcce8918e5095430552" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_nu</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a639f528d6956936a482523bdc04eb4b5" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_num_support_vectors</name></member>
      <member refid="classshogun_1_1CSVM_1a1a825064f5599e4d3a78d595565c936a" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_objective</name></member>
      <member refid="classshogun_1_1CSVM_1aa9f220fc5a0f7222fe8a71316ffa0310" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_qpsize</name></member>
      <member refid="classshogun_1_1CSVM_1a727c64fadb95845ffc75f0d9d1766076" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_shrinking_enabled</name></member>
      <member refid="classshogun_1_1CClassifier_1a8a3acda6819b4a4b77b656b6b9e1817c" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_solver_type</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a340532552838d25c1a0917d59de1dbee" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_support_vector</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a50bd31e7cf0cabc0ec41896ab97292fa" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_support_vectors</name></member>
      <member refid="classshogun_1_1CMKL_1a5e1128495509231d0d44c1119b52af6e" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>get_svm</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a0915cae39b88af20c288fbc1f5979afb" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>init_kernel_optimization</name></member>
      <member refid="classshogun_1_1CMKL_1a0831b704f4280f41dfabfb520a93010e" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>init_solver</name></member>
      <member refid="classshogun_1_1CMKL_1a3d50bcedd22efd0c162831c336b23558" prot="protected" virt="pure-virtual"><scope>shogun::CMKL</scope><name>init_training</name></member>
      <member refid="classshogun_1_1CMKL_1a82eb45ca35ab6d9db34356732cee0208" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>interleaved_optimization</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a6d47114463588d9dbd672180dc2e7357" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>kernel</name></member>
      <member refid="classshogun_1_1CClassifier_1a68f1285e63422a24319ed95910d72f73" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>labels</name></member>
      <member refid="classshogun_1_1CSVM_1a4103dd9a97319317117e84e5cb9ce473" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>linear_term</name></member>
      <member refid="classshogun_1_1CSVM_1a53bdb4afaf8f88c2e52d783b28d68703" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>load</name></member>
      <member refid="classshogun_1_1CMKL_1a96257f68ec9ec1d6e95cd275e95d19ae" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>lp_initialized</name></member>
      <member refid="classshogun_1_1CKernelMachine_1ac40c305fb5587c0004d5338ea6d712d2" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>m_alpha</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a5c8a9af0e7b79d02d0be95b3cd8e9910" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>m_bias</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a7e1c9037fb66d596c5dd83c28b8dce6d" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>m_svs</name></member>
      <member refid="classshogun_1_1CClassifier_1a8524d634a67f3538b112f72d7835af46" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>max_train_time</name></member>
      <member refid="classshogun_1_1CSVM_1a94d628c09667f3b469ad4852f9e29690" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>mkl</name></member>
      <member refid="classshogun_1_1CMKL_1aeab6ca49ab478af35bf267a038b8f43f" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>mkl_epsilon</name></member>
      <member refid="classshogun_1_1CMKL_1af18297125c8800179bc8c8b29be65175" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>mkl_iterations</name></member>
      <member refid="classshogun_1_1CMKL_1a90dce2495aa6de1456bf0d13d9c617c6" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>mkl_norm</name></member>
      <member refid="classshogun_1_1CSVM_1a13b42636b6f32acb975043ad16e77b0a" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>nu</name></member>
      <member refid="classshogun_1_1CKernelMachine_1ab4fbabe44610f09e33362234eb131432" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>num_svs</name></member>
      <member refid="classshogun_1_1CSVM_1a1793d92e74d09027ce319f5e6bf55f87" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>objective</name></member>
      <member refid="classshogun_1_1CMKL_1abb840747ae20fbeb88093a6d61e0d2c5" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>perform_mkl_step</name></member>
      <member refid="classshogun_1_1CMKL_1a5d960353089b92ff019afc32224a7083" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>perform_mkl_step</name></member>
      <member refid="classshogun_1_1CMKL_1af7ee654de550c6d682dc78c37f84278c" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>perform_mkl_step_helper</name></member>
      <member refid="classshogun_1_1CSVM_1af10c87729b08be38d1bbe7daa1502420" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>qpsize</name></member>
      <member refid="classshogun_1_1CMKL_1a8c0914c4ab24878458682bea1de00a5c" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>rho</name></member>
      <member refid="classshogun_1_1CSVM_1aec8a6cbb16a1803a291f383ef8eb7c71" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>save</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a804a4f283e98849f4b85a6d52371a848" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_alpha</name></member>
      <member refid="classshogun_1_1CKernelMachine_1ae057fbcb6071331223f1a26de82d1f88" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_alphas</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a1bef02fca7cd9808c9c67c898109a8d2" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_batch_computation_enabled</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a5edc82a48029b91216251b354d341452" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_bias</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a95eb6221dd46fe2dc9fb42b53845df36" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_bias_enabled</name></member>
      <member refid="classshogun_1_1CSVM_1af745c6d5d45c5225c4d2a0b8743632db" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_C</name></member>
      <member refid="classshogun_1_1CMKL_1accf64f1c3983a54882782852f5a6875d" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_C_mkl</name></member>
      <member refid="classshogun_1_1CSVM_1a2798c8deb9a8712d9f49666dd1fb19d6" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_callback_function</name></member>
      <member refid="classshogun_1_1CMKL_1a7f00ad77a34c500edc2e379618a3af6c" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_constraint_generator</name></member>
      <member refid="classshogun_1_1CSVM_1ac882137277cca76b55c28541ddc5e542" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_defaults</name></member>
      <member refid="classshogun_1_1CSVM_1a49773823645284d75da2b22a1707b9e7" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_epsilon</name></member>
      <member refid="classshogun_1_1CMKL_1aa761562aa28d4801f271fd5a264d6599" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_interleaved_optimization_enabled</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a9a26799c7d6769d6f7d052b984718c72" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_kernel</name></member>
      <member refid="classshogun_1_1CClassifier_1aa6b87d22c14fc2b6970d8bf1edbb15fb" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>set_labels</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a605209bfe9a431912fc9a718df808887" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_linadd_enabled</name></member>
      <member refid="classshogun_1_1CSVM_1a3b8ec9a1ff4992e6f9e400568aa06d09" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>set_linear_term</name></member>
      <member refid="classshogun_1_1CClassifier_1af8930a0a848388d8647c9e4604a7856d" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_max_train_time</name></member>
      <member refid="classshogun_1_1CMKL_1add6fc2f09354065ebb0ae46d58c4ae9b" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_mkl_epsilon</name></member>
      <member refid="classshogun_1_1CMKL_1aae9cf6c48e13ead57da32f42fc12d844" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_mkl_norm</name></member>
      <member refid="classshogun_1_1CSVM_1a80eb31d8811d31e4612a0856424db063" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_nu</name></member>
      <member refid="classshogun_1_1CSVM_1a9fedfc8004e361f44a9eef1248088c16" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_objective</name></member>
      <member refid="classshogun_1_1CSVM_1a349a01da8d94a5ce76475a205b9a0d17" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_qpsize</name></member>
      <member refid="classshogun_1_1CSVM_1a3fb0649330798f231b7e864ef3659e8f" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_shrinking_enabled</name></member>
      <member refid="classshogun_1_1CClassifier_1a4c87d6f3a2342c3053aeca82c3cf528c" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_solver_type</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a2746562f3c38954ca0a27089cfbd6eeb" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_support_vector</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a69402864eced218da049c53529138c45" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_support_vectors</name></member>
      <member refid="classshogun_1_1CMKL_1a43c2a403cf426ca47ddf1836c086f259" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_svm</name></member>
      <member refid="classshogun_1_1CSVM_1a197e3be46c604e75917e6f197562f3da" prot="public" virt="non-virtual"><scope>shogun::CMKL</scope><name>set_tube_epsilon</name></member>
      <member refid="classshogun_1_1CClassifier_1a360902e938d7b8890084c5bc6df617be" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>solver_type</name></member>
      <member refid="classshogun_1_1CMKL_1a01c377423a211060040afabc91a1789b" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>svm</name></member>
      <member refid="classshogun_1_1CSVM_1a883d54a63cea716452a35467c90c0d97" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>svm_loaded</name></member>
      <member refid="classshogun_1_1CMKL_1a81e15c891b0ca00c378cd6dfe5b8b7f0" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>train</name></member>
      <member refid="classshogun_1_1CSVM_1aac8050c6b0d7d922330de0fa3e8c1570" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>tube_epsilon</name></member>
      <member refid="classshogun_1_1CKernelMachine_1ade160206d7ddebd3ab2f8d1f40aaa7f9" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>use_batch_computation</name></member>
      <member refid="classshogun_1_1CKernelMachine_1abf9e9cb89f609d79b36a4d1a7f6945b9" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>use_bias</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a8dde883a0c2f53867711a2408e3bef16" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>use_linadd</name></member>
      <member refid="classshogun_1_1CSVM_1a38e40e0db03787a48f54877e53f1f49b" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>use_shrinking</name></member>
      <member refid="classshogun_1_1CMKL_1ac6746bda1ee0bf765fd3217546f6391d" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>W</name></member>
      <member refid="classshogun_1_1CMKL_1aa1e0044b4b9145a33f786d5cc37abaef" prot="protected" virt="non-virtual"><scope>shogun::CMKL</scope><name>w_gap</name></member>
      <member refid="classshogun_1_1CClassifier_1ae7d6c7d39fb314c1092163e958ef66a8" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>~CClassifier</name></member>
      <member refid="classshogun_1_1CKernelMachine_1a5d9a0f4626b37665f847cf209e94a2ed" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>~CKernelMachine</name></member>
      <member refid="classshogun_1_1CMKL_1a4cf1e4d5cd34bcbf5672ddedbb7a77c7" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>~CMKL</name></member>
      <member refid="classshogun_1_1CSVM_1aaa7cb652cc6a927d00b696637efccd49" prot="public" virt="virtual"><scope>shogun::CMKL</scope><name>~CSVM</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
