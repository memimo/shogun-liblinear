# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.
# This file is compatible with both classic and new-style classes.

"""
The `Kernel` module gathers all kernels available in the SHOGUN toolkit.
"""

import _Kernel
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types


class ShogunException(_object):
    """Proxy of C++ ShogunException class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShogunException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ShogunException, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self, str) -> ShogunException"""
        this = _Kernel.new_ShogunException(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_ShogunException
    __del__ = lambda self : None;
    def get_exception_string(*args):
        """get_exception_string(self) -> str"""
        return _Kernel.ShogunException_get_exception_string(*args)

ShogunException_swigregister = _Kernel.ShogunException_swigregister
ShogunException_swigregister(ShogunException)

MSG_GCDEBUG = _Kernel.MSG_GCDEBUG
MSG_DEBUG = _Kernel.MSG_DEBUG
MSG_INFO = _Kernel.MSG_INFO
MSG_NOTICE = _Kernel.MSG_NOTICE
MSG_WARN = _Kernel.MSG_WARN
MSG_ERROR = _Kernel.MSG_ERROR
MSG_CRITICAL = _Kernel.MSG_CRITICAL
MSG_ALERT = _Kernel.MSG_ALERT
MSG_EMERGENCY = _Kernel.MSG_EMERGENCY
MSG_MESSAGEONLY = _Kernel.MSG_MESSAGEONLY
class IO(_object):
    """Proxy of C++ IO class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IO, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IO, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IO
        __init__(self, orig) -> IO
        """
        this = _Kernel.new_IO(*args)
        try: self.this.append(this)
        except: self.this = this
    def set_loglevel(*args):
        """set_loglevel(self, level)"""
        return _Kernel.IO_set_loglevel(*args)

    def get_loglevel(*args):
        """get_loglevel(self) -> EMessageType"""
        return _Kernel.IO_get_loglevel(*args)

    def get_show_progress(*args):
        """get_show_progress(self) -> bool"""
        return _Kernel.IO_get_show_progress(*args)

    def get_show_file_and_line(*args):
        """get_show_file_and_line(self) -> bool"""
        return _Kernel.IO_get_show_file_and_line(*args)

    def message(*args):
        """message(self, prio, file, line, fmt, ?)"""
        return _Kernel.IO_message(*args)

    def progress(*args):
        """
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        progress(self, current_val, min_val=0.0, max_val=1.0, decimals=1)
        progress(self, current_val, min_val=0.0, max_val=1.0)
        progress(self, current_val, min_val=0.0)
        progress(self, current_val)
        """
        return _Kernel.IO_progress(*args)

    def absolute_progress(*args):
        """
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1, 
            prefix="PROGRESS:\t")
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0, decimals=1)
        absolute_progress(self, current_val, val, min_val=0.0, max_val=1.0)
        absolute_progress(self, current_val, val, min_val=0.0)
        absolute_progress(self, current_val, val)
        """
        return _Kernel.IO_absolute_progress(*args)

    def done(*args):
        """done(self)"""
        return _Kernel.IO_done(*args)

    def not_implemented(*args):
        """not_implemented(self, file, line)"""
        return _Kernel.IO_not_implemented(*args)

    def deprecated(*args):
        """deprecated(self, file, line)"""
        return _Kernel.IO_deprecated(*args)

    def buffered_message(*args):
        """buffered_message(self, prio, fmt, ?)"""
        return _Kernel.IO_buffered_message(*args)

    def skip_spaces(*args):
        """skip_spaces(str) -> str"""
        return _Kernel.IO_skip_spaces(*args)

    if _newclass:skip_spaces = staticmethod(skip_spaces)
    __swig_getmethods__["skip_spaces"] = lambda x: skip_spaces
    def skip_blanks(*args):
        """skip_blanks(str) -> str"""
        return _Kernel.IO_skip_blanks(*args)

    if _newclass:skip_blanks = staticmethod(skip_blanks)
    __swig_getmethods__["skip_blanks"] = lambda x: skip_blanks
    def get_target(*args):
        """get_target(self) -> FILE"""
        return _Kernel.IO_get_target(*args)

    def set_target(*args):
        """set_target(self, target)"""
        return _Kernel.IO_set_target(*args)

    def set_target_to_stderr(*args):
        """set_target_to_stderr(self)"""
        return _Kernel.IO_set_target_to_stderr(*args)

    def set_target_to_stdout(*args):
        """set_target_to_stdout(self)"""
        return _Kernel.IO_set_target_to_stdout(*args)

    def enable_progress(*args):
        """enable_progress(self)"""
        return _Kernel.IO_enable_progress(*args)

    def disable_progress(*args):
        """disable_progress(self)"""
        return _Kernel.IO_disable_progress(*args)

    def enable_file_and_line(*args):
        """enable_file_and_line(self)"""
        return _Kernel.IO_enable_file_and_line(*args)

    def disable_file_and_line(*args):
        """disable_file_and_line(self)"""
        return _Kernel.IO_disable_file_and_line(*args)

    def set_dirname(*args):
        """set_dirname(dirname)"""
        return _Kernel.IO_set_dirname(*args)

    if _newclass:set_dirname = staticmethod(set_dirname)
    __swig_getmethods__["set_dirname"] = lambda x: set_dirname
    def concat_filename(*args):
        """concat_filename(filename) -> str"""
        return _Kernel.IO_concat_filename(*args)

    if _newclass:concat_filename = staticmethod(concat_filename)
    __swig_getmethods__["concat_filename"] = lambda x: concat_filename
    def filter(*args):
        """filter(d) -> int"""
        return _Kernel.IO_filter(*args)

    if _newclass:filter = staticmethod(filter)
    __swig_getmethods__["filter"] = lambda x: filter
    def ref(*args):
        """ref(self) ->  int"""
        return _Kernel.IO_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Kernel.IO_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Kernel.IO_unref(*args)

    def get_name(*args):
        """get_name(self) -> str"""
        return _Kernel.IO_get_name(*args)

    __swig_destroy__ = _Kernel.delete_IO
    __del__ = lambda self : None;
IO_swigregister = _Kernel.IO_swigregister
IO_swigregister(IO)
cvar = _Kernel.cvar

def IO_skip_spaces(*args):
  """IO_skip_spaces(str) -> str"""
  return _Kernel.IO_skip_spaces(*args)

def IO_skip_blanks(*args):
  """IO_skip_blanks(str) -> str"""
  return _Kernel.IO_skip_blanks(*args)

def IO_set_dirname(*args):
  """IO_set_dirname(dirname)"""
  return _Kernel.IO_set_dirname(*args)

def IO_concat_filename(*args):
  """IO_concat_filename(filename) -> str"""
  return _Kernel.IO_concat_filename(*args)

def IO_filter(*args):
  """IO_filter(d) -> int"""
  return _Kernel.IO_filter(*args)

class SGObject(_object):
    """Proxy of C++ SGObject class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SGObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SGObject, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_SGObject
    __del__ = lambda self : None;
    def ref(*args):
        """ref(self) ->  int"""
        return _Kernel.SGObject_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Kernel.SGObject_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Kernel.SGObject_unref(*args)

    def get_name(*args):
        """get_name(self) -> str"""
        return _Kernel.SGObject_get_name(*args)

    __swig_setmethods__["io"] = _Kernel.SGObject_io_set
    __swig_getmethods__["io"] = _Kernel.SGObject_io_get
    if _newclass:io = _swig_property(_Kernel.SGObject_io_get, _Kernel.SGObject_io_set)
    __swig_setmethods__["parallel"] = _Kernel.SGObject_parallel_set
    __swig_getmethods__["parallel"] = _Kernel.SGObject_parallel_get
    if _newclass:parallel = _swig_property(_Kernel.SGObject_parallel_get, _Kernel.SGObject_parallel_set)
    __swig_setmethods__["version"] = _Kernel.SGObject_version_set
    __swig_getmethods__["version"] = _Kernel.SGObject_version_get
    if _newclass:version = _swig_property(_Kernel.SGObject_version_get, _Kernel.SGObject_version_set)
SGObject_swigregister = _Kernel.SGObject_swigregister
SGObject_swigregister(SGObject)

class Version(_object):
    """Proxy of C++ Version class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Version, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Version, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """__init__(self) -> Version"""
        this = _Kernel.new_Version(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_Version
    __del__ = lambda self : None;
    def print_version(*args):
        """print_version()"""
        return _Kernel.Version_print_version(*args)

    if _newclass:print_version = staticmethod(print_version)
    __swig_getmethods__["print_version"] = lambda x: print_version
    def get_version_extra(*args):
        """get_version_extra() -> str"""
        return _Kernel.Version_get_version_extra(*args)

    if _newclass:get_version_extra = staticmethod(get_version_extra)
    __swig_getmethods__["get_version_extra"] = lambda x: get_version_extra
    def get_version_release(*args):
        """get_version_release() -> str"""
        return _Kernel.Version_get_version_release(*args)

    if _newclass:get_version_release = staticmethod(get_version_release)
    __swig_getmethods__["get_version_release"] = lambda x: get_version_release
    def get_version_revision(*args):
        """get_version_revision() ->  int"""
        return _Kernel.Version_get_version_revision(*args)

    if _newclass:get_version_revision = staticmethod(get_version_revision)
    __swig_getmethods__["get_version_revision"] = lambda x: get_version_revision
    def get_version_year(*args):
        """get_version_year() ->  int"""
        return _Kernel.Version_get_version_year(*args)

    if _newclass:get_version_year = staticmethod(get_version_year)
    __swig_getmethods__["get_version_year"] = lambda x: get_version_year
    def get_version_month(*args):
        """get_version_month() ->  int"""
        return _Kernel.Version_get_version_month(*args)

    if _newclass:get_version_month = staticmethod(get_version_month)
    __swig_getmethods__["get_version_month"] = lambda x: get_version_month
    def get_version_day(*args):
        """get_version_day() ->  int"""
        return _Kernel.Version_get_version_day(*args)

    if _newclass:get_version_day = staticmethod(get_version_day)
    __swig_getmethods__["get_version_day"] = lambda x: get_version_day
    def get_version_hour(*args):
        """get_version_hour() ->  int"""
        return _Kernel.Version_get_version_hour(*args)

    if _newclass:get_version_hour = staticmethod(get_version_hour)
    __swig_getmethods__["get_version_hour"] = lambda x: get_version_hour
    def get_version_minute(*args):
        """get_version_minute() ->  int"""
        return _Kernel.Version_get_version_minute(*args)

    if _newclass:get_version_minute = staticmethod(get_version_minute)
    __swig_getmethods__["get_version_minute"] = lambda x: get_version_minute
    def get_version_in_minutes(*args):
        """get_version_in_minutes() -> int"""
        return _Kernel.Version_get_version_in_minutes(*args)

    if _newclass:get_version_in_minutes = staticmethod(get_version_in_minutes)
    __swig_getmethods__["get_version_in_minutes"] = lambda x: get_version_in_minutes
    def ref(*args):
        """ref(self) ->  int"""
        return _Kernel.Version_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Kernel.Version_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Kernel.Version_unref(*args)

Version_swigregister = _Kernel.Version_swigregister
Version_swigregister(Version)

def Version_print_version(*args):
  """Version_print_version()"""
  return _Kernel.Version_print_version(*args)

def Version_get_version_extra(*args):
  """Version_get_version_extra() -> str"""
  return _Kernel.Version_get_version_extra(*args)

def Version_get_version_release(*args):
  """Version_get_version_release() -> str"""
  return _Kernel.Version_get_version_release(*args)

def Version_get_version_revision(*args):
  """Version_get_version_revision() ->  int"""
  return _Kernel.Version_get_version_revision(*args)

def Version_get_version_year(*args):
  """Version_get_version_year() ->  int"""
  return _Kernel.Version_get_version_year(*args)

def Version_get_version_month(*args):
  """Version_get_version_month() ->  int"""
  return _Kernel.Version_get_version_month(*args)

def Version_get_version_day(*args):
  """Version_get_version_day() ->  int"""
  return _Kernel.Version_get_version_day(*args)

def Version_get_version_hour(*args):
  """Version_get_version_hour() ->  int"""
  return _Kernel.Version_get_version_hour(*args)

def Version_get_version_minute(*args):
  """Version_get_version_minute() ->  int"""
  return _Kernel.Version_get_version_minute(*args)

def Version_get_version_in_minutes(*args):
  """Version_get_version_in_minutes() -> int"""
  return _Kernel.Version_get_version_in_minutes(*args)

class Parallel(_object):
    """Proxy of C++ Parallel class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Parallel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Parallel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> Parallel
        __init__(self, orig) -> Parallel
        """
        this = _Kernel.new_Parallel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_Parallel
    __del__ = lambda self : None;
    def get_num_cpus(*args):
        """get_num_cpus(self) ->  int"""
        return _Kernel.Parallel_get_num_cpus(*args)

    def set_num_threads(*args):
        """set_num_threads(self, n)"""
        return _Kernel.Parallel_set_num_threads(*args)

    def get_num_threads(*args):
        """get_num_threads(self) ->  int"""
        return _Kernel.Parallel_get_num_threads(*args)

    def ref(*args):
        """ref(self) ->  int"""
        return _Kernel.Parallel_ref(*args)

    def ref_count(*args):
        """ref_count(self) ->  int"""
        return _Kernel.Parallel_ref_count(*args)

    def unref(*args):
        """unref(self) ->  int"""
        return _Kernel.Parallel_unref(*args)

Parallel_swigregister = _Kernel.Parallel_swigregister
Parallel_swigregister(Parallel)

class PySwigIterator(_object):
    """Proxy of C++ PySwigIterator class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_PySwigIterator
    __del__ = lambda self : None;
    def value(*args):
        """value(self) -> PyObject"""
        return _Kernel.PySwigIterator_value(*args)

    def incr(*args):
        """
        incr(self, n=1) -> PySwigIterator
        incr(self) -> PySwigIterator
        """
        return _Kernel.PySwigIterator_incr(*args)

    def decr(*args):
        """
        decr(self, n=1) -> PySwigIterator
        decr(self) -> PySwigIterator
        """
        return _Kernel.PySwigIterator_decr(*args)

    def distance(*args):
        """distance(self, x) -> ptrdiff_t"""
        return _Kernel.PySwigIterator_distance(*args)

    def equal(*args):
        """equal(self, x) -> bool"""
        return _Kernel.PySwigIterator_equal(*args)

    def copy(*args):
        """copy(self) -> PySwigIterator"""
        return _Kernel.PySwigIterator_copy(*args)

    def next(*args):
        """next(self) -> PyObject"""
        return _Kernel.PySwigIterator_next(*args)

    def previous(*args):
        """previous(self) -> PyObject"""
        return _Kernel.PySwigIterator_previous(*args)

    def advance(*args):
        """advance(self, n) -> PySwigIterator"""
        return _Kernel.PySwigIterator_advance(*args)

    def __eq__(*args):
        """__eq__(self, x) -> bool"""
        return _Kernel.PySwigIterator___eq__(*args)

    def __ne__(*args):
        """__ne__(self, x) -> bool"""
        return _Kernel.PySwigIterator___ne__(*args)

    def __iadd__(*args):
        """__iadd__(self, n) -> PySwigIterator"""
        return _Kernel.PySwigIterator___iadd__(*args)

    def __isub__(*args):
        """__isub__(self, n) -> PySwigIterator"""
        return _Kernel.PySwigIterator___isub__(*args)

    def __add__(*args):
        """__add__(self, n) -> PySwigIterator"""
        return _Kernel.PySwigIterator___add__(*args)

    def __sub__(*args):
        """
        __sub__(self, n) -> PySwigIterator
        __sub__(self, x) -> ptrdiff_t
        """
        return _Kernel.PySwigIterator___sub__(*args)

    def __iter__(self): return self
PySwigIterator_swigregister = _Kernel.PySwigIterator_swigregister
PySwigIterator_swigregister(PySwigIterator)

class IntVector(_object):
    """Proxy of C++ IntVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _Kernel.IntVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _Kernel.IntVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(int)>::size_type"""
        return _Kernel.IntVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(int)>::value_type"""
        return _Kernel.IntVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> IntVector"""
        return _Kernel.IntVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _Kernel.IntVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _Kernel.IntVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _Kernel.IntVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(int)>::value_type"""
        return _Kernel.IntVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _Kernel.IntVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _Kernel.IntVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _Kernel.IntVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(int)>::size_type"""
        return _Kernel.IntVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _Kernel.IntVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _Kernel.IntVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(int)>::allocator_type"""
        return _Kernel.IntVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(int)>::const_iterator"""
        return _Kernel.IntVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(int)>::const_iterator"""
        return _Kernel.IntVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _Kernel.IntVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(int)>::const_reverse_iterator"""
        return _Kernel.IntVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _Kernel.IntVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(int)>::iterator
        erase(self, first, last) -> std::vector<(int)>::iterator
        """
        return _Kernel.IntVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> IntVector
        __init__(self, ?) -> IntVector
        __init__(self, size) -> IntVector
        __init__(self, size, value) -> IntVector
        """
        this = _Kernel.new_IntVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _Kernel.IntVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(int)>::value_type"""
        return _Kernel.IntVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(int)>::value_type"""
        return _Kernel.IntVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _Kernel.IntVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _Kernel.IntVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(int)>::iterator
        insert(self, pos, n, x)
        """
        return _Kernel.IntVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _Kernel.IntVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(int)>::size_type"""
        return _Kernel.IntVector_capacity(*args)

    __swig_destroy__ = _Kernel.delete_IntVector
    __del__ = lambda self : None;
IntVector_swigregister = _Kernel.IntVector_swigregister
IntVector_swigregister(IntVector)

class DoubleVector(_object):
    """Proxy of C++ DoubleVector class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr
    def iterator(*args):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _Kernel.DoubleVector_iterator(*args)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args):
        """__nonzero__(self) -> bool"""
        return _Kernel.DoubleVector___nonzero__(*args)

    def __len__(*args):
        """__len__(self) -> std::vector<(double)>::size_type"""
        return _Kernel.DoubleVector___len__(*args)

    def pop(*args):
        """pop(self) -> std::vector<(double)>::value_type"""
        return _Kernel.DoubleVector_pop(*args)

    def __getslice__(*args):
        """__getslice__(self, i, j) -> DoubleVector"""
        return _Kernel.DoubleVector___getslice__(*args)

    def __setslice__(*args):
        """__setslice__(self, i, j, v)"""
        return _Kernel.DoubleVector___setslice__(*args)

    def __delslice__(*args):
        """__delslice__(self, i, j)"""
        return _Kernel.DoubleVector___delslice__(*args)

    def __delitem__(*args):
        """__delitem__(self, i)"""
        return _Kernel.DoubleVector___delitem__(*args)

    def __getitem__(*args):
        """__getitem__(self, i) -> std::vector<(double)>::value_type"""
        return _Kernel.DoubleVector___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, i, x)"""
        return _Kernel.DoubleVector___setitem__(*args)

    def append(*args):
        """append(self, x)"""
        return _Kernel.DoubleVector_append(*args)

    def empty(*args):
        """empty(self) -> bool"""
        return _Kernel.DoubleVector_empty(*args)

    def size(*args):
        """size(self) -> std::vector<(double)>::size_type"""
        return _Kernel.DoubleVector_size(*args)

    def clear(*args):
        """clear(self)"""
        return _Kernel.DoubleVector_clear(*args)

    def swap(*args):
        """swap(self, v)"""
        return _Kernel.DoubleVector_swap(*args)

    def get_allocator(*args):
        """get_allocator(self) -> std::vector<(double)>::allocator_type"""
        return _Kernel.DoubleVector_get_allocator(*args)

    def begin(*args):
        """begin(self) -> std::vector<(double)>::const_iterator"""
        return _Kernel.DoubleVector_begin(*args)

    def end(*args):
        """end(self) -> std::vector<(double)>::const_iterator"""
        return _Kernel.DoubleVector_end(*args)

    def rbegin(*args):
        """rbegin(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _Kernel.DoubleVector_rbegin(*args)

    def rend(*args):
        """rend(self) -> std::vector<(double)>::const_reverse_iterator"""
        return _Kernel.DoubleVector_rend(*args)

    def pop_back(*args):
        """pop_back(self)"""
        return _Kernel.DoubleVector_pop_back(*args)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(double)>::iterator
        erase(self, first, last) -> std::vector<(double)>::iterator
        """
        return _Kernel.DoubleVector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> DoubleVector
        __init__(self, ?) -> DoubleVector
        __init__(self, size) -> DoubleVector
        __init__(self, size, value) -> DoubleVector
        """
        this = _Kernel.new_DoubleVector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args):
        """push_back(self, x)"""
        return _Kernel.DoubleVector_push_back(*args)

    def front(*args):
        """front(self) -> std::vector<(double)>::value_type"""
        return _Kernel.DoubleVector_front(*args)

    def back(*args):
        """back(self) -> std::vector<(double)>::value_type"""
        return _Kernel.DoubleVector_back(*args)

    def assign(*args):
        """assign(self, n, x)"""
        return _Kernel.DoubleVector_assign(*args)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _Kernel.DoubleVector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(double)>::iterator
        insert(self, pos, n, x)
        """
        return _Kernel.DoubleVector_insert(*args)

    def reserve(*args):
        """reserve(self, n)"""
        return _Kernel.DoubleVector_reserve(*args)

    def capacity(*args):
        """capacity(self) -> std::vector<(double)>::size_type"""
        return _Kernel.DoubleVector_capacity(*args)

    __swig_destroy__ = _Kernel.delete_DoubleVector
    __del__ = lambda self : None;
DoubleVector_swigregister = _Kernel.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

FASTBUTMEMHUNGRY = _Kernel.FASTBUTMEMHUNGRY
SLOWBUTMEMEFFICIENT = _Kernel.SLOWBUTMEMEFFICIENT
K_UNKNOWN = _Kernel.K_UNKNOWN
K_LINEAR = _Kernel.K_LINEAR
K_SPARSELINEAR = _Kernel.K_SPARSELINEAR
K_POLY = _Kernel.K_POLY
K_GAUSSIAN = _Kernel.K_GAUSSIAN
K_SPARSEGAUSSIAN = _Kernel.K_SPARSEGAUSSIAN
K_GAUSSIANSHIFT = _Kernel.K_GAUSSIANSHIFT
K_HISTOGRAM = _Kernel.K_HISTOGRAM
K_SALZBERG = _Kernel.K_SALZBERG
K_LOCALITYIMPROVED = _Kernel.K_LOCALITYIMPROVED
K_SIMPLELOCALITYIMPROVED = _Kernel.K_SIMPLELOCALITYIMPROVED
K_FIXEDDEGREE = _Kernel.K_FIXEDDEGREE
K_WEIGHTEDDEGREE = _Kernel.K_WEIGHTEDDEGREE
K_WEIGHTEDDEGREEPOS = _Kernel.K_WEIGHTEDDEGREEPOS
K_WEIGHTEDCOMMWORDSTRING = _Kernel.K_WEIGHTEDCOMMWORDSTRING
K_POLYMATCH = _Kernel.K_POLYMATCH
K_ALIGNMENT = _Kernel.K_ALIGNMENT
K_COMMWORDSTRING = _Kernel.K_COMMWORDSTRING
K_COMMULONGSTRING = _Kernel.K_COMMULONGSTRING
K_COMBINED = _Kernel.K_COMBINED
K_AUC = _Kernel.K_AUC
K_CUSTOM = _Kernel.K_CUSTOM
K_SIGMOID = _Kernel.K_SIGMOID
K_CHI2 = _Kernel.K_CHI2
K_DIAG = _Kernel.K_DIAG
K_CONST = _Kernel.K_CONST
K_DISTANCE = _Kernel.K_DISTANCE
K_LOCALALIGNMENT = _Kernel.K_LOCALALIGNMENT
K_PYRAMIDCHI2 = _Kernel.K_PYRAMIDCHI2
K_OLIGO = _Kernel.K_OLIGO
K_MATCHWORD = _Kernel.K_MATCHWORD
K_TPPK = _Kernel.K_TPPK
K_REGULATORYMODULES = _Kernel.K_REGULATORYMODULES
KP_NONE = _Kernel.KP_NONE
KP_LINADD = _Kernel.KP_LINADD
KP_KERNCOMBINATION = _Kernel.KP_KERNCOMBINATION
KP_BATCHEVALUATION = _Kernel.KP_BATCHEVALUATION
class Kernel(SGObject):
    """
    The Kernel base class.

    Non-mathematically spoken, a kernel is a function that given two input
    objects ${\\bf x}$ and ${\\bf x'}$ returns a score describing the
    similarity of the vectors. The score should be larger when the objects
    are more similar.

    It can be defined as

    \\[ k({\\bf x},{\\bf x'})= \\Phi_k({\\bf x})\\cdot
    \\Phi_k({\\bf x'}) \\]

    where $\\Phi$ maps the objects into some potentially high
    dimensional feature space.

    Apart from the input features, the base kernel takes only one argument
    (the size of the kernel cache) that is used to efficiently train
    kernel-machines like e.g. SVMs.

    In case you would like to define your own kernel, you only have to
    define a new compute() function (and the kernel name via get_name()
    and the kernel type get_kernel_type()). A good example to look at is
    the GaussianKernel.

    C++ includes: Kernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Kernel, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Kernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_Kernel
    __del__ = lambda self : None;
    def kernel(*args):
        """
        kernel(self, idx_a, idx_b) -> float

        get kernel function for lhs feature vector a and rhs feature vector b

        Parameters:
        -----------

        idx_a:  index of feature vector a

        idx_b:  index of feature vector b

        computed kernel function 
        """
        return _Kernel.Kernel_kernel(*args)

    def get_kernel_matrix(*args):
        """
        get_kernel_matrix(self) -> numpy 2dim array of float

        get kernel matrix real

        Parameters:
        -----------

        m:  dimension m of matrix

        n:  dimension n of matrix

        target:  the kernel matrix

        the kernel matrix 
        """
        return _Kernel.Kernel_get_kernel_matrix(*args)

    def init(*args):
        """
        init(self, lhs, rhs) -> bool

        initialize kernel e.g. setup lhs/rhs of kernel, precompute
        normalization constants etc. make sure to check that your kernel can
        deal with the supplied features (!)

        Parameters:
        -----------

        lhs:  features for left-hand side

        rhs:  features for right-hand side

        if init was successful 
        """
        return _Kernel.Kernel_init(*args)

    def set_normalizer(*args):
        """
        set_normalizer(self, normalizer) -> bool

        set the current kernel normalizer

        if successful 
        """
        return _Kernel.Kernel_set_normalizer(*args)

    def get_normalizer(*args):
        """
        get_normalizer(self) -> KernelNormalizer

        obtain the current kernel normalizer

        the kernel normalizer 
        """
        return _Kernel.Kernel_get_normalizer(*args)

    def init_normalizer(*args):
        """
        init_normalizer(self) -> bool

        initialize the current kernel normalizer if init was successful 
        """
        return _Kernel.Kernel_init_normalizer(*args)

    def cleanup(*args):
        """
        cleanup(self)

        clean up your kernel

        base method only removes lhs and rhs overload to add further cleanup
        but make sure CKernel::cleanup() is called 
        """
        return _Kernel.Kernel_cleanup(*args)

    def load(*args):
        """
        load(self, fname) -> bool

        load the kernel matrix

        Parameters:
        -----------

        fname:  filename to load from

        if loading was successful 
        """
        return _Kernel.Kernel_load(*args)

    def save(*args):
        """
        save(self, fname) -> bool

        save kernel matrix

        Parameters:
        -----------

        fname:  filename to save to

        if saving was successful 
        """
        return _Kernel.Kernel_save(*args)

    def get_lhs(*args):
        """
        get_lhs(self) -> Features

        get left-hand side of features used in kernel

        features of left-hand side 
        """
        return _Kernel.Kernel_get_lhs(*args)

    def get_rhs(*args):
        """
        get_rhs(self) -> Features

        get right-hand side of features used in kernel

        features of right-hand side 
        """
        return _Kernel.Kernel_get_rhs(*args)

    def get_num_vec_lhs(*args):
        """
        get_num_vec_lhs(self) ->  int

        get number of vectors of lhs features

        number of vectors of left-hand side 
        """
        return _Kernel.Kernel_get_num_vec_lhs(*args)

    def get_num_vec_rhs(*args):
        """
        get_num_vec_rhs(self) ->  int

        get number of vectors of rhs features

        number of vectors of right-hand side 
        """
        return _Kernel.Kernel_get_num_vec_rhs(*args)

    def has_features(*args):
        """
        has_features(self) -> bool

        test whether features have been assigned to lhs and rhs

        true if features are assigned 
        """
        return _Kernel.Kernel_has_features(*args)

    def lhs_equals_rhs(*args):
        """
        lhs_equals_rhs(self) -> bool

        test whether features on lhs and rhs are the same

        true if features are the same 
        """
        return _Kernel.Kernel_lhs_equals_rhs(*args)

    def remove_lhs_and_rhs(*args):
        """
        remove_lhs_and_rhs(self)

        remove lhs and rhs from kernel 
        """
        return _Kernel.Kernel_remove_lhs_and_rhs(*args)

    def remove_lhs(*args):
        """
        remove_lhs(self)

        remove lhs from kernel 
        """
        return _Kernel.Kernel_remove_lhs(*args)

    def remove_rhs(*args):
        """
        remove_rhs(self)

        remove rhs from kernel 
        """
        return _Kernel.Kernel_remove_rhs(*args)

    def get_kernel_type(*args):
        """
        get_kernel_type(self) -> EKernelType

        return what type of kernel we are, e.g. Linear,Polynomial,
        Gaussian,...

        abstract base method

        kernel type 
        """
        return _Kernel.Kernel_get_kernel_type(*args)

    def get_feature_type(*args):
        """
        get_feature_type(self) -> EFeatureType

        return feature type the kernel can deal with

        abstract base method

        feature type 
        """
        return _Kernel.Kernel_get_feature_type(*args)

    def get_feature_class(*args):
        """
        get_feature_class(self) -> EFeatureClass

        return feature class the kernel can deal with

        abstract base method

        feature class 
        """
        return _Kernel.Kernel_get_feature_class(*args)

    def set_cache_size(*args):
        """
        set_cache_size(self, size)

        set the size of the kernel cache

        Parameters:
        -----------

        size:  of kernel cache 
        """
        return _Kernel.Kernel_set_cache_size(*args)

    def get_cache_size(*args):
        """
        get_cache_size(self) ->  int

        return the size of the kernel cache

        size of kernel cache 
        """
        return _Kernel.Kernel_get_cache_size(*args)

    def cache_reset(*args):
        """cache_reset(self)"""
        return _Kernel.Kernel_cache_reset(*args)

    def get_max_elems_cache(*args):
        """get_max_elems_cache(self) ->  int"""
        return _Kernel.Kernel_get_max_elems_cache(*args)

    def get_activenum_cache(*args):
        """get_activenum_cache(self) ->  int"""
        return _Kernel.Kernel_get_activenum_cache(*args)

    def get_kernel_row(*args):
        """
        get_kernel_row(self, docnum, active2dnum, buffer, full_line=False)
        get_kernel_row(self, docnum, active2dnum, buffer)
        """
        return _Kernel.Kernel_get_kernel_row(*args)

    def cache_kernel_row(*args):
        """cache_kernel_row(self, x)"""
        return _Kernel.Kernel_cache_kernel_row(*args)

    def cache_multiple_kernel_rows(*args):
        """cache_multiple_kernel_rows(self, key, varnum)"""
        return _Kernel.Kernel_cache_multiple_kernel_rows(*args)

    def kernel_cache_reset_lru(*args):
        """kernel_cache_reset_lru(self)"""
        return _Kernel.Kernel_kernel_cache_reset_lru(*args)

    def kernel_cache_shrink(*args):
        """kernel_cache_shrink(self, totdoc, num_shrink, after)"""
        return _Kernel.Kernel_kernel_cache_shrink(*args)

    def resize_kernel_cache(*args):
        """
        resize_kernel_cache(self, size, regression_hack=False)
        resize_kernel_cache(self, size)
        """
        return _Kernel.Kernel_resize_kernel_cache(*args)

    def set_time(*args):
        """set_time(self, t)"""
        return _Kernel.Kernel_set_time(*args)

    def kernel_cache_touch(*args):
        """kernel_cache_touch(self, cacheidx) ->  int"""
        return _Kernel.Kernel_kernel_cache_touch(*args)

    def kernel_cache_check(*args):
        """kernel_cache_check(self, cacheidx) ->  int"""
        return _Kernel.Kernel_kernel_cache_check(*args)

    def kernel_cache_space_available(*args):
        """kernel_cache_space_available(self) ->  int"""
        return _Kernel.Kernel_kernel_cache_space_available(*args)

    def kernel_cache_init(*args):
        """
        kernel_cache_init(self, size, regression_hack=False)
        kernel_cache_init(self, size)
        """
        return _Kernel.Kernel_kernel_cache_init(*args)

    def kernel_cache_cleanup(*args):
        """kernel_cache_cleanup(self)"""
        return _Kernel.Kernel_kernel_cache_cleanup(*args)

    def list_kernel(*args):
        """
        list_kernel(self)

        list kernel 
        """
        return _Kernel.Kernel_list_kernel(*args)

    def has_property(*args):
        """
        has_property(self, p) -> bool

        check if kernel has given property

        Parameters:
        -----------

        p:  kernel property

        if kernel has given property 
        """
        return _Kernel.Kernel_has_property(*args)

    def clear_normal(*args):
        """
        clear_normal(self)

        for optimizable kernels, i.e. kernels where the weight vector can be
        computed explicitly (if it fits into memory) 
        """
        return _Kernel.Kernel_clear_normal(*args)

    def add_to_normal(*args):
        """
        add_to_normal(self, vector_idx, weight)

        add vector*factor to 'virtual' normal vector

        Parameters:
        -----------

        vector_idx:  index

        weight:  weight 
        """
        return _Kernel.Kernel_add_to_normal(*args)

    def get_optimization_type(*args):
        """
        get_optimization_type(self) -> EOptimizationType

        get optimization type

        optimization type 
        """
        return _Kernel.Kernel_get_optimization_type(*args)

    def set_optimization_type(*args):
        """
        set_optimization_type(self, t)

        set optimization type

        Parameters:
        -----------

        t:  optimization type to set 
        """
        return _Kernel.Kernel_set_optimization_type(*args)

    def get_is_initialized(*args):
        """
        get_is_initialized(self) -> bool

        check if optimization is initialized

        if optimization is initialized 
        """
        return _Kernel.Kernel_get_is_initialized(*args)

    def init_optimization(*args):
        """
        init_optimization(self, count, IDX, weights) -> bool

        initialize optimization

        Parameters:
        -----------

        count:  count

        IDX:  index

        weights:  weights

        if initializing was successful 
        """
        return _Kernel.Kernel_init_optimization(*args)

    def delete_optimization(*args):
        """
        delete_optimization(self) -> bool

        delete optimization

        if deleting was successful 
        """
        return _Kernel.Kernel_delete_optimization(*args)

    def init_optimization_svm(*args):
        """
        init_optimization_svm(self, svm) -> bool

        initialize optimization

        Parameters:
        -----------

        svm:  svm model

        if initializing was successful 
        """
        return _Kernel.Kernel_init_optimization_svm(*args)

    def compute_optimized(*args):
        """
        compute_optimized(self, vector_idx) -> float

        compute optimized

        Parameters:
        -----------

        vector_idx:  index to compute

        optimized value at given index 
        """
        return _Kernel.Kernel_compute_optimized(*args)

    def compute_batch(*args):
        """
        compute_batch(self, num_vec, vec_idx, target, num_suppvec, IDX, alphas, 
            factor=1.0)
        compute_batch(self, num_vec, vec_idx, target, num_suppvec, IDX, alphas)

        computes output for a batch of examples in an optimized fashion
        (favorable if kernel supports it, i.e. has KP_BATCHEVALUATION. to the
        outputvector target (of length num_vec elements) the output for the
        examples enumerated in vec_idx are added. therefore make sure that it
        is initialized with ZERO. the following num_suppvec, IDX, alphas
        arguments are the number of support vectors, their indices and weights

        """
        return _Kernel.Kernel_compute_batch(*args)

    def get_combined_kernel_weight(*args):
        """
        get_combined_kernel_weight(self) -> float

        get combined kernel weight

        combined kernel weight 
        """
        return _Kernel.Kernel_get_combined_kernel_weight(*args)

    def set_combined_kernel_weight(*args):
        """
        set_combined_kernel_weight(self, nw)

        set combined kernel weight

        Parameters:
        -----------

        nw:  new combined kernel weight 
        """
        return _Kernel.Kernel_set_combined_kernel_weight(*args)

    def get_num_subkernels(*args):
        """
        get_num_subkernels(self) ->  int

        get number of subkernels

        number of subkernels 
        """
        return _Kernel.Kernel_get_num_subkernels(*args)

    def compute_by_subkernel(*args):
        """
        compute_by_subkernel(self, vector_idx, subkernel_contrib)

        compute by subkernel

        Parameters:
        -----------

        vector_idx:  index

        subkernel_contrib:  subkernel contribution 
        """
        return _Kernel.Kernel_compute_by_subkernel(*args)

    def get_subkernel_weights(*args):
        """
        get_subkernel_weights(self, num_weights) -> float

        get subkernel weights

        Parameters:
        -----------

        num_weights:  number of weights will be stored here

        subkernel weights 
        """
        return _Kernel.Kernel_get_subkernel_weights(*args)

    def set_subkernel_weights(*args):
        """
        set_subkernel_weights(self, weights, num_weights)

        set subkernel weights

        Parameters:
        -----------

        weights:  subkernel weights

        num_weights:  number of weights 
        """
        return _Kernel.Kernel_set_subkernel_weights(*args)

Kernel_swigregister = _Kernel.Kernel_swigregister
Kernel_swigregister(Kernel)

class RealKernel(Kernel):
    """
    Template class SimpleKernel is the base class for kernels working on
    Simple features.

    CSimpleFeatures are dense Matrix like Features and Kernels operating
    on them all derive from this class (cf., e.g., CGaussianKernel)

    C++ includes: SimpleKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RealKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RealKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_RealKernel
    __del__ = lambda self : None;
RealKernel_swigregister = _Kernel.RealKernel_swigregister
RealKernel_swigregister(RealKernel)

class ShortRealKernel(Kernel):
    """
    Template class SimpleKernel is the base class for kernels working on
    Simple features.

    CSimpleFeatures are dense Matrix like Features and Kernels operating
    on them all derive from this class (cf., e.g., CGaussianKernel)

    C++ includes: SimpleKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShortRealKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShortRealKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_ShortRealKernel
    __del__ = lambda self : None;
ShortRealKernel_swigregister = _Kernel.ShortRealKernel_swigregister
ShortRealKernel_swigregister(ShortRealKernel)

class WordKernel(Kernel):
    """
    Template class SimpleKernel is the base class for kernels working on
    Simple features.

    CSimpleFeatures are dense Matrix like Features and Kernels operating
    on them all derive from this class (cf., e.g., CGaussianKernel)

    C++ includes: SimpleKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WordKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WordKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_WordKernel
    __del__ = lambda self : None;
WordKernel_swigregister = _Kernel.WordKernel_swigregister
WordKernel_swigregister(WordKernel)

class CharKernel(Kernel):
    """
    Template class SimpleKernel is the base class for kernels working on
    Simple features.

    CSimpleFeatures are dense Matrix like Features and Kernels operating
    on them all derive from this class (cf., e.g., CGaussianKernel)

    C++ includes: SimpleKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CharKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CharKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_CharKernel
    __del__ = lambda self : None;
CharKernel_swigregister = _Kernel.CharKernel_swigregister
CharKernel_swigregister(CharKernel)

class ByteKernel(Kernel):
    """
    Template class SimpleKernel is the base class for kernels working on
    Simple features.

    CSimpleFeatures are dense Matrix like Features and Kernels operating
    on them all derive from this class (cf., e.g., CGaussianKernel)

    C++ includes: SimpleKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_ByteKernel
    __del__ = lambda self : None;
ByteKernel_swigregister = _Kernel.ByteKernel_swigregister
ByteKernel_swigregister(ByteKernel)

class IntKernel(Kernel):
    """
    Template class SimpleKernel is the base class for kernels working on
    Simple features.

    CSimpleFeatures are dense Matrix like Features and Kernels operating
    on them all derive from this class (cf., e.g., CGaussianKernel)

    C++ includes: SimpleKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_IntKernel
    __del__ = lambda self : None;
IntKernel_swigregister = _Kernel.IntKernel_swigregister
IntKernel_swigregister(IntKernel)

class ShortKernel(Kernel):
    """
    Template class SimpleKernel is the base class for kernels working on
    Simple features.

    CSimpleFeatures are dense Matrix like Features and Kernels operating
    on them all derive from this class (cf., e.g., CGaussianKernel)

    C++ includes: SimpleKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShortKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShortKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_ShortKernel
    __del__ = lambda self : None;
ShortKernel_swigregister = _Kernel.ShortKernel_swigregister
ShortKernel_swigregister(ShortKernel)

class UlongKernel(Kernel):
    """
    Template class SimpleKernel is the base class for kernels working on
    Simple features.

    CSimpleFeatures are dense Matrix like Features and Kernels operating
    on them all derive from this class (cf., e.g., CGaussianKernel)

    C++ includes: SimpleKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UlongKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, UlongKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_UlongKernel
    __del__ = lambda self : None;
UlongKernel_swigregister = _Kernel.UlongKernel_swigregister
UlongKernel_swigregister(UlongKernel)

class SparseRealKernel(Kernel):
    """
    Template class SparseKernel, is the base class of kernels working on
    sparse features.

    See e.g. the CSparseGaussianKernel for an example.

    C++ includes: SparseKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SparseRealKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SparseRealKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_SparseRealKernel
    __del__ = lambda self : None;
SparseRealKernel_swigregister = _Kernel.SparseRealKernel_swigregister
SparseRealKernel_swigregister(SparseRealKernel)

class SparseWordKernel(Kernel):
    """
    Template class SparseKernel, is the base class of kernels working on
    sparse features.

    See e.g. the CSparseGaussianKernel for an example.

    C++ includes: SparseKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SparseWordKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SparseWordKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_SparseWordKernel
    __del__ = lambda self : None;
SparseWordKernel_swigregister = _Kernel.SparseWordKernel_swigregister
SparseWordKernel_swigregister(SparseWordKernel)

class StringRealKernel(Kernel):
    """
    Template class StringKernel, is the base class of all String Kernels.

    For a (very complex) example see e.g. CWeightedDegreeStringKernel

    C++ includes: StringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringRealKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StringRealKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_StringRealKernel
    __del__ = lambda self : None;
StringRealKernel_swigregister = _Kernel.StringRealKernel_swigregister
StringRealKernel_swigregister(StringRealKernel)

class StringWordKernel(Kernel):
    """
    Template class StringKernel, is the base class of all String Kernels.

    For a (very complex) example see e.g. CWeightedDegreeStringKernel

    C++ includes: StringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringWordKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StringWordKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_StringWordKernel
    __del__ = lambda self : None;
StringWordKernel_swigregister = _Kernel.StringWordKernel_swigregister
StringWordKernel_swigregister(StringWordKernel)

class StringCharKernel(Kernel):
    """
    Template class StringKernel, is the base class of all String Kernels.

    For a (very complex) example see e.g. CWeightedDegreeStringKernel

    C++ includes: StringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringCharKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StringCharKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_StringCharKernel
    __del__ = lambda self : None;
StringCharKernel_swigregister = _Kernel.StringCharKernel_swigregister
StringCharKernel_swigregister(StringCharKernel)

class StringIntKernel(Kernel):
    """
    Template class StringKernel, is the base class of all String Kernels.

    For a (very complex) example see e.g. CWeightedDegreeStringKernel

    C++ includes: StringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringIntKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StringIntKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_StringIntKernel
    __del__ = lambda self : None;
StringIntKernel_swigregister = _Kernel.StringIntKernel_swigregister
StringIntKernel_swigregister(StringIntKernel)

class StringUlongKernel(Kernel):
    """
    Template class StringKernel, is the base class of all String Kernels.

    For a (very complex) example see e.g. CWeightedDegreeStringKernel

    C++ includes: StringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringUlongKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StringUlongKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_StringUlongKernel
    __del__ = lambda self : None;
StringUlongKernel_swigregister = _Kernel.StringUlongKernel_swigregister
StringUlongKernel_swigregister(StringUlongKernel)

class StringShortKernel(Kernel):
    """
    Template class StringKernel, is the base class of all String Kernels.

    For a (very complex) example see e.g. CWeightedDegreeStringKernel

    C++ includes: StringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringShortKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StringShortKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_StringShortKernel
    __del__ = lambda self : None;
StringShortKernel_swigregister = _Kernel.StringShortKernel_swigregister
StringShortKernel_swigregister(StringShortKernel)

class StringByteKernel(Kernel):
    """
    Template class StringKernel, is the base class of all String Kernels.

    For a (very complex) example see e.g. CWeightedDegreeStringKernel

    C++ includes: StringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringByteKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, StringByteKernel, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_StringByteKernel
    __del__ = lambda self : None;
StringByteKernel_swigregister = _Kernel.StringByteKernel_swigregister
StringByteKernel_swigregister(StringByteKernel)

class KernelNormalizer(SGObject):
    """
    The class Kernel Normalizer defines a function to postprocess kernel
    values.

    Formally it defines f(.,.,.)

    \\[ k'({\\bf x},{\\bf x'}) = f(k({\\bf x},{\\bf x'}),{\\bf
    x},{\\bf x'}) \\]

    examples for f(.,.,.) would be scaling with a constant

    \\[ f(k({\\bf x},{\\bf x'}), ., .)= \\frac{1}{c}\\cdot
    k({\\bf x},{\\bf x'}) \\]

    as can be found in class CAvgDiagKernelNormalizer, the identity (cf.
    CIdentityKernelNormalizer), dividing by the Square Root of the product
    of the diagonal elements which effectively normalizes the vectors in
    feature space to norm 1 (see CSqrtDiagKernelNormalizer)

    \\[ k'({\\bf x},{\\bf x'}) = \\frac{k({\\bf x},{\\bf
    x'})}{\\sqrt{k({\\bf x},{\\bf x})k({\\bf x'},{\\bf x'})}}
    \\]

    C++ includes: KernelNormalizer.h 
    """
    __swig_setmethods__ = {}
    for _s in [SGObject]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, KernelNormalizer, name, value)
    __swig_getmethods__ = {}
    for _s in [SGObject]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, KernelNormalizer, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_KernelNormalizer
    __del__ = lambda self : None;
    def init(*args):
        """
        init(self, k) -> bool

        initialization of the normalizer (if needed)

        Parameters:
        -----------

        k:  kernel 
        """
        return _Kernel.KernelNormalizer_init(*args)

    def normalize(*args):
        """
        normalize(self, value, idx_lhs, idx_rhs) -> float

        normalize the kernel value

        Parameters:
        -----------

        value:  kernel value

        idx_lhs:  index of left hand side vector

        idx_rhs:  index of right hand side vector 
        """
        return _Kernel.KernelNormalizer_normalize(*args)

    def normalize_lhs(*args):
        """
        normalize_lhs(self, value, idx_lhs) -> float

        normalize only the left hand side vector

        Parameters:
        -----------

        value:  value of a component of the left hand side feature vector

        idx_lhs:  index of left hand side vector 
        """
        return _Kernel.KernelNormalizer_normalize_lhs(*args)

    def normalize_rhs(*args):
        """
        normalize_rhs(self, value, idx_rhs) -> float

        normalize only the right hand side vector

        Parameters:
        -----------

        value:  value of a component of the right hand side feature vector

        idx_rhs:  index of right hand side vector 
        """
        return _Kernel.KernelNormalizer_normalize_rhs(*args)

KernelNormalizer_swigregister = _Kernel.KernelNormalizer_swigregister
KernelNormalizer_swigregister(KernelNormalizer)

class PyramidChi2(RealKernel):
    """
    Pyramid Kernel over Chi2 matched histograms.

    The Pyramid Chi2 Kernel often used in image classification with sum
    inside the exponential. TODO: add adaptive width computation via
    median

    C++ includes: PyramidChi2.h 
    """
    __swig_setmethods__ = {}
    for _s in [RealKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyramidChi2, name, value)
    __swig_getmethods__ = {}
    for _s in [RealKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PyramidChi2, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, num_cells2, weights_foreach_cell2, width_computation_type2, 
            width2) -> PyramidChi2
        __init__(self, l, r, size, num_cells2, weights_foreach_cell2, width_computation_type2, 
            width2) -> PyramidChi2

        constructor

        Parameters:
        -----------

        l:  features lhs convention: concatenated features along all cells,
        i.e. [feature for cell1, feature for cell2, ... feature for last cell]
        , the dimensionality of the base feature is equal to dividing the
        total feature length by the number ofcells

        r:  features rhs the same convention as for param l applies here

        size:  size

        num_cells2:  - the number of pyramid cells

        weights_foreach_cell2:  the vector of weights for each cell with which
        the Chi2 distance gets weighted

        width_computation_type:  - 0 use the following parameter as fixed
        width, 1- use mean of inner distances in case 1 the value of parameter
        width is important!!!

        width2:  - in case of width_computation_type ==0 it is the width, in
        case of width_computation_type > 0 its value determines the how many
        random features are used for determining the width in case of
        width_computation_type > 0 set width2 <=1 to use all LEFT HAND SIDE
        features for width estimation 
        """
        this = _Kernel.new_PyramidChi2(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_PyramidChi2
    __del__ = lambda self : None;
PyramidChi2_swigregister = _Kernel.PyramidChi2_swigregister
PyramidChi2_swigregister(PyramidChi2)

class AUCKernel(WordKernel):
    """
    The AUC kernel can be used to maximize the area under the receiver
    operator stracteristic curve (AUC) instead of margin in SVM training.

    It takes as argument a sub-kernel and Labels based on which number of
    positive labels times number of negative labels many ``virtual''
    examples are created that ensure that all positive examples get a
    higher score than all negative examples in training.

    C++ includes: AUCKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [WordKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AUCKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [WordKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AUCKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, subkernel) -> AUCKernel

        constructor

        Parameters:
        -----------

        size:  cache size

        subkernel:  the subkernel 
        """
        this = _Kernel.new_AUCKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_AUCKernel
    __del__ = lambda self : None;
    def setup_auc_maximization(*args):
        """
        setup_auc_maximization(self, labels) -> CLabels

        initialize kernel based on current labeling and subkernel

        Parameters:
        -----------

        labels:  - current labeling

        new label object to be used together with this kernel in SVM training
        for AUC maximization 
        """
        return _Kernel.AUCKernel_setup_auc_maximization(*args)

AUCKernel_swigregister = _Kernel.AUCKernel_swigregister
AUCKernel_swigregister(AUCKernel)

class AvgDiagKernelNormalizer(KernelNormalizer):
    """
    Normalize the kernel by either a constant or the average value of the
    diagonal elements (depending on argument c of the constructor).

    In case c <= 0 compute scale as \\[ \\mbox{scale} =
    \\frac{1}{N}\\sum_{i=1}^N k(x_i,x_i) \\]

    otherwise use scale=c and normalize the kernel via

    \\[ k'(x,x')= \\frac{k(x,x')}{scale} \\]

    C++ includes: AvgDiagKernelNormalizer.h 
    """
    __swig_setmethods__ = {}
    for _s in [KernelNormalizer]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AvgDiagKernelNormalizer, name, value)
    __swig_getmethods__ = {}
    for _s in [KernelNormalizer]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, AvgDiagKernelNormalizer, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, c=0.0) -> AvgDiagKernelNormalizer
        __init__(self) -> AvgDiagKernelNormalizer

        constructor

        Parameters:
        -----------

        c:  scale parameter, if <= 0 scaling will be computed from the avg of
        the kernel diagonal elements 
        """
        this = _Kernel.new_AvgDiagKernelNormalizer(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_AvgDiagKernelNormalizer
    __del__ = lambda self : None;
AvgDiagKernelNormalizer_swigregister = _Kernel.AvgDiagKernelNormalizer_swigregister
AvgDiagKernelNormalizer_swigregister(AvgDiagKernelNormalizer)

class RidgeKernelNormalizer(KernelNormalizer):
    """
    Normalize the kernel by adding a constant term to its diagonal. This
    aids kernels to become positive definite (even though they are not -
    often caused by numerical problems).

    Formally,

    \\[ k'(x,x')= \\frac{k(x,x')}+ R\\cdot {\\bf E} \\]

    where E is a matrix with ones on the diagonal and R is the scalar
    ridge term. The ridge term R is computed as $R=r\\dot c$.

    Typically,

    r=1e-10 and c=0.0 will add mean(diag(K))*1e-10 to the diagonal

    r=0.1 and c=1 will add 0.1 to the diagonal

    In case c <= 0, c is compute as the mean of the kernel diagonal \\[
    \\mbox{c} = \\frac{1}{N}\\sum_{i=1}^N k(x_i,x_i) \\]

    C++ includes: RidgeKernelNormalizer.h 
    """
    __swig_setmethods__ = {}
    for _s in [KernelNormalizer]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RidgeKernelNormalizer, name, value)
    __swig_getmethods__ = {}
    for _s in [KernelNormalizer]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RidgeKernelNormalizer, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, r=1e-10, c=0.0) -> RidgeKernelNormalizer
        __init__(self, r=1e-10) -> RidgeKernelNormalizer
        __init__(self) -> RidgeKernelNormalizer

        constructor

        Parameters:
        -----------

        r:  ridge parameter

        c:  scale parameter, if <= 0 scaling will be computed from the avg of
        the kernel diagonal elements

        the scalar r*c will be added to the kernel diagonal, typical use
        cases: r=1e-10 and c=0.0 will add mean(diag(K))*1e-10 to the diagonal

        r=0.1 and c=1 will add 0.1 to the diagonal 
        """
        this = _Kernel.new_RidgeKernelNormalizer(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_RidgeKernelNormalizer
    __del__ = lambda self : None;
RidgeKernelNormalizer_swigregister = _Kernel.RidgeKernelNormalizer_swigregister
RidgeKernelNormalizer_swigregister(RidgeKernelNormalizer)

class Chi2Kernel(RealKernel):
    """
    The Chi2 kernel operating on realvalued vectors computes the chi-
    squared distance between sets of histograms.

    It is a very useful distance in image recognition (used to detect
    objects).

    It is defined as \\[ k({\\bf x},({\\bf x'})=
    e^{-\\frac{1}{width}
    \\sum_{i=0}^{l}\\frac{(x_i-x'_i)^2}{(x_i+x'_i)}} \\]

    C++ includes: Chi2Kernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [RealKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Chi2Kernel, name, value)
    __swig_getmethods__ = {}
    for _s in [RealKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Chi2Kernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, width) -> Chi2Kernel
        __init__(self, l, r, width, size) -> Chi2Kernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        width:  width

        size:  cache size 
        """
        this = _Kernel.new_Chi2Kernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_Chi2Kernel
    __del__ = lambda self : None;
Chi2Kernel_swigregister = _Kernel.Chi2Kernel_swigregister
Chi2Kernel_swigregister(Chi2Kernel)

class CombinedKernel(Kernel):
    """
    The Combined kernel is used to combine a number of kernels into a
    single CombinedKernel object by linear combination.

    It keeps pointers to the added sub-kernels $k_m({\\bf x}, {\\bf
    x'})$ and for each sub-kernel - a kernel specific weight $\\beta_m$.

    It is especially useful to combine kernels working on different
    domains and to combine kernels looking at independent features and
    requires CCombinedFeatures to be used.

    It is defined as:

    \\[ k_{combined}({\\bf x}, {\\bf x'}) = \\sum_{m=1}^M
    \\beta_m k_m({\\bf x}, {\\bf x'}) \\]

    C++ includes: CombinedKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CombinedKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CombinedKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size=10, append_subkernel_weights=False) -> CombinedKernel
        __init__(self, size=10) -> CombinedKernel
        __init__(self) -> CombinedKernel

        constructor

        Parameters:
        -----------

        size:  cache size

        append_subkernel_weights:  if subkernel weights shall be appended 
        """
        this = _Kernel.new_CombinedKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_CombinedKernel
    __del__ = lambda self : None;
    def list_kernels(*args):
        """
        list_kernels(self)

        list kernels 
        """
        return _Kernel.CombinedKernel_list_kernels(*args)

    def get_first_kernel(*args):
        """
        get_first_kernel(self) -> Kernel
        get_first_kernel(self, current) -> Kernel

        get first kernel

        Parameters:
        -----------

        current:

        first kernel 
        """
        return _Kernel.CombinedKernel_get_first_kernel(*args)

    def get_kernel(*args):
        """
        get_kernel(self, idx) -> Kernel

        get kernel

        Parameters:
        -----------

        idx:  index of kernel

        kernel at index idx 
        """
        return _Kernel.CombinedKernel_get_kernel(*args)

    def get_last_kernel(*args):
        """
        get_last_kernel(self) -> Kernel

        get last kernel

        last kernel 
        """
        return _Kernel.CombinedKernel_get_last_kernel(*args)

    def get_next_kernel(*args):
        """
        get_next_kernel(self) -> Kernel
        get_next_kernel(self, current) -> Kernel

        get next kernel multi-thread safe

        Parameters:
        -----------

        current:

        next kernel 
        """
        return _Kernel.CombinedKernel_get_next_kernel(*args)

    def insert_kernel(*args):
        """
        insert_kernel(self, k) -> bool

        insert kernel

        Parameters:
        -----------

        k:  kernel

        if inserting was successful 
        """
        return _Kernel.CombinedKernel_insert_kernel(*args)

    def append_kernel(*args):
        """
        append_kernel(self, k) -> bool

        append kernel

        Parameters:
        -----------

        k:  kernel

        if appending was successful 
        """
        return _Kernel.CombinedKernel_append_kernel(*args)

    def delete_kernel(*args):
        """
        delete_kernel(self) -> bool

        delete kernel

        if deleting was successful 
        """
        return _Kernel.CombinedKernel_delete_kernel(*args)

    def get_append_subkernel_weights(*args):
        """
        get_append_subkernel_weights(self) -> bool

        check if subkernel weights are appended

        if subkernel weigths are appended 
        """
        return _Kernel.CombinedKernel_get_append_subkernel_weights(*args)

    def compute_batch(*args):
        """
        compute_batch(self, num_vec, vec_idx, target, num_suppvec, IDX, alphas, 
            factor=1.0)
        compute_batch(self, num_vec, vec_idx, target, num_suppvec, IDX, alphas)

        computes output for a batch of examples in an optimized fashion
        (favorable if kernel supports it, i.e. has KP_BATCHEVALUATION. to the
        outputvector target (of length num_vec elements) the output for the
        examples enumerated in vec_idx are added. therefore make sure that it
        is initialized with ZERO. the following num_suppvec, IDX, alphas
        arguments are the number of support vectors, their indices and weights

        """
        return _Kernel.CombinedKernel_compute_batch(*args)

    def compute_optimized_kernel_helper(*args):
        """compute_optimized_kernel_helper(p) -> void"""
        return _Kernel.CombinedKernel_compute_optimized_kernel_helper(*args)

    if _newclass:compute_optimized_kernel_helper = staticmethod(compute_optimized_kernel_helper)
    __swig_getmethods__["compute_optimized_kernel_helper"] = lambda x: compute_optimized_kernel_helper
    def compute_kernel_helper(*args):
        """compute_kernel_helper(p) -> void"""
        return _Kernel.CombinedKernel_compute_kernel_helper(*args)

    if _newclass:compute_kernel_helper = staticmethod(compute_kernel_helper)
    __swig_getmethods__["compute_kernel_helper"] = lambda x: compute_kernel_helper
    def emulate_compute_batch(*args):
        """
        emulate_compute_batch(self, k, num_vec, vec_idx, target, num_suppvec, IDX, weights)

        emulates batch computation, via linadd optimization w^t x or even down
        to sum_i alpha_i K(x_i,x)

        Parameters:
        -----------

        k:  kernel

        num_vec:  number of vectors

        vec_idx:  vector index

        target:  target

        num_suppvec:  number of support vectors

        IDX:  IDX

        weights:  weights 
        """
        return _Kernel.CombinedKernel_emulate_compute_batch(*args)

    def get_subkernel_weights(*args):
        """
        get_subkernel_weights(self, num_weights) -> float
        get_subkernel_weights(self, weights)

        get subkernel weights (swig compatible)

        Parameters:
        -----------

        weights:  subkernel weights

        num_weights:  number of weights 
        """
        return _Kernel.CombinedKernel_get_subkernel_weights(*args)

    def precompute_subkernels(*args):
        """
        precompute_subkernels(self) -> bool

        precompute all sub-kernels 
        """
        return _Kernel.CombinedKernel_precompute_subkernels(*args)

CombinedKernel_swigregister = _Kernel.CombinedKernel_swigregister
CombinedKernel_swigregister(CombinedKernel)

def CombinedKernel_compute_optimized_kernel_helper(*args):
  """CombinedKernel_compute_optimized_kernel_helper(p) -> void"""
  return _Kernel.CombinedKernel_compute_optimized_kernel_helper(*args)

def CombinedKernel_compute_kernel_helper(*args):
  """CombinedKernel_compute_kernel_helper(p) -> void"""
  return _Kernel.CombinedKernel_compute_kernel_helper(*args)

class CommUlongStringKernel(StringUlongKernel):
    """
    The CommUlongString kernel may be used to compute the spectrum kernel
    from strings that have been mapped into unsigned 64bit integers.

    These 64bit integers correspond to k-mers. To be applicable in this
    kernel they need to be sorted (e.g. via the SortUlongString pre-
    processor).

    It basically uses the algorithm in the unix "comm" command (hence
    the name) to compute:

    \\[ k({\\bf x},({\\bf x'})= \\Phi_k({\\bf x})\\cdot
    \\Phi_k({\\bf x'}) \\]

    where $\\Phi_k$ maps a sequence ${\\bf x}$ that consists of
    letters in $\\Sigma$ to a feature vector of size $|\\Sigma|^k$. In
    this feature vector each entry denotes how often the k-mer appears in
    that ${\\bf x}$.

    Note that this representation enables spectrum kernels of order 8 for
    8bit alphabets (like binaries) and order 32 for 2-bit alphabets like
    DNA.

    For this kernel the linadd speedups are implemented (though there is
    room for improvement here when a whole set of sequences is ADDed)
    using sorted lists.

    C++ includes: CommUlongStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringUlongKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommUlongStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringUlongKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CommUlongStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size=10, use_sign=False) -> CommUlongStringKernel
        __init__(self, size=10) -> CommUlongStringKernel
        __init__(self) -> CommUlongStringKernel
        __init__(self, l, r, use_sign=False, size=10) -> CommUlongStringKernel
        __init__(self, l, r, use_sign=False) -> CommUlongStringKernel
        __init__(self, l, r) -> CommUlongStringKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        use_sign:  if sign shall be used

        size:  cache size 
        """
        this = _Kernel.new_CommUlongStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_CommUlongStringKernel
    __del__ = lambda self : None;
    def merge_dictionaries(*args):
        """
        merge_dictionaries(self, t, j, k, vec, dic, dic_weights, weight, vec_idx)

        merge dictionaries

        Parameters:
        -----------

        t:  t

        j:  j

        k:  k

        vec:  vector

        dic:  dictionary

        dic_weights:  dictionary weights

        weight:  weight

        vec_idx:  vector index 
        """
        return _Kernel.CommUlongStringKernel_merge_dictionaries(*args)

    def get_dictionary(*args):
        """
        get_dictionary(self, dsize, dict, dweights)

        get dictionary

        Parameters:
        -----------

        dsize:  dictionary size will be stored in here

        dict:  dictionary will be stored in here

        dweights:  dictionary weights will be stored in here 
        """
        return _Kernel.CommUlongStringKernel_get_dictionary(*args)

CommUlongStringKernel_swigregister = _Kernel.CommUlongStringKernel_swigregister
CommUlongStringKernel_swigregister(CommUlongStringKernel)

class CommWordStringKernel(StringWordKernel):
    """
    The CommWordString kernel may be used to compute the spectrum kernel
    from strings that have been mapped into unsigned 16bit integers.

    These 16bit integers correspond to k-mers. To applicable in this
    kernel they need to be sorted (e.g. via the SortWordString pre-
    processor).

    It basically uses the algorithm in the unix "comm" command (hence
    the name) to compute:

    \\[ k({\\bf x},({\\bf x'})= \\Phi_k({\\bf x})\\cdot
    \\Phi_k({\\bf x'}) \\]

    where $\\Phi_k$ maps a sequence ${\\bf x}$ that consists of
    letters in $\\Sigma$ to a feature vector of size $|\\Sigma|^k$. In
    this feature vector each entry denotes how often the k-mer appears in
    that ${\\bf x}$.

    Note that this representation is especially tuned to small alphabets
    (like the 2-bit alphabet DNA), for which it enables spectrum kernels
    of order up to 8.

    For this kernel the linadd speedups are quite efficiently implemented
    using direct maps.

    C++ includes: CommWordStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringWordKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CommWordStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringWordKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CommWordStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, use_sign) -> CommWordStringKernel
        __init__(self, l, r, use_sign=False, size=10) -> CommWordStringKernel
        __init__(self, l, r, use_sign=False) -> CommWordStringKernel
        __init__(self, l, r) -> CommWordStringKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        use_sign:  if sign shall be used

        size:  cache size 
        """
        this = _Kernel.new_CommWordStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_CommWordStringKernel
    __del__ = lambda self : None;
    def init_dictionary(*args):
        """
        init_dictionary(self, size) -> bool

        initialize dictionary

        Parameters:
        -----------

        size:  size 
        """
        return _Kernel.CommWordStringKernel_init_dictionary(*args)

    def get_dictionary(*args):
        """
        get_dictionary(self, dsize, dweights)

        get dictionary

        Parameters:
        -----------

        dsize:  dictionary size will be stored in here

        dweights:  dictionary weights will be stored in here 
        """
        return _Kernel.CommWordStringKernel_get_dictionary(*args)

    def compute_scoring(*args):
        """
        compute_scoring(self, max_degree, num_feat, num_sym, target, num_suppvec, 
            IDX, alphas, do_init=True) -> float
        compute_scoring(self, max_degree, num_feat, num_sym, target, num_suppvec, 
            IDX, alphas) -> float

        compute scoring

        Parameters:
        -----------

        max_degree:  maximum degree

        num_feat:  number of features

        num_sym:  number of symbols

        target:  target

        num_suppvec:  number of support vectors

        IDX:  IDX

        alphas:  alphas

        do_init:  if initialization shall be performed

        computed scores 
        """
        return _Kernel.CommWordStringKernel_compute_scoring(*args)

    def compute_consensus(*args):
        """
        compute_consensus(self, num_feat, num_suppvec, IDX, alphas) -> str

        compute consensus

        Parameters:
        -----------

        num_feat:  number of features

        num_suppvec:  number of support vectors

        IDX:  IDX

        alphas:  alphas

        computed consensus 
        """
        return _Kernel.CommWordStringKernel_compute_consensus(*args)

    def set_use_dict_diagonal_optimization(*args):
        """
        set_use_dict_diagonal_optimization(self, flag)

        set_use_dict_diagonal_optimization

        Parameters:
        -----------

        flag:  enable diagonal optimization 
        """
        return _Kernel.CommWordStringKernel_set_use_dict_diagonal_optimization(*args)

    def get_use_dict_diagonal_optimization(*args):
        """
        get_use_dict_diagonal_optimization(self) -> bool

        get.use.dict.diagonal.optimization

        true if diagonal optimization is on 
        """
        return _Kernel.CommWordStringKernel_get_use_dict_diagonal_optimization(*args)

CommWordStringKernel_swigregister = _Kernel.CommWordStringKernel_swigregister
CommWordStringKernel_swigregister(CommWordStringKernel)

class ConstKernel(Kernel):
    """
    The Constant Kernel returns a constant for all elements.

    A ``kernel'' that simply returns a single constant, i.e. $k({\\bf
    x}, {\\bf x'})= c$

    C++ includes: ConstKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConstKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConstKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, c) -> ConstKernel
        __init__(self, l, r, c) -> ConstKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        c:  constant c 
        """
        this = _Kernel.new_ConstKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_ConstKernel
    __del__ = lambda self : None;
ConstKernel_swigregister = _Kernel.ConstKernel_swigregister
ConstKernel_swigregister(ConstKernel)

class CustomKernel(Kernel):
    """
    The Custom Kernelallows for custom user provided kernel matrices.

    For squared training matrices it allows to store only the upper
    triangle of the kernel to save memory: Full symmetric kernel matrices
    can be stored as is or can be internally converted into (or directly
    given in) upper triangle representation. Also note that values are
    stored as 32bit floats.

    C++ includes: CustomKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CustomKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CustomKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> CustomKernel
        __init__(self, k) -> CustomKernel
        __init__(self, km) -> CustomKernel

        constructor

        sets full kernel matrix from full kernel matrix

        Parameters:
        -----------

        km:  kernel matrix

        rows:  number of rows in matrix

        cols:  number of cols in matrix

        if setting was successful 
        """
        this = _Kernel.new_CustomKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_CustomKernel
    __del__ = lambda self : None;
    def dummy_init(*args):
        """
        dummy_init(self, rows, cols) -> bool

        initialize kernel with dummy features

        Kernels always need feature objects assigned. As the custom kernel
        does not really require this it creates some magic dummy features that
        only know about the number of vectors

        Parameters:
        -----------

        rows:  features of left-hand side

        cols:  features of right-hand side

        if initializing was successful 
        """
        return _Kernel.CustomKernel_dummy_init(*args)

    def set_triangle_kernel_matrix_from_triangle(*args):
        """
        set_triangle_kernel_matrix_from_triangle(self, km) -> bool

        set kernel matrix (only elements from upper triangle) from elements of
        upper triangle (concat'd), including the main diagonal

        Parameters:
        -----------

        km:  kernel matrix

        len:  denotes the size of the array and should match
        len=cols*(cols+1)/2

        if setting was successful 
        """
        return _Kernel.CustomKernel_set_triangle_kernel_matrix_from_triangle(*args)

    def set_triangle_kernel_matrix_from_full(*args):
        """
        set_triangle_kernel_matrix_from_full(self, km) -> bool

        set kernel matrix (only elements from upper triangle) from squared
        matrix

        Parameters:
        -----------

        km:  kernel matrix

        rows:  number of rows in matrix

        cols:  number of cols in matrix

        if setting was successful 
        """
        return _Kernel.CustomKernel_set_triangle_kernel_matrix_from_full(*args)

    def set_full_kernel_matrix_from_full(*args):
        """
        set_full_kernel_matrix_from_full(self, km) -> bool

        set full kernel matrix from full kernel matrix

        Parameters:
        -----------

        km:  kernel matrix

        rows:  number of rows in matrix

        cols:  number of cols in matrix

        if setting was successful 
        """
        return _Kernel.CustomKernel_set_full_kernel_matrix_from_full(*args)

CustomKernel_swigregister = _Kernel.CustomKernel_swigregister
CustomKernel_swigregister(CustomKernel)

class DiagKernel(Kernel):
    """
    The Diagonal Kernel returns a constant for the diagonal and zero
    otherwise.

    A kernel that returns zero for all non-diagonal elements and a single
    constant otherwise, i.e. $k({\\bf x_i}, {\\bf x_j})=
    \\delta_{ij} c$

    C++ includes: DiagKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiagKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DiagKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, diag=1.0) -> DiagKernel
        __init__(self, size) -> DiagKernel
        __init__(self, l, r, diag=1.0) -> DiagKernel
        __init__(self, l, r) -> DiagKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        diag:  diagonal 
        """
        this = _Kernel.new_DiagKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_DiagKernel
    __del__ = lambda self : None;
DiagKernel_swigregister = _Kernel.DiagKernel_swigregister
DiagKernel_swigregister(DiagKernel)

class DiceKernelNormalizer(KernelNormalizer):
    """
    DiceKernelNormalizer performs kernel normalization inspired by the
    Dice coefficient (seehttp://en.wikipedia.org/wiki/Dice's_coefficient).

    \\[ k'({\\bf x},{\\bf x'}) = \\frac{2k({\\bf x},{\\bf
    x'})}{k({\\bf x},{\\bf x})+k({\\bf x'},{\\bf x'}} \\]

    C++ includes: DiceKernelNormalizer.h 
    """
    __swig_setmethods__ = {}
    for _s in [KernelNormalizer]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DiceKernelNormalizer, name, value)
    __swig_getmethods__ = {}
    for _s in [KernelNormalizer]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DiceKernelNormalizer, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_DiceKernelNormalizer
    __del__ = lambda self : None;
    def alloc_and_compute_diag(*args):
        """
        alloc_and_compute_diag(self, k, v, num) -> bool

        alloc and compute the vector containing the square root of the
        diagonal elements of this kernel. 
        """
        return _Kernel.DiceKernelNormalizer_alloc_and_compute_diag(*args)

DiceKernelNormalizer_swigregister = _Kernel.DiceKernelNormalizer_swigregister
DiceKernelNormalizer_swigregister(DiceKernelNormalizer)

class DistanceKernel(Kernel):
    """
    The Distance kernel takes a distance as input.

    It turns a distance into something kernel like by computing

    \\[ k({\\bf x}, {\\bf x'}) = e^{-\\frac{dist({\\bf x},
    {\\bf x'})}{width}} \\]

    C++ includes: DistanceKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [Kernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DistanceKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [Kernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DistanceKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, cache, width, dist) -> DistanceKernel
        __init__(self, l, r, width, dist) -> DistanceKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        width:  width

        dist:  distance 
        """
        this = _Kernel.new_DistanceKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_DistanceKernel
    __del__ = lambda self : None;
DistanceKernel_swigregister = _Kernel.DistanceKernel_swigregister
DistanceKernel_swigregister(DistanceKernel)

class FixedDegreeStringKernel(StringCharKernel):
    """
    The FixedDegree String kernel takes as input two strings of same size
    and counts the number of matches of length d.

    \\[ k({\\bf x}, {\\bf x'}) = \\sum_{i=0}^{l-d} I({\\bf
    x}_{i,i+1,\\dots,i+d-1} = {\\bf x'}_{i,i+1,\\dots,i+d-1}) \\]

    Note that additional normalisation is applied, i.e. \\[ k'({\\bf
    x}, {\\bf x'})=\\frac{k({\\bf x}, {\\bf
    x'})}{\\sqrt{k({\\bf x}, {\\bf x})k({\\bf x'}, {\\bf x'})}}
    \\]

    C++ includes: FixedDegreeStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringCharKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FixedDegreeStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringCharKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, FixedDegreeStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, degree) -> FixedDegreeStringKernel
        __init__(self, l, r, degree) -> FixedDegreeStringKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        degree:  the degree 
        """
        this = _Kernel.new_FixedDegreeStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_FixedDegreeStringKernel
    __del__ = lambda self : None;
FixedDegreeStringKernel_swigregister = _Kernel.FixedDegreeStringKernel_swigregister
FixedDegreeStringKernel_swigregister(FixedDegreeStringKernel)

class GaussianKernel(RealKernel):
    """
    The well known Gaussian kernel (swiss army knife for SVMs) on dense
    real valued features.

    It is computed as

    \\[ k({\\bf x},{\\bf x'})= exp(-\\frac{||{\\bf x}-{\\bf
    x'}||^2}{\\tau}) \\]

    where $\\tau$ is the kernel width.

    C++ includes: GaussianKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [RealKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GaussianKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [RealKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GaussianKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> GaussianKernel
        __init__(self, size, width) -> GaussianKernel
        __init__(self, l, r, width, size=10) -> GaussianKernel
        __init__(self, l, r, width) -> GaussianKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        width:  width

        size:  cache size 
        """
        this = _Kernel.new_GaussianKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_GaussianKernel
    __del__ = lambda self : None;
GaussianKernel_swigregister = _Kernel.GaussianKernel_swigregister
GaussianKernel_swigregister(GaussianKernel)

class GaussianShiftKernel(GaussianKernel):
    """
    An experimental kernel inspired by the
    WeightedDegreePositionStringKernel and the Gaussian kernel.

    It is computed as

    \\[ k({\\bf x},{\\bf x'})= \\exp(-\\frac{||{\\bf
    x}-{\\bf x'}||^2}{\\tau}) +
    \\sum_{s=1}^{S_{\\mathrm{max}}/S_{\\mathrm{step}}}
    \\frac{1}{2s} \\exp(-\\frac{||{\\bf x}_{[1:|{\\bf
    x}|-sS_{\\mathrm{step}}]}-{\\bf
    x'}_{[sS_{\\mathrm{step}}:|{\\bf x}|]}||^2}{\\tau}) +
    \\sum_{s=1}^{S_{max}/S_{step}} \\frac{1}{2s}
    \\exp(-\\frac{||{\\bf x}_{[sS_{\\mathrm{step}}:|{\\bf
    x}|]}-{\\bf x'}_{[1:|{\\bf
    x}|-sS_{\\mathrm{step}}]}||^2}{\\tau}) + \\]

    where $\\tau$ is the kernel width. The idea is to shift the
    dimensions of the input vectors against eachother.
    $S_{\\mathrm{step}}$ is the step size (parameter shift_step) of the
    shifts and $S_{\\mathrm{max}}$ (parameter max_shift) is the maximal
    shift.

    C++ includes: GaussianShiftKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [GaussianKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GaussianShiftKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [GaussianKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GaussianShiftKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, width, max_shift, shift_step) -> GaussianShiftKernel
        __init__(self, l, r, width, max_shift, shift_step, size=10) -> GaussianShiftKernel
        __init__(self, l, r, width, max_shift, shift_step) -> GaussianShiftKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        width:  width

        max_shift:  maximum shift

        shift_step:  shift step

        size:  cache size 
        """
        this = _Kernel.new_GaussianShiftKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_GaussianShiftKernel
    __del__ = lambda self : None;
GaussianShiftKernel_swigregister = _Kernel.GaussianShiftKernel_swigregister
GaussianShiftKernel_swigregister(GaussianShiftKernel)

class GaussianShortRealKernel(ShortRealKernel):
    """
    The well known Gaussian kernel (swiss army knife for SVMs) on dense
    short-real valued features.

    It is computed as

    \\[ k({\\bf x},{\\bf x'})= exp(-\\frac{||{\\bf x}-{\\bf
    x'}||^2}{\\tau}) \\]

    where $\\tau$ is the kernel width.

    C++ includes: GaussianShortRealKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [ShortRealKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GaussianShortRealKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [ShortRealKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GaussianShortRealKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, width) -> GaussianShortRealKernel
        __init__(self, l, r, width, size=10) -> GaussianShortRealKernel
        __init__(self, l, r, width) -> GaussianShortRealKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        width:  width

        size:  cache size 
        """
        this = _Kernel.new_GaussianShortRealKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_GaussianShortRealKernel
    __del__ = lambda self : None;
GaussianShortRealKernel_swigregister = _Kernel.GaussianShortRealKernel_swigregister
GaussianShortRealKernel_swigregister(GaussianShortRealKernel)

class HistogramWordStringKernel(StringWordKernel):
    """
    The HistogramWordString computes the TOP kernel on inhomogeneous
    Markov Chains.

    C++ includes: HistogramWordStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringWordKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HistogramWordStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringWordKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HistogramWordStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, pie) -> HistogramWordStringKernel
        __init__(self, l, r, pie) -> HistogramWordStringKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        pie:  plugin estimate 
        """
        this = _Kernel.new_HistogramWordStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_HistogramWordStringKernel
    __del__ = lambda self : None;
HistogramWordStringKernel_swigregister = _Kernel.HistogramWordStringKernel_swigregister
HistogramWordStringKernel_swigregister(HistogramWordStringKernel)

class IdentityKernelNormalizer(KernelNormalizer):
    """
    Identity Kernel Normalization, i.e. no normalization is applied.

    C++ includes: IdentityKernelNormalizer.h 
    """
    __swig_setmethods__ = {}
    for _s in [KernelNormalizer]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IdentityKernelNormalizer, name, value)
    __swig_getmethods__ = {}
    for _s in [KernelNormalizer]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, IdentityKernelNormalizer, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> IdentityKernelNormalizer

        default constructor 
        """
        this = _Kernel.new_IdentityKernelNormalizer(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_IdentityKernelNormalizer
    __del__ = lambda self : None;
IdentityKernelNormalizer_swigregister = _Kernel.IdentityKernelNormalizer_swigregister
IdentityKernelNormalizer_swigregister(IdentityKernelNormalizer)

class LinearByteKernel(ByteKernel):
    """
    Computes the standard linear kernel on dense byte valued features.

    Formally, it computes

    \\[ k({\\bf x},{\\bf x'})= {\\bf x}\\cdot {\\bf x'} \\]

    C++ includes: LinearByteKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [ByteKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinearByteKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [ByteKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LinearByteKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> LinearByteKernel
        __init__(self, l, r) -> LinearByteKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side 
        """
        this = _Kernel.new_LinearByteKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_LinearByteKernel
    __del__ = lambda self : None;
LinearByteKernel_swigregister = _Kernel.LinearByteKernel_swigregister
LinearByteKernel_swigregister(LinearByteKernel)

class LinearKernel(RealKernel):
    """
    Computes the standard linear kernel on dense real valued features.

    Formally, it computes

    \\[ k({\\bf x},{\\bf x'})= {\\bf x}\\cdot {\\bf x'} \\]

    C++ includes: LinearKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [RealKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinearKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [RealKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LinearKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> LinearKernel
        __init__(self, l, r) -> LinearKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side 
        """
        this = _Kernel.new_LinearKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_LinearKernel
    __del__ = lambda self : None;
    def get_normal(*args):
        """
        get_normal(self, len) -> float

        get normal

        Parameters:
        -----------

        len:  where length of normal vector will be stored

        normal vector 
        """
        return _Kernel.LinearKernel_get_normal(*args)

    def get_w(*args):
        """
        get_w(self, dst_w)

        get normal vector (swig compatible)

        Parameters:
        -----------

        dst_w:  store w in this argument

        dst_dims:  dimension of w 
        """
        return _Kernel.LinearKernel_get_w(*args)

    def set_w(*args):
        """
        set_w(self, src_w)

        set normal vector (swig compatible)

        Parameters:
        -----------

        src_w:  new w

        src_w_dim:  dimension of new w - must fit dim of lhs 
        """
        return _Kernel.LinearKernel_set_w(*args)

LinearKernel_swigregister = _Kernel.LinearKernel_swigregister
LinearKernel_swigregister(LinearKernel)

class LinearStringKernel(StringCharKernel):
    """
    Computes the standard linear kernel on dense str valued features.

    Formally, it computes

    \\[ k({\\bf x},{\\bf x'})= \\frac{1}{scale}{\\bf x}\\cdot
    {\\bf x'} \\]

    Note: Basically the same as LinearByteKernel but on signed strs.

    C++ includes: LinearStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringCharKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinearStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringCharKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LinearStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> LinearStringKernel
        __init__(self, l, r) -> LinearStringKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side 
        """
        this = _Kernel.new_LinearStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_LinearStringKernel
    __del__ = lambda self : None;
LinearStringKernel_swigregister = _Kernel.LinearStringKernel_swigregister
LinearStringKernel_swigregister(LinearStringKernel)

class LinearWordKernel(WordKernel):
    """
    Computes the standard linear kernel on dense word (2-byte) valued
    features.

    Formally, it computes

    \\[ k({\\bf x},{\\bf x'})= \\frac{1}{scale}{\\bf x}\\cdot
    {\\bf x'} \\]

    C++ includes: LinearWordKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [WordKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LinearWordKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [WordKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LinearWordKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> LinearWordKernel
        __init__(self, l, r) -> LinearWordKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side 
        """
        this = _Kernel.new_LinearWordKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_LinearWordKernel
    __del__ = lambda self : None;
LinearWordKernel_swigregister = _Kernel.LinearWordKernel_swigregister
LinearWordKernel_swigregister(LinearWordKernel)

LOGSUM_TBL = _Kernel.LOGSUM_TBL
class LocalAlignmentStringKernel(StringCharKernel):
    """
    The LocalAlignmentString kernel compares two sequences through all
    possible local alignments between the two sequences.

    The implementation is taken fromhttp://www.mloss.org/software/view/40/
    and only adjusted to work with shogun.

    C++ includes: LocalAlignmentStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringCharKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocalAlignmentStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringCharKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LocalAlignmentStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size) -> LocalAlignmentStringKernel
        __init__(self, l, r) -> LocalAlignmentStringKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side 
        """
        this = _Kernel.new_LocalAlignmentStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_LocalAlignmentStringKernel
    __del__ = lambda self : None;
LocalAlignmentStringKernel_swigregister = _Kernel.LocalAlignmentStringKernel_swigregister
LocalAlignmentStringKernel_swigregister(LocalAlignmentStringKernel)

class LocalityImprovedStringKernel(StringCharKernel):
    """
    The LocalityImprovedString kernel is inspired by the polynomial
    kernel. Comparing neighboring stracters it puts emphasize on local
    features.

    It can be defined as \\[ K({\\bf x},{\\bf
    x'})=\\left(\\sum_{i=0}^{T-1}\\left(\\sum_{j=-l}^{+l}w_jI_{i+j}({\\bf
    x},{\\bf x'})\\right)^{d_1}\\right)^{d_2}, \\] where $
    I_i({\\bf x},{\\bf x'})=1$ if $x_i=x'_i$ and 0 otherwise.

    C++ includes: LocalityImprovedStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringCharKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LocalityImprovedStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringCharKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, LocalityImprovedStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, length, inner_degree, outer_degree) -> LocalityImprovedStringKernel
        __init__(self, l, r, length, inner_degree, outer_degree) -> LocalityImprovedStringKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        length:  length

        inner_degree:  inner degree

        outer_degree:  outer degree 
        """
        this = _Kernel.new_LocalityImprovedStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_LocalityImprovedStringKernel
    __del__ = lambda self : None;
LocalityImprovedStringKernel_swigregister = _Kernel.LocalityImprovedStringKernel_swigregister
LocalityImprovedStringKernel_swigregister(LocalityImprovedStringKernel)

class MatchWordStringKernel(StringWordKernel):
    """
    The class MatchWordStringKernel computes a variant of the polynomial
    kernel on strings of same length converted to a word alphabet.

    It is computed as

    \\[ k({\\bf x},{\\bf x'})= \\sum_{i=0}^L I(x_i=x'_i)+c)^d
    \\]

    where I is the indicator function which evaluates to 1 if its argument
    is true and to 0 otherwise.

    Note that additional normalisation is applied, i.e. \\[ k'({\\bf
    x}, {\\bf x'})=\\frac{k({\\bf x}, {\\bf
    x'})}{\\sqrt{k({\\bf x}, {\\bf x})k({\\bf x'}, {\\bf x'})}}
    \\]

    C++ includes: MatchWordStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringWordKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MatchWordStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringWordKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MatchWordStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, d) -> MatchWordStringKernel
        __init__(self, l, r, degree) -> MatchWordStringKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        degree:  degree 
        """
        this = _Kernel.new_MatchWordStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_MatchWordStringKernel
    __del__ = lambda self : None;
MatchWordStringKernel_swigregister = _Kernel.MatchWordStringKernel_swigregister
MatchWordStringKernel_swigregister(MatchWordStringKernel)

class MultitaskKernelNormalizer(KernelNormalizer):
    """
    The MultitaskKernel allows Multitask Learning via a modified kernel
    function.

    This effectively normalizes the vectors in feature space to norm 1
    (see CSqrtDiagKernelNormalizer)

    \\[ k'({\\bf x},{\\bf x'}) = ... \\]

    C++ includes: MultitaskKernelNormalizer.h 
    """
    __swig_setmethods__ = {}
    for _s in [KernelNormalizer]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultitaskKernelNormalizer, name, value)
    __swig_getmethods__ = {}
    for _s in [KernelNormalizer]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultitaskKernelNormalizer, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> MultitaskKernelNormalizer
        __init__(self, task_lhs, task_rhs) -> MultitaskKernelNormalizer

        default constructor

        Parameters:
        -----------

        task_lhs:  task vector with containing task_id for each example for
        left hand side

        task_rhs:  task vector with containing task_id for each example for
        right hand side 
        """
        this = _Kernel.new_MultitaskKernelNormalizer(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_MultitaskKernelNormalizer
    __del__ = lambda self : None;
    def get_task_vector_lhs(*args):
        """
        get_task_vector_lhs(self) -> IntVector

        vec task vector with containing task_id for each example on left hand
        side 
        """
        return _Kernel.MultitaskKernelNormalizer_get_task_vector_lhs(*args)

    def set_task_vector_lhs(*args):
        """
        set_task_vector_lhs(self, vec)

        Parameters:

        vec:  task vector with containing task_id for each example 
        """
        return _Kernel.MultitaskKernelNormalizer_set_task_vector_lhs(*args)

    def get_task_vector_rhs(*args):
        """
        get_task_vector_rhs(self) -> IntVector

        vec task vector with containing task_id for each example on right hand
        side 
        """
        return _Kernel.MultitaskKernelNormalizer_get_task_vector_rhs(*args)

    def set_task_vector_rhs(*args):
        """
        set_task_vector_rhs(self, vec)

        Parameters:

        vec:  task vector with containing task_id for each example 
        """
        return _Kernel.MultitaskKernelNormalizer_set_task_vector_rhs(*args)

    def set_task_vector(*args):
        """
        set_task_vector(self, vec)

        Parameters:

        vec:  task vector with containing task_id for each example 
        """
        return _Kernel.MultitaskKernelNormalizer_set_task_vector(*args)

    def get_task_similarity(*args):
        """
        get_task_similarity(self, task_lhs, task_rhs) -> float

        Parameters:

        task_lhs:  task_id on left hand side

        task_rhs:  task_id on right hand side

        similarity between tasks 
        """
        return _Kernel.MultitaskKernelNormalizer_get_task_similarity(*args)

    def set_task_similarity(*args):
        """
        set_task_similarity(self, task_lhs, task_rhs, similarity)

        Parameters:

        task_lhs:  task_id on left hand side

        task_rhs:  task_id on right hand side

        similarity:  similarity between tasks 
        """
        return _Kernel.MultitaskKernelNormalizer_set_task_similarity(*args)

MultitaskKernelNormalizer_swigregister = _Kernel.MultitaskKernelNormalizer_swigregister
MultitaskKernelNormalizer_swigregister(MultitaskKernelNormalizer)

class OligoStringKernel(StringCharKernel):
    """
    This class offers access to the Oligo Kernel introduced by Meinicke et
    al. in 2004.

    The class has functions to preprocess the data such that the kernel
    computation can be pursued faster. The kernel function is then
    kernelOligoFast or kernelOligo.

    Requires significant speedup, should be working but as is might be
    applicable only to academic small scale problems:

    the kernel should only ever see encoded sequences, which however
    requires another OligoFeatures object (using CSimpleFeatures of pairs)

    Uses CSqrtDiagKernelNormalizer, as the vanilla kernel seems to be very
    diagonally dominant.

    C++ includes: OligoStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringCharKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OligoStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringCharKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, OligoStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, cache_size, k, width) -> OligoStringKernel

        Constructor

        Parameters:
        -----------

        cache_size:  cache size for kernel

        k:  k-mer length

        width:  - equivalent to 2*sigma^2 
        """
        this = _Kernel.new_OligoStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_OligoStringKernel
    __del__ = lambda self : None;
    def compute(*args):
        """
        compute(self, x, y) -> float

        compute kernel function for features a and b idx_{a,b} denote the
        index of the feature vectors in the corresponding feature object

        abstract base method

        Parameters:
        -----------

        x:  index a

        y:  index b

        computed kernel function at indices a,b 
        """
        return _Kernel.OligoStringKernel_compute(*args)

OligoStringKernel_swigregister = _Kernel.OligoStringKernel_swigregister
OligoStringKernel_swigregister(OligoStringKernel)

class PolyKernel(RealKernel):
    """
    Computes the standard polynomial kernel on dense real valued features.

    Formally, it computes

    \\[ k({\\bf x},{\\bf x'})= ({\\bf x}\\cdot {\\bf x'}+c)^d
    \\]

    Note that additional normalisation is applied, i.e. \\[ k'({\\bf
    x}, {\\bf x'})=\\frac{k({\\bf x}, {\\bf
    x'})}{\\sqrt{k({\\bf x}, {\\bf x})k({\\bf x'}, {\\bf x'})}}
    \\]

    C++ includes: PolyKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [RealKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolyKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [RealKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PolyKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, l, r, d, inhom, size=10) -> PolyKernel
        __init__(self, l, r, d, inhom) -> PolyKernel
        __init__(self, size, degree, inhomogene=True) -> PolyKernel
        __init__(self, size, degree) -> PolyKernel

        constructor

        Parameters:
        -----------

        size:  cache size

        degree:  degree

        inhomogene:  is inhomogeneous 
        """
        this = _Kernel.new_PolyKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_PolyKernel
    __del__ = lambda self : None;
PolyKernel_swigregister = _Kernel.PolyKernel_swigregister
PolyKernel_swigregister(PolyKernel)

class PolyMatchStringKernel(StringCharKernel):
    """
    The class PolyMatchStringKernel computes a variant of the polynomial
    kernel on strings of same length.

    It is computed as

    \\[ k({\\bf x},{\\bf x'})= (\\sum_{i=0}^L I(x_i=x'_i)+c)^d
    \\]

    where I is the indicator function which evaluates to 1 if its argument
    is true and to 0 otherwise.

    Note that additional normalisation is applied, i.e. \\[ k'({\\bf
    x}, {\\bf x'})=\\frac{k({\\bf x}, {\\bf
    x'})}{\\sqrt{k({\\bf x}, {\\bf x})k({\\bf x'}, {\\bf x'})}}
    \\]

    C++ includes: PolyMatchStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringCharKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolyMatchStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringCharKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PolyMatchStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, degree, inhomogene) -> PolyMatchStringKernel
        __init__(self, l, r, degree, inhomogene) -> PolyMatchStringKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        degree:  degree

        inhomogene:  is inhomogeneous 
        """
        this = _Kernel.new_PolyMatchStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_PolyMatchStringKernel
    __del__ = lambda self : None;
PolyMatchStringKernel_swigregister = _Kernel.PolyMatchStringKernel_swigregister
PolyMatchStringKernel_swigregister(PolyMatchStringKernel)

class RegulatoryModulesStringKernel(StringCharKernel):
    """
    The Regulaty Modules kernel, based on the WD kernel, as published in
    Schultheiss et al., Bioinformatics (2009) on regulatory sequences.

    C++ includes: RegulatoryModulesStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringCharKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RegulatoryModulesStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringCharKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, RegulatoryModulesStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, width, degree, shift, window) -> RegulatoryModulesStringKernel
        __init__(self, lstr, rstr, lpos, rpos, width, degree, shift, window, 
            size=10) -> RegulatoryModulesStringKernel
        __init__(self, lstr, rstr, lpos, rpos, width, degree, shift, window) -> RegulatoryModulesStringKernel

        constructor

        Parameters:
        -----------

        lstr:  string features of left-hand side

        rstr:  string features of right-hand side

        lpos:  motif positions on lhs

        rpos:  motif positions on rhs

        width:  width of gaussian kernel

        degree:  degree of wds kernel

        shift:  shift of wds kernel

        window:  size of window around motifs to compute wds kernels on

        size:  cache size 
        """
        this = _Kernel.new_RegulatoryModulesStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_RegulatoryModulesStringKernel
    __del__ = lambda self : None;
    def set_motif_positions(*args):
        """
        set_motif_positions(self, positions_lhs, positions_rhs)

        set motif positions

        Parameters:
        -----------

        positions_lhs:  motif positions on lhs

        positions_rhs:  motif positions on rhs 
        """
        return _Kernel.RegulatoryModulesStringKernel_set_motif_positions(*args)

RegulatoryModulesStringKernel_swigregister = _Kernel.RegulatoryModulesStringKernel_swigregister
RegulatoryModulesStringKernel_swigregister(RegulatoryModulesStringKernel)

class PolyMatchWordStringKernel(StringWordKernel):
    """
    The class PolyMatchWordStringKernel computes a variant of the
    polynomial kernel on word-features.

    It makes sense for strings of same length mapped to word features and
    is computed as

    \\[ k({\\bf x},{\\bf x'})= (\\sum_{i=0}^L I(x_i=x'_i)+c)^d
    \\]

    where I is the indicator function which evaluates to 1 if its argument
    is true and to 0 otherwise.

    Note that additional normalisation is applied, i.e. \\[ k'({\\bf
    x}, {\\bf x'})=\\frac{k({\\bf x}, {\\bf
    x'})}{\\sqrt{k({\\bf x}, {\\bf x})k({\\bf x'}, {\\bf x'})}}
    \\]

    C++ includes: PolyMatchWordStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringWordKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PolyMatchWordStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringWordKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PolyMatchWordStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, degree, inhomogene) -> PolyMatchWordStringKernel
        __init__(self, l, r, degree, inhomogene) -> PolyMatchWordStringKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        degree:  degree

        inhomogene:  is inhomogeneous 
        """
        this = _Kernel.new_PolyMatchWordStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_PolyMatchWordStringKernel
    __del__ = lambda self : None;
PolyMatchWordStringKernel_swigregister = _Kernel.PolyMatchWordStringKernel_swigregister
PolyMatchWordStringKernel_swigregister(PolyMatchWordStringKernel)

class SalzbergWordStringKernel(StringWordKernel):
    """
    The SalzbergWordString kernel implements the Salzberg kernel.

    It is described in

    Engineering Support Vector Machine Kernels That Recognize Translation
    Initiation Sites A. Zien, G.Raetsch, S. Mika, B. Schoelkopf, T.
    Lengauer, K.-R. Mueller

    C++ includes: SalzbergWordStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringWordKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SalzbergWordStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringWordKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SalzbergWordStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, pie, labels=None) -> SalzbergWordStringKernel
        __init__(self, size, pie) -> SalzbergWordStringKernel
        __init__(self, l, r, pie, labels=None) -> SalzbergWordStringKernel
        __init__(self, l, r, pie) -> SalzbergWordStringKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        pie:  the plugin estimate

        labels:  optional labels to set prior from 
        """
        this = _Kernel.new_SalzbergWordStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_SalzbergWordStringKernel
    __del__ = lambda self : None;
    def set_prior_probs(*args):
        """
        set_prior_probs(self, pos_prior_, neg_prior_)

        set prior probs

        Parameters:
        -----------

        pos_prior_:  positive prior

        neg_prior_:  negative prior 
        """
        return _Kernel.SalzbergWordStringKernel_set_prior_probs(*args)

    def set_prior_probs_from_labels(*args):
        """
        set_prior_probs_from_labels(self, labels)

        set prior probs from labels

        Parameters:
        -----------

        labels:  labels to set prior probabilites from 
        """
        return _Kernel.SalzbergWordStringKernel_set_prior_probs_from_labels(*args)

SalzbergWordStringKernel_swigregister = _Kernel.SalzbergWordStringKernel_swigregister
SalzbergWordStringKernel_swigregister(SalzbergWordStringKernel)

class SigmoidKernel(RealKernel):
    """
    The standard Sigmoid kernel computed on dense real valued features.

    Formally, it is computed as

    \\[ k({\\bf x},{\\bf x'})=\\mbox{tanh}(\\gamma {\\bf
    x}\\cdot{\\bf x'}+c) \\]

    C++ includes: SigmoidKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [RealKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SigmoidKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [RealKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SigmoidKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, gamma, coef0) -> SigmoidKernel
        __init__(self, l, r, size, gamma, coef0) -> SigmoidKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        size:  cache size

        gamma:  gamma

        coef0:  coefficient 0 
        """
        this = _Kernel.new_SigmoidKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_SigmoidKernel
    __del__ = lambda self : None;
SigmoidKernel_swigregister = _Kernel.SigmoidKernel_swigregister
SigmoidKernel_swigregister(SigmoidKernel)

class SimpleLocalityImprovedStringKernel(StringCharKernel):
    """
    SimpleLocalityImprovedString kernel, is a ``simplified'' and better
    performing version of the Locality improved kernel.

    It can be defined as

    \\[ K({\\bf x},{\\bf
    x'})=\\left(\\sum_{i=0}^{T-1}\\left(\\sum_{j=-l}^{+l}w_jI_{i+j}({\\bf
    x},{\\bf x'})\\right)^{d_1}\\right)^{d_2}, \\] where $
    I_i({\\bf x},{\\bf x'})=1$ if $x_i=x'_i$ and 0 otherwise.

    C++ includes: SimpleLocalityImprovedStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringCharKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimpleLocalityImprovedStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringCharKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SimpleLocalityImprovedStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, length, inner_degree, outer_degree) -> SimpleLocalityImprovedStringKernel
        __init__(self, l, r, length, inner_degree, outer_degree) -> SimpleLocalityImprovedStringKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        length:  length

        inner_degree:  inner degree

        outer_degree:  outer degree 
        """
        this = _Kernel.new_SimpleLocalityImprovedStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_SimpleLocalityImprovedStringKernel
    __del__ = lambda self : None;
SimpleLocalityImprovedStringKernel_swigregister = _Kernel.SimpleLocalityImprovedStringKernel_swigregister
SimpleLocalityImprovedStringKernel_swigregister(SimpleLocalityImprovedStringKernel)

class SparseGaussianKernel(SparseRealKernel):
    """
    The well known Gaussian kernel (swiss army knife for SVMs) on sparse
    real valued features.

    It is computed as

    \\[ k({\\bf x},{\\bf x'})= exp(-\\frac{||{\\bf x}-{\\bf
    x'}||^2}{\\tau}) \\]

    where $\\tau$ is the kernel width.

    C++ includes: SparseGaussianKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [SparseRealKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SparseGaussianKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [SparseRealKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SparseGaussianKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, width) -> SparseGaussianKernel
        __init__(self, l, r, width) -> SparseGaussianKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        width:  width 
        """
        this = _Kernel.new_SparseGaussianKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_SparseGaussianKernel
    __del__ = lambda self : None;
SparseGaussianKernel_swigregister = _Kernel.SparseGaussianKernel_swigregister
SparseGaussianKernel_swigregister(SparseGaussianKernel)

class SparseLinearKernel(SparseRealKernel):
    """
    Computes the standard linear kernel on sparse real valued features.

    Formally, it computes

    \\[ k({\\bf x},{\\bf x'})= \\Phi_k({\\bf x})\\cdot
    \\Phi_k({\\bf x'}) \\]

    C++ includes: SparseLinearKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [SparseRealKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SparseLinearKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [SparseRealKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SparseLinearKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> SparseLinearKernel
        __init__(self, l, r) -> SparseLinearKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side 
        """
        this = _Kernel.new_SparseLinearKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_SparseLinearKernel
    __del__ = lambda self : None;
    def get_normal(*args):
        """
        get_normal(self, len) -> float

        get normal

        Parameters:
        -----------

        len:  length of normal vector will be stored here

        the normal vector 
        """
        return _Kernel.SparseLinearKernel_get_normal(*args)

SparseLinearKernel_swigregister = _Kernel.SparseLinearKernel_swigregister
SparseLinearKernel_swigregister(SparseLinearKernel)

class SparsePolyKernel(SparseRealKernel):
    """
    Computes the standard polynomial kernel on sparse real valued
    features.

    Formally, it computes

    \\[ k({\\bf x},{\\bf x'})= ({\\bf x}\\cdot {\\bf x'}+c)^d
    \\]

    Note that additional normalisation is applied, i.e. \\[ k'({\\bf
    x}, {\\bf x'})=\\frac{k({\\bf x}, {\\bf
    x'})}{\\sqrt{k({\\bf x}, {\\bf x})k({\\bf x'}, {\\bf x'})}}
    \\]

    C++ includes: SparsePolyKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [SparseRealKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SparsePolyKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [SparseRealKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SparsePolyKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, l, r, size, d, inhom) -> SparsePolyKernel
        __init__(self, size, degree, inhomogene=True) -> SparsePolyKernel
        __init__(self, size, degree) -> SparsePolyKernel

        constructor

        Parameters:
        -----------

        size:  cache size

        degree:  degree

        inhomogene:  is inhomogeneous 
        """
        this = _Kernel.new_SparsePolyKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_SparsePolyKernel
    __del__ = lambda self : None;
SparsePolyKernel_swigregister = _Kernel.SparsePolyKernel_swigregister
SparsePolyKernel_swigregister(SparsePolyKernel)

class SqrtDiagKernelNormalizer(KernelNormalizer):
    """
    SqrtDiagKernelNormalizer divides by the Square Root of the product of
    the diagonal elements.

    This effectively normalizes the vectors in feature space to norm 1
    (see CSqrtDiagKernelNormalizer)

    \\[ k'({\\bf x},{\\bf x'}) = \\frac{k({\\bf x},{\\bf
    x'})}{\\sqrt{k({\\bf x},{\\bf x})k({\\bf x'},{\\bf x'})}}
    \\]

    C++ includes: SqrtDiagKernelNormalizer.h 
    """
    __swig_setmethods__ = {}
    for _s in [KernelNormalizer]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SqrtDiagKernelNormalizer, name, value)
    __swig_getmethods__ = {}
    for _s in [KernelNormalizer]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SqrtDiagKernelNormalizer, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, use_opt_diag=False) -> SqrtDiagKernelNormalizer
        __init__(self) -> SqrtDiagKernelNormalizer

        default constructor

        Parameters:
        -----------

        use_opt_diag:  - some kernels support faster diagonal compuation via
        compute_diag(idx), this flag enables this 
        """
        this = _Kernel.new_SqrtDiagKernelNormalizer(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_SqrtDiagKernelNormalizer
    __del__ = lambda self : None;
    def alloc_and_compute_diag(*args):
        """
        alloc_and_compute_diag(self, k, v, num) -> bool

        alloc and compute the vector containing the square root of the
        diagonal elements of this kernel. 
        """
        return _Kernel.SqrtDiagKernelNormalizer_alloc_and_compute_diag(*args)

SqrtDiagKernelNormalizer_swigregister = _Kernel.SqrtDiagKernelNormalizer_swigregister
SqrtDiagKernelNormalizer_swigregister(SqrtDiagKernelNormalizer)

class TanimotoKernelNormalizer(KernelNormalizer):
    """
    TanimotoKernelNormalizer performs kernel normalization inspired by the
    Tanimoto coefficient (seehttp://en.wikipedia.org/wiki/Jaccard_index ).

    \\[ k'({\\bf x},{\\bf x'}) = \\frac{k({\\bf x},{\\bf
    x'})}{k({\\bf x},{\\bf x})+k({\\bf x'},{\\bf x'})-k({\\bf
    x},{\\bf x'})} \\]

    C++ includes: TanimotoKernelNormalizer.h 
    """
    __swig_setmethods__ = {}
    for _s in [KernelNormalizer]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TanimotoKernelNormalizer, name, value)
    __swig_getmethods__ = {}
    for _s in [KernelNormalizer]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TanimotoKernelNormalizer, name)
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _Kernel.delete_TanimotoKernelNormalizer
    __del__ = lambda self : None;
    def alloc_and_compute_diag(*args):
        """
        alloc_and_compute_diag(self, k, v, num) -> bool

        alloc and compute the vector containing the square root of the
        diagonal elements of this kernel. 
        """
        return _Kernel.TanimotoKernelNormalizer_alloc_and_compute_diag(*args)

TanimotoKernelNormalizer_swigregister = _Kernel.TanimotoKernelNormalizer_swigregister
TanimotoKernelNormalizer_swigregister(TanimotoKernelNormalizer)

class TensorProductPairKernel(IntKernel):
    """
    Computes the Tensor Product Pair Kernel (TPPK).

    Formally, it computes

    \\[ k_{\\mbox{tppk}}(({\\bf a},{\\bf b}), ({\\bf c},{\\bf
    d}))= k({\\bf a}, {\\bf c})\\cdot k({\\bf b}, {\\bf c}) +
    k({\\bf a},{\\bf d})\\cdot k({\\bf b}, {\\bf c}) \\]

    It is defined on pairs of inputs and a subkernel $k$. The subkernel
    has to be given on initialization. The pairs are specified via indizes
    (ab)using 2-dimensional integer features.

    Its feature space $\\Phi_{\\mbox{tppk}}$ is the tensor product of
    the feature spaces of the subkernel $k(.,.)$ on its input.

    It is often used in bioinformatics, e.g., to predict protein-protein
    interactions.

    C++ includes: TensorProductPairKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [IntKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TensorProductPairKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [IntKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TensorProductPairKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, subkernel) -> TensorProductPairKernel
        __init__(self, l, r, subkernel) -> TensorProductPairKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        subkernel:  the subkernel 
        """
        this = _Kernel.new_TensorProductPairKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_TensorProductPairKernel
    __del__ = lambda self : None;
TensorProductPairKernel_swigregister = _Kernel.TensorProductPairKernel_swigregister
TensorProductPairKernel_swigregister(TensorProductPairKernel)

class WeightedCommWordStringKernel(CommWordStringKernel):
    """
    The WeightedCommWordString kernel may be used to compute the weighted
    spectrum kernel (i.e. a spectrum kernel for 1 to K-mers, where each
    k-mer length is weighted by some coefficient $\\beta_k$) from
    strings that have been mapped into unsigned 16bit integers.

    These 16bit integers correspond to k-mers. To applicable in this
    kernel they need to be sorted (e.g. via the SortWordString pre-
    processor).

    It basically uses the algorithm in the unix "comm" command (hence
    the name) to compute:

    \\[ k({\\bf x},({\\bf x'})=
    \\sum_{k=1}^K\\beta_k\\Phi_k({\\bf x})\\cdot
    \\Phi_k({\\bf x'}) \\]

    where $\\Phi_k$ maps a sequence ${\\bf x}$ that consists of
    letters in $\\Sigma$ to a feature vector of size $|\\Sigma|^k$. In
    this feature vector each entry denotes how often the k-mer appears in
    that ${\\bf x}$.

    Note that this representation is especially tuned to small alphabets
    (like the 2-bit alphabet DNA), for which it enables spectrum kernels
    of order 8.

    For this kernel the linadd speedups are quite efficiently implemented
    using direct maps.

    C++ includes: WeightedCommWordStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [CommWordStringKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WeightedCommWordStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [CommWordStringKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WeightedCommWordStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, use_sign) -> WeightedCommWordStringKernel
        __init__(self, l, r, use_sign=False, size=10) -> WeightedCommWordStringKernel
        __init__(self, l, r, use_sign=False) -> WeightedCommWordStringKernel
        __init__(self, l, r) -> WeightedCommWordStringKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        use_sign:  if sign shall be used

        size:  cache size 
        """
        this = _Kernel.new_WeightedCommWordStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_WeightedCommWordStringKernel
    __del__ = lambda self : None;
    def merge_normal(*args):
        """
        merge_normal(self)

        merge normal 
        """
        return _Kernel.WeightedCommWordStringKernel_merge_normal(*args)

    def set_wd_weights(*args):
        """
        set_wd_weights(self) -> bool

        set weighted degree weights

        if setting was successful 
        """
        return _Kernel.WeightedCommWordStringKernel_set_wd_weights(*args)

    def set_weights(*args):
        """
        set_weights(self, w) -> bool

        set custom weights (swig compatible)

        Parameters:
        -----------

        w:  weights

        d:  degree (must match number of weights)

        if setting was successful 
        """
        return _Kernel.WeightedCommWordStringKernel_set_weights(*args)

    def compute_scoring(*args):
        """
        compute_scoring(self, max_degree, num_feat, num_sym, target, num_suppvec, 
            IDX, alphas, do_init=True) -> float
        compute_scoring(self, max_degree, num_feat, num_sym, target, num_suppvec, 
            IDX, alphas) -> float

        compute scoring

        Parameters:
        -----------

        max_degree:  maximum degree

        num_feat:  number of features

        num_sym:  number of symbols

        target:  target

        num_suppvec:  number of support vectors

        IDX:  IDX

        alphas:  alphas

        do_init:  if initialization shall be performed

        computed score 
        """
        return _Kernel.WeightedCommWordStringKernel_compute_scoring(*args)

WeightedCommWordStringKernel_swigregister = _Kernel.WeightedCommWordStringKernel_swigregister
WeightedCommWordStringKernel_swigregister(WeightedCommWordStringKernel)

class WeightedDegreePositionStringKernel(StringCharKernel):
    """
    The Weighted Degree Position String kernel (Weighted Degree kernel
    with shifts).

    The WD-shift kernel of order d compares two sequences ${\\bf x}$ and
    ${\\bf x'}$ of length L by summing all contributions of k-mer
    matches of lengths $k\\in\\{1,\\dots,d\\}$, weighted by
    coefficients $\\beta_k$ allowing for a positional tolerance of up to
    shift s.

    It is formally defined as \\begin{eqnarray*}
    &&\\!\\!\\!\\!\\!\\!\\!k({\\bf x}_i,{\\bf
    x}_j)=\\sum_{k=1}^d\\beta_k\\sum_{l=1}^{\\!\\!\\!\\!L-k+1\\!\\!\\!\\!}\\gamma_l\\sum_{\\begin{array}{c}s=0\\\\
    \\!\\!\\!\\!s+l\\leq
    L\\!\\!\\!\\!\\end{array}}^{S(l)}
    \\delta_s\\;\\mu_{k,l,s,{{\\bf x}_i},{{\\bf x}_j}},\\\\
    &&\\!\\!\\!\\!\\!\\!\\!\\!\\!\\! {\\footnotesize
    \\mu_{k,l,s,{{\\bf x}_i},{{\\bf x}_j}}\\!\\!\\!
    =\\!\\! I({\\bf u}_{k,l+s}({\\bf x}_i)\\! =\\!{\\bf
    u}_{k,l}({\\bf x}_j))\\! +\\!I({\\bf u}_{k,l}({\\bf
    x}_i)\\! =\\!{\\bf u}_{k,l+s}({\\bf x}_j))},\\nonumber
    \\end{eqnarray*} where $\\beta_j$ are the weighting coefficients
    of the j-mers, $\\gamma_l$ is a weighting over the position in the
    sequence, $\\delta_s=1/(2(s+1))$ is the weight assigned to shifts
    (in either direction) of extent s, and S(l) determines the shift range
    at position l.

    C++ includes: WeightedDegreePositionStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringCharKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WeightedDegreePositionStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringCharKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WeightedDegreePositionStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, size, degree, max_mismatch=0, mkl_stepsize=1) -> WeightedDegreePositionStringKernel
        __init__(self, size, degree, max_mismatch=0) -> WeightedDegreePositionStringKernel
        __init__(self, size, degree) -> WeightedDegreePositionStringKernel
        __init__(self, size, weights, degree, max_mismatch, shift, shift_len, 
            mkl_stepsize=1) -> WeightedDegreePositionStringKernel
        __init__(self, size, weights, degree, max_mismatch, shift, shift_len) -> WeightedDegreePositionStringKernel
        __init__(self, l, r, degree) -> WeightedDegreePositionStringKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        degree:  degree 
        """
        this = _Kernel.new_WeightedDegreePositionStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_WeightedDegreePositionStringKernel
    __del__ = lambda self : None;
    def init_optimization(*args):
        """
        init_optimization(self, p_count, IDX, alphas) -> bool
        init_optimization(self, count, IDX, alphas, tree_num, upto_tree=-1) -> bool
        init_optimization(self, count, IDX, alphas, tree_num) -> bool

        initialize optimization do initialization for tree_num up to
        upto_tree, use tree_num=-1 to construct all trees

        Parameters:
        -----------

        count:  count

        IDX:  IDX

        alphas:  alphas

        tree_num:  which tree

        upto_tree:  up to this tree

        if initializing was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_init_optimization(*args)

    def compute_batch_helper(*args):
        """compute_batch_helper(p) -> void"""
        return _Kernel.WeightedDegreePositionStringKernel_compute_batch_helper(*args)

    if _newclass:compute_batch_helper = staticmethod(compute_batch_helper)
    __swig_getmethods__["compute_batch_helper"] = lambda x: compute_batch_helper
    def compute_batch(*args):
        """
        compute_batch(self, num_vec, vec_idx, target, num_suppvec, IDX, alphas, 
            factor=1.0)
        compute_batch(self, num_vec, vec_idx, target, num_suppvec, IDX, alphas)

        compute batch

        Parameters:
        -----------

        num_vec:  number of vectors

        vec_idx:  vector index

        target:  target

        num_suppvec:  number of support vectors

        IDX:  IDX

        alphas:  alphas

        factor:  factor 
        """
        return _Kernel.WeightedDegreePositionStringKernel_compute_batch(*args)

    def compute_abs_weights(*args):
        """
        compute_abs_weights(self, len) -> float

        compute abs weights

        Parameters:
        -----------

        len:  len

        computed abs weights 
        """
        return _Kernel.WeightedDegreePositionStringKernel_compute_abs_weights(*args)

    def is_tree_initialized(*args):
        """
        is_tree_initialized(self) -> bool

        check if tree is initialized

        if tree is initialized 
        """
        return _Kernel.WeightedDegreePositionStringKernel_is_tree_initialized(*args)

    def get_max_mismatch(*args):
        """
        get_max_mismatch(self) ->  int

        get maximum mismatch

        maximum mismatch 
        """
        return _Kernel.WeightedDegreePositionStringKernel_get_max_mismatch(*args)

    def get_degree(*args):
        """
        get_degree(self) ->  int

        get degree

        the degree 
        """
        return _Kernel.WeightedDegreePositionStringKernel_get_degree(*args)

    def get_degree_weights(*args):
        """
        get_degree_weights(self, d, len) -> float

        get degree weights

        Parameters:
        -----------

        d:  degree weights will be stored here

        len:  number of degree weights will be stored here 
        """
        return _Kernel.WeightedDegreePositionStringKernel_get_degree_weights(*args)

    def get_weights(*args):
        """
        get_weights(self, num_weights) -> float

        get weights

        Parameters:
        -----------

        num_weights:  number of weights will be stored here

        weights 
        """
        return _Kernel.WeightedDegreePositionStringKernel_get_weights(*args)

    def get_position_weights(*args):
        """
        get_position_weights(self, len) -> float

        get position weights

        Parameters:
        -----------

        len:  number of position weights will be stored here

        position weights 
        """
        return _Kernel.WeightedDegreePositionStringKernel_get_position_weights(*args)

    def set_shifts(*args):
        """
        set_shifts(self, shifts) -> bool

        set shifts

        Parameters:
        -----------

        shifts:  new shifts

        len:  number of shifts 
        """
        return _Kernel.WeightedDegreePositionStringKernel_set_shifts(*args)

    def set_weights(*args):
        """
        set_weights(self, weights) -> bool
        set_weights(self, weights, d) -> bool

        set weights

        Parameters:
        -----------

        weights:  new weights

        d:  degree

        len:  number of weights 
        """
        return _Kernel.WeightedDegreePositionStringKernel_set_weights(*args)

    def set_wd_weights(*args):
        """
        set_wd_weights(self) -> bool

        set wd weights

        if setting was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_set_wd_weights(*args)

    def set_position_weights(*args):
        """
        set_position_weights(self, pws) -> bool

        set position weights

        Parameters:
        -----------

        pws:  new position weights

        len:  number of position weights

        if setting was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_set_position_weights(*args)

    def set_position_weights_lhs(*args):
        """
        set_position_weights_lhs(self, pws, num) -> bool

        set position weights for left-hand side

        Parameters:
        -----------

        pws:  new position weights

        len:  len

        num:  num

        if setting was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_set_position_weights_lhs(*args)

    def set_position_weights_rhs(*args):
        """
        set_position_weights_rhs(self, pws, num) -> bool

        set position weights for right-hand side

        Parameters:
        -----------

        pws:  new position weights

        len:  len

        num:  num

        if setting was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_set_position_weights_rhs(*args)

    def init_block_weights(*args):
        """
        init_block_weights(self) -> bool

        initialize block weights

        if initialization was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_init_block_weights(*args)

    def init_block_weights_from_wd(*args):
        """
        init_block_weights_from_wd(self) -> bool

        initialize block weights from weighted degree

        if initialization was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_init_block_weights_from_wd(*args)

    def init_block_weights_from_wd_external(*args):
        """
        init_block_weights_from_wd_external(self) -> bool

        initialize block weights from external weighted degree

        if initialization was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_init_block_weights_from_wd_external(*args)

    def init_block_weights_const(*args):
        """
        init_block_weights_const(self) -> bool

        initialize block weights constant

        if initialization was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_init_block_weights_const(*args)

    def init_block_weights_linear(*args):
        """
        init_block_weights_linear(self) -> bool

        initialize block weights linear

        if initialization was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_init_block_weights_linear(*args)

    def init_block_weights_sqpoly(*args):
        """
        init_block_weights_sqpoly(self) -> bool

        initialize block weights squared polynomial

        if initialization was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_init_block_weights_sqpoly(*args)

    def init_block_weights_cubicpoly(*args):
        """
        init_block_weights_cubicpoly(self) -> bool

        initialize block weights cubic polynomial

        if initialization was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_init_block_weights_cubicpoly(*args)

    def init_block_weights_exp(*args):
        """
        init_block_weights_exp(self) -> bool

        initialize block weights exponential

        if initialization was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_init_block_weights_exp(*args)

    def init_block_weights_log(*args):
        """
        init_block_weights_log(self) -> bool

        initialize block weights logarithmic

        if initialization was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_init_block_weights_log(*args)

    def init_block_weights_external(*args):
        """
        init_block_weights_external(self) -> bool

        initialize block weights external

        if initialization was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_init_block_weights_external(*args)

    def delete_position_weights(*args):
        """
        delete_position_weights(self) -> bool

        delete position weights

        if deleting was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_delete_position_weights(*args)

    def delete_position_weights_lhs(*args):
        """
        delete_position_weights_lhs(self) -> bool

        delete position weights left-hand side

        if deleting was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_delete_position_weights_lhs(*args)

    def delete_position_weights_rhs(*args):
        """
        delete_position_weights_rhs(self) -> bool

        delete position weights right-hand side

        if deleting was successful 
        """
        return _Kernel.WeightedDegreePositionStringKernel_delete_position_weights_rhs(*args)

    def compute_by_tree(*args):
        """
        compute_by_tree(self, idx) -> float
        compute_by_tree(self, idx, LevelContrib)

        compute by tree

        Parameters:
        -----------

        idx:  index

        LevelContrib:  level contribution 
        """
        return _Kernel.WeightedDegreePositionStringKernel_compute_by_tree(*args)

    def compute_scoring(*args):
        """
        compute_scoring(self, max_degree, num_feat, num_sym, target, num_suppvec, 
            IDX, weights) -> float

        compute positional scoring function, which assigns a weight per
        position, per symbol in the sequence

        Parameters:
        -----------

        max_degree:  maximum degree

        num_feat:  number of features

        num_sym:  number of symbols

        target:  target

        num_suppvec:  number of support vectors

        IDX:  IDX

        weights:  weights

        computed scores 
        """
        return _Kernel.WeightedDegreePositionStringKernel_compute_scoring(*args)

    def compute_consensus(*args):
        """
        compute_consensus(self, num_feat, num_suppvec, IDX, alphas) -> str

        compute consensus string

        Parameters:
        -----------

        num_feat:  number of features

        num_suppvec:  number of support vectors

        IDX:  IDX

        alphas:  alphas

        consensus string 
        """
        return _Kernel.WeightedDegreePositionStringKernel_compute_consensus(*args)

    def extract_w(*args):
        """
        extract_w(self, max_degree, num_feat, num_sym, w_result, num_suppvec, 
            IDX, alphas) -> float

        extract w

        Parameters:
        -----------

        max_degree:  maximum degree

        num_feat:  number of features

        num_sym:  number of symbols

        w_result:  w

        num_suppvec:  number of support vectors

        IDX:  IDX

        alphas:  alphas

        w 
        """
        return _Kernel.WeightedDegreePositionStringKernel_extract_w(*args)

    def compute_POIM(*args):
        """
        compute_POIM(self, max_degree, num_feat, num_sym, poim_result, num_suppvec, 
            IDX, alphas, distrib) -> float

        compute POIM

        Parameters:
        -----------

        max_degree:  maximum degree

        num_feat:  number of features

        num_sym:  number of symbols

        poim_result:  poim

        num_suppvec:  number of support vectors

        IDX:  IDX

        alphas:  alphas

        distrib:  distribution

        computed POIMs 
        """
        return _Kernel.WeightedDegreePositionStringKernel_compute_POIM(*args)

    def prepare_POIM2(*args):
        """
        prepare_POIM2(self, distrib)

        prepare POIM2

        Parameters:
        -----------

        num_feat:  number of features

        num_sym:  number of symbols

        distrib:  distribution 
        """
        return _Kernel.WeightedDegreePositionStringKernel_prepare_POIM2(*args)

    def compute_POIM2(*args):
        """
        compute_POIM2(self, max_degree, svm)

        compute POIM2

        Parameters:
        -----------

        max_degree:  maximum degree

        svm:  SVM 
        """
        return _Kernel.WeightedDegreePositionStringKernel_compute_POIM2(*args)

    def get_POIM2(*args):
        """
        get_POIM2(self) -> [] of float

        get POIM2

        Parameters:
        -----------

        poim:  POIMs (returned)

        result_len:  (returned) 
        """
        return _Kernel.WeightedDegreePositionStringKernel_get_POIM2(*args)

    def cleanup_POIM2(*args):
        """
        cleanup_POIM2(self)

        cleanup POIM2 
        """
        return _Kernel.WeightedDegreePositionStringKernel_cleanup_POIM2(*args)

WeightedDegreePositionStringKernel_swigregister = _Kernel.WeightedDegreePositionStringKernel_swigregister
WeightedDegreePositionStringKernel_swigregister(WeightedDegreePositionStringKernel)

def WeightedDegreePositionStringKernel_compute_batch_helper(*args):
  """WeightedDegreePositionStringKernel_compute_batch_helper(p) -> void"""
  return _Kernel.WeightedDegreePositionStringKernel_compute_batch_helper(*args)

E_WD = _Kernel.E_WD
E_EXTERNAL = _Kernel.E_EXTERNAL
E_BLOCK_CONST = _Kernel.E_BLOCK_CONST
E_BLOCK_LINEAR = _Kernel.E_BLOCK_LINEAR
E_BLOCK_SQPOLY = _Kernel.E_BLOCK_SQPOLY
E_BLOCK_CUBICPOLY = _Kernel.E_BLOCK_CUBICPOLY
E_BLOCK_EXP = _Kernel.E_BLOCK_EXP
E_BLOCK_LOG = _Kernel.E_BLOCK_LOG
E_BLOCK_EXTERNAL = _Kernel.E_BLOCK_EXTERNAL
class WeightedDegreeStringKernel(StringCharKernel):
    """
    The Weighted Degree String kernel.

    The WD kernel of order d compares two sequences ${\\bf x}$ and
    ${\\bf x'}$ of length L by summing all contributions of k-mer
    matches of lengths $k\\in\\{1,\\dots,d\\}$, weighted by
    coefficients $\\beta_k$. It is defined as \\[ k({\\bf x},{\\bf
    x'})=\\sum_{k=1}^d\\beta_k\\sum_{l=1}^{L-k+1}I({\\bf
    u}_{k,l}({\\bf x})={\\bf u}_{k,l}({\\bf x'})). \\] Here,
    ${\\bf u}_{k,l}({\\bf x})$ is the string of length k starting at
    position l of the sequence ${\\bf x}$ and $I(\\cdot)$ is the
    indicator function which evaluates to 1 when its argument is true and
    to 0 otherwise.

    C++ includes: WeightedDegreeStringKernel.h 
    """
    __swig_setmethods__ = {}
    for _s in [StringCharKernel]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WeightedDegreeStringKernel, name, value)
    __swig_getmethods__ = {}
    for _s in [StringCharKernel]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, WeightedDegreeStringKernel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, degree, type=E_WD) -> WeightedDegreeStringKernel
        __init__(self, degree) -> WeightedDegreeStringKernel
        __init__(self, weights, degree) -> WeightedDegreeStringKernel
        __init__(self, l, r, degree) -> WeightedDegreeStringKernel

        constructor

        Parameters:
        -----------

        l:  features of left-hand side

        r:  features of right-hand side

        degree:  degree 
        """
        this = _Kernel.new_WeightedDegreeStringKernel(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _Kernel.delete_WeightedDegreeStringKernel
    __del__ = lambda self : None;
    def get_type(*args):
        """
        get_type(self) -> EWDKernType

        get WD kernel weighting type

        weighting type

        See:  EWDKernType 
        """
        return _Kernel.WeightedDegreeStringKernel_get_type(*args)

    def init_optimization(*args):
        """
        init_optimization(self, count, IDX, alphas) -> bool
        init_optimization(self, count, IDX, alphas, tree_num) -> bool

        initialize optimization do initialization for tree_num up to
        upto_tree, use tree_num=-1 to construct all trees

        Parameters:
        -----------

        count:  count

        IDX:  IDX

        alphas:  alphas

        tree_num:  which tree

        if initializing was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_init_optimization(*args)

    def compute_batch_helper(*args):
        """compute_batch_helper(p) -> void"""
        return _Kernel.WeightedDegreeStringKernel_compute_batch_helper(*args)

    if _newclass:compute_batch_helper = staticmethod(compute_batch_helper)
    __swig_getmethods__["compute_batch_helper"] = lambda x: compute_batch_helper
    def compute_batch(*args):
        """
        compute_batch(self, num_vec, vec_idx, target, num_suppvec, IDX, alphas, 
            factor=1.0)
        compute_batch(self, num_vec, vec_idx, target, num_suppvec, IDX, alphas)

        compute batch

        Parameters:
        -----------

        num_vec:  number of vectors

        vec_idx:  vector index

        target:  target

        num_suppvec:  number of support vectors

        IDX:  IDX

        alphas:  alphas

        factor:  factor 
        """
        return _Kernel.WeightedDegreeStringKernel_compute_batch(*args)

    def compute_abs_weights(*args):
        """
        compute_abs_weights(self, len) -> float

        compute abs weights

        Parameters:
        -----------

        len:  len

        computed abs weights 
        """
        return _Kernel.WeightedDegreeStringKernel_compute_abs_weights(*args)

    def compute_by_tree(*args):
        """
        compute_by_tree(self, idx, LevelContrib)

        compute by tree

        Parameters:
        -----------

        idx:  index

        LevelContrib:  level contribution

        computed value 
        """
        return _Kernel.WeightedDegreeStringKernel_compute_by_tree(*args)

    def is_tree_initialized(*args):
        """
        is_tree_initialized(self) -> bool

        check if tree is initialized

        if tree is initialized 
        """
        return _Kernel.WeightedDegreeStringKernel_is_tree_initialized(*args)

    def get_degree_weights(*args):
        """
        get_degree_weights(self, d, len) -> float

        get degree weights

        Parameters:
        -----------

        d:  degree weights will be stored here

        len:  number of degree weights will be stored here 
        """
        return _Kernel.WeightedDegreeStringKernel_get_degree_weights(*args)

    def get_weights(*args):
        """
        get_weights(self, num_weights) -> float

        get weights

        Parameters:
        -----------

        num_weights:  number of weights will be stored here

        weights 
        """
        return _Kernel.WeightedDegreeStringKernel_get_weights(*args)

    def get_position_weights(*args):
        """
        get_position_weights(self, len) -> float

        get position weights

        Parameters:
        -----------

        len:  number of position weights will be stored here

        position weights 
        """
        return _Kernel.WeightedDegreeStringKernel_get_position_weights(*args)

    def set_wd_weights_by_type(*args):
        """
        set_wd_weights_by_type(self, type) -> bool

        set wd weights

        Parameters:
        -----------

        type:  weighted degree kernel type

        if setting was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_set_wd_weights_by_type(*args)

    def set_wd_weights(*args):
        """
        set_wd_weights(self, p_weights)

        set wd weights

        Parameters:
        -----------

        p_weights:  new eights

        d:  degree

        if setting was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_set_wd_weights(*args)

    def set_weights(*args):
        """
        set_weights(self, weights) -> bool

        set weights

        Parameters:
        -----------

        weights:  new weights

        d:  degree

        len:  number of weights 
        """
        return _Kernel.WeightedDegreeStringKernel_set_weights(*args)

    def set_position_weights(*args):
        """
        set_position_weights(self, position_weights, len=0) -> bool
        set_position_weights(self, position_weights) -> bool

        set position weights

        Parameters:
        -----------

        position_weights:  new position weights

        len:  number of position weights

        if setting was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_set_position_weights(*args)

    def init_block_weights(*args):
        """
        init_block_weights(self) -> bool

        initialize block weights

        if initialization was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_init_block_weights(*args)

    def init_block_weights_from_wd(*args):
        """
        init_block_weights_from_wd(self) -> bool

        initialize block weights from weighted degree

        if initialization was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_init_block_weights_from_wd(*args)

    def init_block_weights_from_wd_external(*args):
        """
        init_block_weights_from_wd_external(self) -> bool

        initialize block weights from external weighted degree

        if initialization was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_init_block_weights_from_wd_external(*args)

    def init_block_weights_const(*args):
        """
        init_block_weights_const(self) -> bool

        initialize block weights constant

        if initialization was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_init_block_weights_const(*args)

    def init_block_weights_linear(*args):
        """
        init_block_weights_linear(self) -> bool

        initialize block weights linear

        if initialization was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_init_block_weights_linear(*args)

    def init_block_weights_sqpoly(*args):
        """
        init_block_weights_sqpoly(self) -> bool

        initialize block weights squared polynomial

        if initialization was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_init_block_weights_sqpoly(*args)

    def init_block_weights_cubicpoly(*args):
        """
        init_block_weights_cubicpoly(self) -> bool

        initialize block weights cubic polynomial

        if initialization was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_init_block_weights_cubicpoly(*args)

    def init_block_weights_exp(*args):
        """
        init_block_weights_exp(self) -> bool

        initialize block weights exponential

        if initialization was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_init_block_weights_exp(*args)

    def init_block_weights_log(*args):
        """
        init_block_weights_log(self) -> bool

        initialize block weights logarithmic

        if initialization was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_init_block_weights_log(*args)

    def init_block_weights_external(*args):
        """
        init_block_weights_external(self) -> bool

        initialize block weights external

        if initialization was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_init_block_weights_external(*args)

    def delete_position_weights(*args):
        """
        delete_position_weights(self) -> bool

        delete position weights

        if deleting was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_delete_position_weights(*args)

    def set_max_mismatch(*args):
        """
        set_max_mismatch(self, max) -> bool

        set maximum mismatch

        Parameters:
        -----------

        max:  new maximum mismatch

        if setting was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_set_max_mismatch(*args)

    def get_max_mismatch(*args):
        """
        get_max_mismatch(self) ->  int
        get_max_mismatch(self) ->  int

        get maximum mismatch

        maximum mismatch 
        """
        return _Kernel.WeightedDegreeStringKernel_get_max_mismatch(*args)

    def set_degree(*args):
        """
        set_degree(self, deg) -> bool

        set degree

        Parameters:
        -----------

        deg:  new degree

        if setting was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_set_degree(*args)

    def get_degree(*args):
        """
        get_degree(self) ->  int
        get_degree(self) ->  int

        get degree

        degree 
        """
        return _Kernel.WeightedDegreeStringKernel_get_degree(*args)

    def set_use_block_computation(*args):
        """
        set_use_block_computation(self, block) -> bool

        set if block computation shall be performed

        Parameters:
        -----------

        block:  if block computation shall be performed

        if setting was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_set_use_block_computation(*args)

    def get_use_block_computation(*args):
        """
        get_use_block_computation(self) -> bool

        check if block computation is performed

        if block computation is performed 
        """
        return _Kernel.WeightedDegreeStringKernel_get_use_block_computation(*args)

    def set_mkl_stepsize(*args):
        """
        set_mkl_stepsize(self, step) -> bool

        set MKL steps ize

        Parameters:
        -----------

        step:  new step size

        if setting was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_set_mkl_stepsize(*args)

    def get_mkl_stepsize(*args):
        """
        get_mkl_stepsize(self) ->  int

        get MKL step size

        MKL step size 
        """
        return _Kernel.WeightedDegreeStringKernel_get_mkl_stepsize(*args)

    def set_which_degree(*args):
        """
        set_which_degree(self, which) -> bool

        set which degree

        Parameters:
        -----------

        which:  which degree

        if setting was successful 
        """
        return _Kernel.WeightedDegreeStringKernel_set_which_degree(*args)

    def get_which_degree(*args):
        """
        get_which_degree(self) ->  int

        get which degree

        which degree 
        """
        return _Kernel.WeightedDegreeStringKernel_get_which_degree(*args)

WeightedDegreeStringKernel_swigregister = _Kernel.WeightedDegreeStringKernel_swigregister
WeightedDegreeStringKernel_swigregister(WeightedDegreeStringKernel)

def WeightedDegreeStringKernel_compute_batch_helper(*args):
  """WeightedDegreeStringKernel_compute_batch_helper(p) -> void"""
  return _Kernel.WeightedDegreeStringKernel_compute_batch_helper(*args)



